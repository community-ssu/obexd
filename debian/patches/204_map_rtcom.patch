diff -crN Makefile.am Makefile.am
*** Makefile.am	Tue Oct  2 04:24:18 2012
--- Makefile.am	Tue Oct  2 05:04:47 2012
***************
*** 10,16 ****
  test_files = test/simple-agent test/send-files \
  		test/pull-business-card test/exchange-business-cards \
  		test/list-folders test/pbap-client test/ftp-client \
! 		test/map-client
  
  gdbus_sources = gdbus/gdbus.h gdbus/mainloop.c gdbus/watch.c \
  					gdbus/object.c gdbus/polkit.c
--- 10,16 ----
  test_files = test/simple-agent test/send-files \
  		test/pull-business-card test/exchange-business-cards \
  		test/list-folders test/pbap-client test/ftp-client \
! 		test/map-client test/mns-client
  
  gdbus_sources = gdbus/gdbus.h gdbus/mainloop.c gdbus/watch.c \
  					gdbus/object.c gdbus/polkit.c
***************
*** 63,68 ****
--- 63,70 ----
  
  builtin_modules += mas
  builtin_sources += plugins/mas.c plugins/messages.h \
+ 			plugins/bmsg.c plugins/bmsg.h \
+ 			plugins/bmsg_parser.c plugins/bmsg_parser.h \
  			src/map_ap.c src/map_ap.h
  
  builtin_modules += irmc
***************
*** 86,96 ****
--- 88,110 ----
  			src/transport.h src/transport.c \
  			src/server.h src/server.c
  
+ if MESSAGES_QT
+ 
+ src_obexd_LDADD = @DBUS_LIBS@ @GLIB_LIBS@ @GTHREAD_LIBS@ \
+ 					@EBOOK_LIBS@ @BLUEZ_LIBS@ \
+ 					@LIBICAL_LIBS@ @TRACKER_LIBS@ -ldl \
+ 					messages-qt/libmessages-qt.a \
+ 					@QTCORE_LIBS@ @COMMHISTORY_LIBS@
+ 
+ else
+ 
  src_obexd_LDADD = @DBUS_LIBS@ @GLIB_LIBS@ @GTHREAD_LIBS@ \
  					@EBOOK_LIBS@ @BLUEZ_LIBS@ \
  					@RTCOM_EVENTLOGGER_ASYNC_LIBS@ \
  					@LIBICAL_LIBS@ @TRACKER_LIBS@ -ldl
  
+ endif
+ 
  src_obexd_LDFLAGS = -Wl,--export-dynamic
  
  builtin_files = src/builtin.h $(builtin_nodist)
***************
*** 128,133 ****
--- 142,148 ----
  				client/agent.h client/agent.c \
  				client/transport.h client/transport.c \
  				client/driver.h client/driver.c \
+ 				client/mns.h client/mns.c \
  				src/map_ap.h src/map_ap.c
  
  client_obex_client_LDADD = @GLIB_LIBS@ @DBUS_LIBS@ @BLUEZ_LIBS@
***************
*** 151,157 ****
  			src/obexd.service.in client/obex-client.service.in \
  			plugins/phonebook-dummy.c plugins/phonebook-ebook.c \
  			plugins/phonebook-tracker.c \
! 			plugins/messages-dummy.c plugins/messages-tracker.c
  
  DISTCHECK_CONFIGURE_FLAGS = --enable-client --enable-server
  
--- 166,179 ----
  			src/obexd.service.in client/obex-client.service.in \
  			plugins/phonebook-dummy.c plugins/phonebook-ebook.c \
  			plugins/phonebook-tracker.c \
! 			plugins/messages-dummy.c plugins/messages-rtcom.c \
! 			plugins/messages-tracker.c \
! 			messages-qt/messages-qt.pro messages-qt/messages-qt.cpp \
! 			messages-qt/Makefile
! 
! if MESSAGES_QT
! SUBDIRS = messages-qt
! endif
  
  DISTCHECK_CONFIGURE_FLAGS = --enable-client --enable-server
  
diff -crN Makefile.in Makefile.in
*** Makefile.in	Tue Oct  2 04:24:18 2012
--- Makefile.in	Tue Oct  2 05:04:47 2012
***************
*** 117,123 ****
  	client/opp.c client/map.h client/map.c client/transfer.h \
  	client/transfer.c client/agent.h client/agent.c \
  	client/transport.h client/transport.c client/driver.h \
! 	client/driver.c src/map_ap.h src/map_ap.c
  am__dirstamp = $(am__leading_dot)dirstamp
  am__objects_1 = gdbus/mainloop.$(OBJEXT) gdbus/watch.$(OBJEXT) \
  	gdbus/object.$(OBJEXT) gdbus/polkit.$(OBJEXT)
--- 117,124 ----
  	client/opp.c client/map.h client/map.c client/transfer.h \
  	client/transfer.c client/agent.h client/agent.c \
  	client/transport.h client/transport.c client/driver.h \
! 	client/driver.c client/mns.h client/mns.c \
! 	src/map_ap.h src/map_ap.c
  am__dirstamp = $(am__leading_dot)dirstamp
  am__objects_1 = gdbus/mainloop.$(OBJEXT) gdbus/watch.$(OBJEXT) \
  	gdbus/object.$(OBJEXT) gdbus/polkit.$(OBJEXT)
***************
*** 133,140 ****
  @CLIENT_TRUE@	client/pbap.$(OBJEXT) client/ftp.$(OBJEXT) \
  @CLIENT_TRUE@	client/opp.$(OBJEXT) client/map.$(OBJEXT) \
  @CLIENT_TRUE@	client/transfer.$(OBJEXT) client/agent.$(OBJEXT) \
! @CLIENT_TRUE@	client/transport.$(OBJEXT) \
! @CLIENT_TRUE@	client/driver.$(OBJEXT) src/map_ap.$(OBJEXT)
  client_obex_client_OBJECTS = $(am_client_obex_client_OBJECTS)
  client_obex_client_DEPENDENCIES =
  AM_V_lt = $(am__v_lt_@AM_V@)
--- 134,141 ----
  @CLIENT_TRUE@	client/pbap.$(OBJEXT) client/ftp.$(OBJEXT) \
  @CLIENT_TRUE@	client/opp.$(OBJEXT) client/map.$(OBJEXT) \
  @CLIENT_TRUE@	client/transfer.$(OBJEXT) client/agent.$(OBJEXT) \
! @CLIENT_TRUE@	client/transport.$(OBJEXT) client/driver.$(OBJEXT) \
! @CLIENT_TRUE@	client/mns.$(OBJEXT) src/map_ap.$(OBJEXT)
  client_obex_client_OBJECTS = $(am_client_obex_client_OBJECTS)
  client_obex_client_DEPENDENCIES =
  AM_V_lt = $(am__v_lt_@AM_V@)
***************
*** 146,154 ****
  	plugins/filesystem.h plugins/pcsuite.c plugins/opp.c \
  	plugins/ftp.c plugins/ftp.h plugins/pbap.c plugins/phonebook.h \
  	plugins/vcard.h plugins/vcard.c plugins/mas.c \
! 	plugins/messages.h src/map_ap.c src/map_ap.h plugins/irmc.c \
! 	plugins/syncevolution.c btio/btio.h btio/btio.c gobex/gobex.h \
! 	gobex/gobex.c gobex/gobex-defs.h gobex/gobex-defs.c \
  	gobex/gobex-packet.c gobex/gobex-packet.h gobex/gobex-header.c \
  	gobex/gobex-header.h gobex/gobex-transfer.c \
  	gobex/gobex-debug.h src/main.c src/obexd.h src/plugin.h \
--- 147,156 ----
  	plugins/filesystem.h plugins/pcsuite.c plugins/opp.c \
  	plugins/ftp.c plugins/ftp.h plugins/pbap.c plugins/phonebook.h \
  	plugins/vcard.h plugins/vcard.c plugins/mas.c \
! 	plugins/messages.h src/map_ap.c src/map_ap.h plugins/bmsg.h \
! 	plugins/bmsg.c plugins/bmsg_parser.h plugins/bmsg_parser.c \
! 	plugins/irmc.c plugins/syncevolution.c btio/btio.h btio/btio.c \
! 	gobex/gobex.h gobex/gobex.c gobex/gobex-defs.h gobex/gobex-defs.c \
  	gobex/gobex-packet.c gobex/gobex-packet.h gobex/gobex-header.c \
  	gobex/gobex-header.h gobex/gobex-transfer.c \
  	gobex/gobex-debug.h src/main.c src/obexd.h src/plugin.h \
***************
*** 164,170 ****
  @SERVER_TRUE@	$(am__objects_5) plugins/opp.$(OBJEXT) \
  @SERVER_TRUE@	plugins/ftp.$(OBJEXT) plugins/pbap.$(OBJEXT) \
  @SERVER_TRUE@	plugins/vcard.$(OBJEXT) plugins/mas.$(OBJEXT) \
! @SERVER_TRUE@	src/map_ap.$(OBJEXT) plugins/irmc.$(OBJEXT) \
  @SERVER_TRUE@	plugins/syncevolution.$(OBJEXT)
  @SERVER_TRUE@am_src_obexd_OBJECTS = $(am__objects_1) $(am__objects_6) \
  @SERVER_TRUE@	$(am__objects_3) $(am__objects_2) \
--- 166,173 ----
  @SERVER_TRUE@	$(am__objects_5) plugins/opp.$(OBJEXT) \
  @SERVER_TRUE@	plugins/ftp.$(OBJEXT) plugins/pbap.$(OBJEXT) \
  @SERVER_TRUE@	plugins/vcard.$(OBJEXT) plugins/mas.$(OBJEXT) \
! @SERVER_TRUE@	src/map_ap.$(OBJEXT) plugins/bmsg.$(OBJEXT) \
! @SERVER_TRUE@	plugins/bmsg_parser.$(OBJEXT) plugins/irmc.$(OBJEXT) \
  @SERVER_TRUE@	plugins/syncevolution.$(OBJEXT)
  @SERVER_TRUE@am_src_obexd_OBJECTS = $(am__objects_1) $(am__objects_6) \
  @SERVER_TRUE@	$(am__objects_3) $(am__objects_2) \
***************
*** 432,438 ****
  test_files = test/simple-agent test/send-files \
  		test/pull-business-card test/exchange-business-cards \
  		test/list-folders test/pbap-client test/ftp-client \
! 		test/map-client
  
  gdbus_sources = gdbus/gdbus.h gdbus/mainloop.c gdbus/watch.c \
  					gdbus/object.c gdbus/polkit.c
--- 435,441 ----
  test_files = test/simple-agent test/send-files \
  		test/pull-business-card test/exchange-business-cards \
  		test/list-folders test/pbap-client test/ftp-client \
! 		test/map-client test/mns-client
  
  gdbus_sources = gdbus/gdbus.h gdbus/mainloop.c gdbus/watch.c \
  					gdbus/object.c gdbus/polkit.c
***************
*** 453,460 ****
  @SERVER_TRUE@	$(am__append_5) plugins/opp.c plugins/ftp.c \
  @SERVER_TRUE@	plugins/ftp.h plugins/pbap.c plugins/phonebook.h \
  @SERVER_TRUE@	plugins/vcard.h plugins/vcard.c plugins/mas.c \
! @SERVER_TRUE@	plugins/messages.h src/map_ap.c src/map_ap.h \
! @SERVER_TRUE@	plugins/irmc.c plugins/syncevolution.c
  @SERVER_TRUE@builtin_nodist = plugins/phonebook.c plugins/messages.c
  @SERVER_TRUE@src_obexd_SOURCES = $(gdbus_sources) $(builtin_sources) $(btio_sources) \
  @SERVER_TRUE@			$(gobex_sources) src/main.c src/obexd.h \
--- 456,465 ----
  @SERVER_TRUE@	$(am__append_5) plugins/opp.c plugins/ftp.c \
  @SERVER_TRUE@	plugins/ftp.h plugins/pbap.c plugins/phonebook.h \
  @SERVER_TRUE@	plugins/vcard.h plugins/vcard.c plugins/mas.c \
! @SERVER_TRUE@	plugins/messages.h plugins/bmsg.c plugins/bmsg.h \
! @SERVER_TRUE@	plugins/bmsg_parser.c plugins/bmsg_parser.h \
! @SERVER_TRUE@	src/map_ap.c src/map_ap.h plugins/irmc.c \
! @SERVER_TRUE@	plugins/syncevolution.c
  @SERVER_TRUE@builtin_nodist = plugins/phonebook.c plugins/messages.c
  @SERVER_TRUE@src_obexd_SOURCES = $(gdbus_sources) $(builtin_sources) $(btio_sources) \
  @SERVER_TRUE@			$(gobex_sources) src/main.c src/obexd.h \
***************
*** 466,475 ****
  @SERVER_TRUE@			src/transport.h src/transport.c \
  @SERVER_TRUE@			src/server.h src/server.c
  
! @SERVER_TRUE@src_obexd_LDADD = @DBUS_LIBS@ @GLIB_LIBS@ @GTHREAD_LIBS@ \
! @SERVER_TRUE@					@EBOOK_LIBS@ @BLUEZ_LIBS@ \
! @SERVER_TRUE@					@RTCOM_EVENTLOGGER_ASYNC_LIBS@ \
! @SERVER_TRUE@					@LIBICAL_LIBS@ @TRACKER_LIBS@ -ldl
  
  @SERVER_TRUE@src_obexd_LDFLAGS = -Wl,--export-dynamic
  @SERVER_TRUE@builtin_files = src/builtin.h $(builtin_nodist)
--- 471,487 ----
  @SERVER_TRUE@			src/transport.h src/transport.c \
  @SERVER_TRUE@			src/server.h src/server.c
  
! @MESSAGES_QT_FALSE@@SERVER_TRUE@src_obexd_LDADD = @DBUS_LIBS@ @GLIB_LIBS@ @GTHREAD_LIBS@ \
! @MESSAGES_QT_FALSE@@SERVER_TRUE@					@EBOOK_LIBS@ @BLUEZ_LIBS@ \
! @MESSAGES_QT_FALSE@@SERVER_TRUE@					@RTCOM_EVENTLOGGER_ASYNC_LIBS@ \
! @MESSAGES_QT_FALSE@@SERVER_TRUE@					@LIBICAL_LIBS@ @TRACKER_LIBS@ -ldl
! 
! @MESSAGES_QT_TRUE@@SERVER_TRUE@src_obexd_LDADD = @DBUS_LIBS@ @GLIB_LIBS@ @GTHREAD_LIBS@ \
! @MESSAGES_QT_TRUE@@SERVER_TRUE@					@EBOOK_LIBS@ @BLUEZ_LIBS@ \
! @MESSAGES_QT_TRUE@@SERVER_TRUE@					@RTCOM_EVENTLOGGER_ASYNC_LIBS@ \
! @MESSAGES_QT_TRUE@@SERVER_TRUE@					@LIBICAL_LIBS@ @TRACKER_LIBS@ -ldl \
! @MESSAGES_QT_TRUE@@SERVER_TRUE@					messages-qt/libmessages-qt.a \
! @MESSAGES_QT_TRUE@@SERVER_TRUE@					@QTCORE_LIBS@ @COMMHISTORY_LIBS@
  
  @SERVER_TRUE@src_obexd_LDFLAGS = -Wl,--export-dynamic
  @SERVER_TRUE@builtin_files = src/builtin.h $(builtin_nodist)
***************
*** 491,496 ****
--- 503,509 ----
  @CLIENT_TRUE@				client/agent.h client/agent.c \
  @CLIENT_TRUE@				client/transport.h client/transport.c \
  @CLIENT_TRUE@				client/driver.h client/driver.c \
+ @CLIENT_TRUE@				client/mns.h client/mns.c \
  @CLIENT_TRUE@				src/map_ap.h src/map_ap.c
  
  @CLIENT_TRUE@client_obex_client_LDADD = @GLIB_LIBS@ @DBUS_LIBS@ @BLUEZ_LIBS@
***************
*** 510,516 ****
  			src/obexd.service.in client/obex-client.service.in \
  			plugins/phonebook-dummy.c plugins/phonebook-ebook.c \
  			plugins/phonebook-tracker.c \
! 			plugins/messages-dummy.c plugins/messages-tracker.c
  
  DISTCHECK_CONFIGURE_FLAGS = --enable-client --enable-server
  MAINTAINERCLEANFILES = Makefile.in \
--- 523,534 ----
  			src/obexd.service.in client/obex-client.service.in \
  			plugins/phonebook-dummy.c plugins/phonebook-ebook.c \
  			plugins/phonebook-tracker.c \
! 			plugins/messages-dummy.c plugins/messages-rtcom.c \
! 			plugins/messages-tracker.c \
! 			messages-qt/messages-qt.pro messages-qt/messages-qt.cpp \
! 			messages-qt/Makefile
! 
! SUBDIRS = messages-qt
  
  DISTCHECK_CONFIGURE_FLAGS = --enable-client --enable-server
  MAINTAINERCLEANFILES = Makefile.in \
***************
*** 755,760 ****
--- 773,780 ----
  	client/$(DEPDIR)/$(am__dirstamp)
  client/driver.$(OBJEXT): client/$(am__dirstamp) \
  	client/$(DEPDIR)/$(am__dirstamp)
+ client/mns.$(OBJEXT): client/$(am__dirstamp) \
+ 	client/$(DEPDIR)/$(am__dirstamp)
  src/map_ap.$(OBJEXT): src/$(am__dirstamp) \
  	src/$(DEPDIR)/$(am__dirstamp)
  client/obex-client$(EXEEXT): $(client_obex_client_OBJECTS) $(client_obex_client_DEPENDENCIES) $(EXTRA_client_obex_client_DEPENDENCIES) client/$(am__dirstamp)
***************
*** 784,789 ****
--- 804,813 ----
  	plugins/$(DEPDIR)/$(am__dirstamp)
  plugins/mas.$(OBJEXT): plugins/$(am__dirstamp) \
  	plugins/$(DEPDIR)/$(am__dirstamp)
+ plugins/bmsg.$(OBJEXT): plugins/$(am__dirstamp) \
+ 	plugins/$(DEPDIR)/$(am__dirstamp)
+ plugins/bmsg_parser.$(OBJEXT): plugins/$(am__dirstamp) \
+ 	plugins/$(DEPDIR)/$(am__dirstamp)
  plugins/irmc.$(OBJEXT): plugins/$(am__dirstamp) \
  	plugins/$(DEPDIR)/$(am__dirstamp)
  plugins/syncevolution.$(OBJEXT): plugins/$(am__dirstamp) \
***************
*** 863,868 ****
--- 887,893 ----
  	-rm -f client/ftp.$(OBJEXT)
  	-rm -f client/main.$(OBJEXT)
  	-rm -f client/manager.$(OBJEXT)
+ 	-rm -f client/mns.$(OBJEXT)
  	-rm -f client/map.$(OBJEXT)
  	-rm -f client/opp.$(OBJEXT)
  	-rm -f client/pbap.$(OBJEXT)
***************
*** 880,885 ****
--- 905,912 ----
  	-rm -f gobex/gobex-transfer.$(OBJEXT)
  	-rm -f gobex/gobex.$(OBJEXT)
  	-rm -f plugins/bluetooth.$(OBJEXT)
+ 	-rm -f plugins/bmsg.$(OBJEXT)
+ 	-rm -f plugins/bmsg_parser.$(OBJEXT)
  	-rm -f plugins/filesystem.$(OBJEXT)
  	-rm -f plugins/ftp.$(OBJEXT)
  	-rm -f plugins/irmc.$(OBJEXT)
***************
*** 920,925 ****
--- 947,953 ----
  @AMDEP_TRUE@@am__include@ @am__quote@client/$(DEPDIR)/ftp.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@client/$(DEPDIR)/main.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@client/$(DEPDIR)/manager.Po@am__quote@
+ @AMDEP_TRUE@@am__include@ @am__quote@client/$(DEPDIR)/mns.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@client/$(DEPDIR)/map.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@client/$(DEPDIR)/opp.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@client/$(DEPDIR)/pbap.Po@am__quote@
***************
*** 937,942 ****
--- 965,972 ----
  @AMDEP_TRUE@@am__include@ @am__quote@gobex/$(DEPDIR)/gobex-transfer.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@gobex/$(DEPDIR)/gobex.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@plugins/$(DEPDIR)/bluetooth.Po@am__quote@
+ @AMDEP_TRUE@@am__include@ @am__quote@plugins/$(DEPDIR)/bmsg.Po@am__quote@
+ @AMDEP_TRUE@@am__include@ @am__quote@plugins/$(DEPDIR)/bmsg_parser.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@plugins/$(DEPDIR)/filesystem.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@plugins/$(DEPDIR)/ftp.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@plugins/$(DEPDIR)/irmc.Po@am__quote@
diff -crN client/manager.c client/manager.c
*** client/manager.c	Tue Oct  2 04:11:18 2012
--- client/manager.c	Tue Oct  2 04:37:04 2012
***************
*** 44,49 ****
--- 44,50 ----
  #include "pbap.h"
  #include "sync.h"
  #include "map.h"
+ #include "mns.h"
  
  #define CLIENT_SERVICE  "org.openobex.client"
  
***************
*** 610,615 ****
--- 611,617 ----
  	{ "pbap", pbap_init, pbap_exit },
  	{ "sync", sync_init, sync_exit },
  	{ "map", map_init, map_exit },
+ 	{ "mns", mns_init, mns_exit },
  	{ }
  };
  
diff -crN client/mns.c client/mns.c
*** client/mns.c	Wed Dec 31 19:00:00 1969
--- client/mns.c	Tue Oct  2 04:37:04 2012
***************
*** 0 ****
--- 1,350 ----
+ /*
+  *
+  *  OBEX Client
+  *
+  *  Copyright (C) 2007-2010  Intel Corporation
+  *  Copyright (C) 2007-2010  Marcel Holtmann <marcel@holtmann.org>
+  *
+  *
+  *  This program is free software; you can redistribute it and/or modify
+  *  it under the terms of the GNU General Public License as published by
+  *  the Free Software Foundation; either version 2 of the License, or
+  *  (at your option) any later version.
+  *
+  *  This program is distributed in the hope that it will be useful,
+  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  *  GNU General Public License for more details.
+  *
+  *  You should have received a copy of the GNU General Public License
+  *  along with this program; if not, write to the Free Software
+  *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+  *
+  */
+ 
+ #ifdef HAVE_CONFIG_H
+ #include <config.h>
+ #endif
+ 
+ #include <errno.h>
+ #include <glib.h>
+ #include <gdbus.h>
+ 
+ #include "log.h"
+ #include "transfer.h"
+ #include "session.h"
+ #include "driver.h"
+ #include "mns.h"
+ 
+ #define OBEX_MNS_UUID \
+ 	"\xbb\x58\x2b\x41\x42\x0c\x11\xdb\xb0\xde\x08\x00\x20\x0c\x9a\x66"
+ #define OBEX_MNS_UUID_LEN 16
+ 
+ #define ERROR_INF MNS_INTERFACE ".Error"
+ #define MASINSTANCEID_TAG	0x0F
+ 
+ #define MET_NEW_MESSAGE		1
+ #define MET_DELIVERY_SUCCESS	2
+ #define MET_SENDING_SUCCESS	3
+ #define MET_DELIVERY_FAILURE	4
+ #define MET_SENDING_FAILURE	5
+ #define MET_MEMORY_FULL		6
+ #define MET_MEMORY_AVAILABLE	7
+ #define MET_MESSAGE_DELETED	8
+ #define MET_MESSAGE_SHIFT	9
+ 
+ #define MT_EMAIL	1
+ #define MT_SMS_GSM	2
+ #define MT_SMS_CDMA	3
+ #define MT_MMS		4
+ 
+ #define MNS_UUID "00001133-0000-1000-8000-00805f9b34fb"
+ 
+ struct event_apparam {
+ 	uint8_t	tag;
+ 	uint8_t	len;
+ 	uint8_t masinstanceid;
+ } __attribute__ ((packed));
+ 
+ static DBusConnection *conn = NULL;
+ 
+ struct mns {
+ 	DBusMessage *msg;
+ 	struct obc_session *session;
+ };
+ 
+ static void mns_send_event_callback(struct obc_session *session,
+ 					struct obc_transfer *transfer,
+ 					GError *err, void *user_data)
+ {
+ 	struct mns *mns = user_data;
+ 	DBusMessage *reply;
+ 
+ 	DBG("");
+ 	/*DBG("%d", gw_obex_xfer_object_done(transfer->xfer));*/
+ 	if (mns->msg == NULL)
+ 		goto done;
+ 
+ 	reply = dbus_message_new_method_return(mns->msg);
+ 
+ 	g_dbus_send_message(conn, reply);
+ 	dbus_message_unref(mns->msg);
+ 	mns->msg = NULL;
+ 
+ done:
+ 	obc_transfer_unregister(transfer);
+ }
+ 
+ 
+ static DBusMessage *mns_send_event(DBusConnection *connection,
+ 					DBusMessage *message, void *user_data)
+ {
+ 	struct mns *mns = user_data;
+ 	struct obc_transfer *transfer;
+ 	DBusMessage *reply;
+ 	GError *err = NULL;
+ 	GString *buf;
+ 	uint8_t evtype;
+ 	uint8_t msgtype;
+ 	uint8_t masinstanceid;
+ 	const char *handle, *folder, *old_folder;
+ 	struct event_apparam eapp;
+ 	char *cbuf;
+ #if 0
+ 	struct session_data *session = user_data;
+ #endif
+ 
+ 	DBG("");
+ 
+ 	if (mns->msg) {
+ 		DBG("Another transfer in progress!");
+ 		return g_dbus_create_error(message,
+ 				"org.openobex.Error.InProgress",
+ 				"Transfer in progress");
+ 	}
+ 
+ 	buf = g_string_new("");
+ 
+ 	if (dbus_message_get_args(message, NULL,
+ 			DBUS_TYPE_BYTE, &masinstanceid,
+ 			DBUS_TYPE_BYTE, &evtype,
+ 			DBUS_TYPE_STRING, &handle,
+ 			DBUS_TYPE_STRING, &folder,
+ 			DBUS_TYPE_STRING, &old_folder,
+ 			DBUS_TYPE_BYTE, &msgtype,
+ 			DBUS_TYPE_INVALID) == FALSE) {
+ 		DBG("Invalid arguments!");
+ 		return g_dbus_create_error(message,
+ 				ERROR_INF ".InvalidArguments", NULL);
+ 	}
+ 
+ 	eapp.tag = MASINSTANCEID_TAG;
+ 	eapp.len = 1;
+ 	eapp.masinstanceid = masinstanceid;
+ 
+ 	g_string_append(buf, "<MAP-event-report version=\"1.0\">\n");
+ 
+ 	switch (evtype) {
+ 	case MET_NEW_MESSAGE:
+ 		g_string_append(buf, "<event type=\"NewMessage\"");
+ 		break;
+ 	case MET_DELIVERY_SUCCESS:
+ 		g_string_append(buf, "<event type=\"DeliverySuccess\"");
+ 		break;
+ 	case MET_SENDING_SUCCESS:
+ 		g_string_append(buf, "<event type=\"SendingSuccess\"");
+ 		break;
+ 	case MET_DELIVERY_FAILURE:
+ 		g_string_append(buf, "<event type=\"DeliveryFailure\"");
+ 		break;
+ 	case MET_SENDING_FAILURE:
+ 		g_string_append(buf, "<event type=\"SendingFailure\"");
+ 		break;
+ 	case MET_MEMORY_FULL:
+ 		g_string_append(buf, "<event type=\"MemoryFull\"");
+ 		break;
+ 	case MET_MEMORY_AVAILABLE:
+ 		g_string_append(buf, "<event type=\"MemoryAvailable\"");
+ 		break;
+ 	case MET_MESSAGE_DELETED:
+ 		g_string_append(buf, "<event type=\"MessageDeleted\"");
+ 		break;
+ 	case MET_MESSAGE_SHIFT:
+ 		g_string_append(buf, "<event type=\"MessageShift\"");
+ 		break;
+ 	default:
+ 		DBG("Incorrect type of event!");
+ 		g_string_free(buf, TRUE);
+ 		return g_dbus_create_error(message,
+ 				ERROR_INF ".InvalidArguments",
+ 				"Incorrect event type");
+ 	}
+ 
+ 	/* FIXME: escape disallowed characters */
+ 	if ((evtype != MET_MEMORY_FULL) && (evtype != MET_MEMORY_AVAILABLE)) {
+ 		g_string_append_printf(buf, " handle=\"%s\"", handle);
+ 		g_string_append_printf(buf, " folder=\"%s\"", folder);
+ 		switch (msgtype) {
+ 		case MT_EMAIL:
+ 			g_string_append(buf, " msg_type=\"EMAIL\"");
+ 			break;
+ 		case MT_SMS_GSM:
+ 			g_string_append(buf, " msg_type=\"SMS_GSM\"");
+ 			break;
+ 		case MT_SMS_CDMA:
+ 			g_string_append(buf, " msg_type=\"SMS_CDMA\"");
+ 			break;
+ 		case MT_MMS:
+ 			g_string_append(buf, " msg_type=\"MMS\"");
+ 			break;
+ 		default:
+ 			/* FIXME */
+ 			break;
+ 		}
+ 	}
+ 
+ 	if (evtype == MET_MESSAGE_SHIFT)
+ 		g_string_append_printf(buf, " old_folder=\"%s\"", old_folder);
+ 
+ 	g_string_append(buf, "/>\n</MAP-event-report>");
+ 
+ 	DBG("Object to be sent:");
+ 	DBG("%s", buf->str);
+ 
+ 	cbuf = buf->str;
+ 
+ 	g_string_free(buf, FALSE);
+ 
+ /*	if (session->msg)
+ 		return g_dbus_create_error(message,
+ 				"org.openobex.Error.InProgress",
+ 				"Transfer in progress");*/
+ 
+ 	/* XXX: currently it also sends obex length header. can we ignore this?
+ 	 * This makes test device respond with code 500.
+ 	 * (also see MAP specification, page 64)
+ 	 * note: temporary "fixed" in obex-priv.c (may definitely break another
+ 	 * things)
+ 	 */
+ 	/* XXX: implementation sends separate Body and EndOfBody headers in
+ 	 * separate packets - ugly (would require fix in openobex) */
+ 	/* XXX: session_put makes a copy of eapp, cbuf will be freed after use
+ 	 */
+ 	transfer = obc_transfer_put("x-bt/MAP-event-report", NULL, NULL, 
+ 				(const guint8 *)&eapp, sizeof(eapp),
+ 				&err);
+ 
+ 	if (transfer == NULL)
+ 		goto fail;
+ 
+ 	if (obc_session_queue(mns->session, transfer, mns_send_event_callback, mns, &err)) {
+ 		mns->msg = dbus_message_ref(message);
+ 
+ 		return NULL;
+ 	}
+ 
+ fail:
+ 	reply = g_dbus_create_error(message,
+ 			ERROR_INF ".Failed", "%s",
+ 			err->message);
+ 
+ 	g_error_free(err);
+ 
+ 	return reply;
+ }
+ 
+ 
+ static GDBusMethodTable mns_methods[] = {
+ 	{ "SendEvent",	"yysssy",	"",	mns_send_event,
+ 						G_DBUS_METHOD_FLAG_ASYNC },
+ 	{ }
+ };
+ 
+ static void mns_free(void *data)
+ {
+ 	struct mns *mns = data;
+ 
+ 	obc_session_unref(mns->session);
+ 	g_free(mns);
+ }
+ /*gboolean mns_register_interface(DBusConnection *connection, const char *path,*/
+ 				/*void *user_data, GDBusDestroyFunction destroy)*/
+ static int mns_probe(struct obc_session *session)
+ {
+ 	const char *path = obc_session_get_path(session);
+ 	struct mns *mns;
+ 
+ 	DBG("%s", path);
+ 	/*struct session_data *session = user_data;
+ 	void *priv;*/
+ 
+ 	mns = g_try_malloc0(sizeof(*mns));
+ 	if (!mns)
+ 		return -ENOMEM;
+ 
+ 	mns->session = obc_session_ref(session);
+ 
+ 	/*session_set_data(session, priv);*/
+ 
+ 	if (!g_dbus_register_interface(conn, path, MNS_INTERFACE,
+ 				mns_methods, NULL, NULL, mns, mns_free)) {
+ 		mns_free(mns);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /*void mns_unregister_interface(DBusConnection *connection, const char *path,
+ 				void *user_data)*/
+ static void mns_remove(struct obc_session *session)
+ {
+ 	const char *path = obc_session_get_path(session);
+ 	/*struct session_data *session = user_data;*/
+ 	/*void *priv = session_get_data(session);*/
+ 
+ 	g_dbus_unregister_interface(conn, path, MNS_INTERFACE);
+ #if 0
+ 	g_free(priv);
+ #endif
+ }
+ 
+ 
+ static struct obc_driver mns = {
+ 	.service = "MNS",
+ 	.uuid = MNS_UUID,
+ 	.target = OBEX_MNS_UUID,
+ 	.target_len = OBEX_MNS_UUID_LEN,
+ 	.probe = mns_probe,
+ 	.remove = mns_remove
+ };
+ 
+ int mns_init(void)
+ {
+ 	int err;
+ 
+ 	DBG("");
+ 
+ 	conn = dbus_bus_get(DBUS_BUS_SESSION, NULL);
+ 	if (!conn)
+ 		return -EIO;
+ 
+ 	err = obc_driver_register(&mns);
+ 	if (err < 0) {
+ 		dbus_connection_unref(conn);
+ 		conn = NULL;
+ 		return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ void mns_exit(void)
+ {
+ 	DBG("");
+ 
+ 	dbus_connection_unref(conn);
+ 	conn = NULL;
+ 
+ 	obc_driver_unregister(&mns);
+ }
diff -crN client/mns.h client/mns.h
*** client/mns.h	Wed Dec 31 19:00:00 1969
--- client/mns.h	Tue Oct  2 04:37:04 2012
***************
*** 0 ****
--- 1,35 ----
+ /*
+  *
+  *  OBEX Client
+  *
+  *  Copyright (C) 2007-2010  Intel Corporation
+  *  Copyright (C) 2007-2010  Marcel Holtmann <marcel@holtmann.org>
+  *
+  *
+  *  This program is free software; you can redistribute it and/or modify
+  *  it under the terms of the GNU General Public License as published by
+  *  the Free Software Foundation; either version 2 of the License, or
+  *  (at your option) any later version.
+  *
+  *  This program is distributed in the hope that it will be useful,
+  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  *  GNU General Public License for more details.
+  *
+  *  You should have received a copy of the GNU General Public License
+  *  along with this program; if not, write to the Free Software
+  *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+  *
+  */
+ 
+ #include <gdbus.h>
+ 
+ #define MNS_INTERFACE  "org.openobex.MNS"
+ 
+ gboolean mns_register_interface(DBusConnection *connection, const char *path,
+ 				void *user_data, GDBusDestroyFunction destroy);
+ void mns_unregister_interface(DBusConnection *connection, const char *path,
+ 				void *user_data);
+ 
+ int mns_init(void);
+ void mns_exit(void);
diff -crN configure configure
*** configure	Tue Oct  2 04:24:19 2012
--- configure	Tue Oct  2 05:04:47 2012
***************
*** 656,661 ****
--- 656,667 ----
  EBOOK_CFLAGS
  LIBICAL_LIBS
  LIBICAL_CFLAGS
+ QTCORE_CFLAGS
+ QTCORE_LIBS
+ COMMHISTORY_CFLAGS
+ COMMHISTORY_LIBS
+ MESSAGES_QT_TRUE
+ MESSAGES_QT_FALSE
  MESSAGES_DRIVER
  BLUEZ_LIBS
  BLUEZ_CFLAGS
***************
*** 825,830 ****
--- 831,840 ----
  DBUS_LIBS
  BLUEZ_CFLAGS
  BLUEZ_LIBS
+ QTCORE_CFLAGS
+ QTCORE_LIBS
+ COMMHISTORY_CFLAGS
+ COMMHISTORY_LIBS
  LIBICAL_CFLAGS
  LIBICAL_LIBS
  EBOOK_CFLAGS
***************
*** 1508,1513 ****
--- 1518,1530 ----
    BLUEZ_CFLAGS
                C compiler flags for BLUEZ, overriding pkg-config
    BLUEZ_LIBS  linker flags for BLUEZ, overriding pkg-config
+   QTCORE_CFLAGS
+               C compiler flags for QTCORE, overriding pkg-config
+   QTCORE_LIBS linker flags for QTCORE, overriding pkg-config
+   COMMHISTORY_CFLAGS
+               C compiler flags for COMMHISTORY, overriding pkg-config
+   COMMHISTORY_LIBS
+               linker flags for COMMHISTORY, overriding pkg-config
    LIBICAL_CFLAGS
                C compiler flags for LIBICAL, overriding pkg-config
    LIBICAL_LIBS
***************
*** 12549,12564 ****
  
  
  messages_driver=dummy
  
  # Check whether --with-messages was given.
! if test "${with_messages+set}" = set; then :
    withval=$with_messages;
  	if (test "${withval}" = "no"); then
  		messages_driver=dummy;
  	else
  		messages_driver=${withval};
  	fi
  
  fi
  
  
--- 12566,12828 ----
  
  
  messages_driver=dummy
+ enable_messages_qt=no
  
  # Check whether --with-messages was given.
! if test "${with_messages+set}" = set; then
    withval=$with_messages;
  	if (test "${withval}" = "no"); then
  		messages_driver=dummy;
  	else
  		messages_driver=${withval};
  	fi
+ 	if (test "${withval}" = "rtcom"); then
  
+ pkg_failed=no
+ { echo "$as_me:$LINENO: checking for RTCOM_EVENTLOGGER_ASYNC" >&5
+ echo $ECHO_N "checking for RTCOM_EVENTLOGGER_ASYNC... $ECHO_C" >&6; }
+ 
+ if test -n "$PKG_CONFIG"; then
+     if test -n "$RTCOM_EVENTLOGGER_ASYNC_CFLAGS"; then
+         pkg_cv_RTCOM_EVENTLOGGER_ASYNC_CFLAGS="$RTCOM_EVENTLOGGER_ASYNC_CFLAGS"
+     else
+         if test -n "$PKG_CONFIG" && \
+     { (echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"rtcom-eventlogger-async\"") >&5
+   ($PKG_CONFIG --exists --print-errors "rtcom-eventlogger-async") 2>&5
+   ac_status=$?
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   (exit $ac_status); }; then
+   pkg_cv_RTCOM_EVENTLOGGER_ASYNC_CFLAGS=`$PKG_CONFIG --cflags "rtcom-eventlogger-async" 2>/dev/null`
+ else
+   pkg_failed=yes
+ fi
+     fi
+ else
+ 	pkg_failed=untried
+ fi
+ if test -n "$PKG_CONFIG"; then
+     if test -n "$RTCOM_EVENTLOGGER_ASYNC_LIBS"; then
+         pkg_cv_QTCORE_LIBS="$RTCOM_EVENTLOGGER_ASYNC_LIBS"
+     else
+         if test -n "$PKG_CONFIG" && \
+     { (echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"rtcom-eventlogger-async\"") >&5
+   ($PKG_CONFIG --exists --print-errors "rtcom-eventlogger-async") 2>&5
+   ac_status=$?
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   (exit $ac_status); }; then
+   pkg_cv_RTCOM_EVENTLOGGER_ASYNC_LIBS=`$PKG_CONFIG --libs "rtcom-eventlogger-async" 2>/dev/null`
+ else
+   pkg_failed=yes
+ fi
+     fi
+ else
+ 	pkg_failed=untried
+ fi
+ 
+ 
+ 
+ if test $pkg_failed = yes; then
+ 
+ if $PKG_CONFIG --atleast-pkgconfig-version 0.20; then
+         _pkg_short_errors_supported=yes
+ else
+         _pkg_short_errors_supported=no
+ fi
+         if test $_pkg_short_errors_supported = yes; then
+                 RTCOM_EVENTLOGGER_ASYNC_PKG_ERRORS=`$PKG_CONFIG --short-errors --errors-to-stdout --print-errors "rtcom-eventlogger-async"`
+         else
+                 RTCOM_EVENTLOGGER_ASYNC_PKG_ERRORS=`$PKG_CONFIG --errors-to-stdout --print-errors "rtcom-eventlogger-async"`
+         fi
+         # Put the nasty error message in config.log where it belongs
+         echo "$RTCOM_EVENTLOGGER_ASYNC_PKG_ERRORS" >&5
+ 
+         { echo "$as_me:$LINENO: result: no" >&5
+ echo "${ECHO_T}no" >&6; }
+                 { { echo "$as_me:$LINENO: error: rtcom-eventlogger-async is required to build messages-rtcom" >&5
+ echo "$as_me: error: rtcom-eventlogger-async is required to build messages-rtcom" >&2;}
+    { (exit 1); exit 1; }; }
+ elif test $pkg_failed = untried; then
+         { { echo "$as_me:$LINENO: error: rtcom-eventlogger-async is required to build messages-rtcom" >&5
+ echo "$as_me: error: rtcom-eventlogger-async is required to build messages-rtcom" >&2;}
+    { (exit 1); exit 1; }; }
+ else
+         RTCOM_EVENTLOGGER_ASYNC_CFLAGS=$pkg_cv_RTCOM_EVENTLOGGER_ASYNC_CFLAGS
+         RTCOM_EVENTLOGGER_ASYNC_LIBS=$pkg_cv_RTCOM_EVENTLOGGER_ASYNC_LIBS
+         { echo "$as_me:$LINENO: result: yes" >&5
+ echo "${ECHO_T}yes" >&6; }
+         dummy=yes
+ fi
+ 
+ fi
+ 
+ 
+ 
+ 	if (test "${withval}" = "tracker"); then
+ 
+ pkg_failed=no
+ { echo "$as_me:$LINENO: checking for QTCORE" >&5
+ echo $ECHO_N "checking for QTCORE... $ECHO_C" >&6; }
+ 
+ if test -n "$PKG_CONFIG"; then
+     if test -n "$QTCORE_CFLAGS"; then
+         pkg_cv_QTCORE_CFLAGS="$QTCORE_CFLAGS"
+     else
+         if test -n "$PKG_CONFIG" && \
+     { (echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"QtCore\"") >&5
+   ($PKG_CONFIG --exists --print-errors "QtCore") 2>&5
+   ac_status=$?
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   (exit $ac_status); }; then
+   pkg_cv_QTCORE_CFLAGS=`$PKG_CONFIG --cflags "QtCore" 2>/dev/null`
+ else
+   pkg_failed=yes
+ fi
+     fi
+ else
+ 	pkg_failed=untried
+ fi
+ if test -n "$PKG_CONFIG"; then
+     if test -n "$QTCORE_LIBS"; then
+         pkg_cv_QTCORE_LIBS="$QTCORE_LIBS"
+     else
+         if test -n "$PKG_CONFIG" && \
+     { (echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"QtCore\"") >&5
+   ($PKG_CONFIG --exists --print-errors "QtCore") 2>&5
+   ac_status=$?
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   (exit $ac_status); }; then
+   pkg_cv_QTCORE_LIBS=`$PKG_CONFIG --libs "QtCore" 2>/dev/null`
+ else
+   pkg_failed=yes
+ fi
+     fi
+ else
+ 	pkg_failed=untried
+ fi
+ 
+ 
+ 
+ if test $pkg_failed = yes; then
+ 
+ if $PKG_CONFIG --atleast-pkgconfig-version 0.20; then
+         _pkg_short_errors_supported=yes
+ else
+         _pkg_short_errors_supported=no
+ fi
+         if test $_pkg_short_errors_supported = yes; then
+                 QTCORE_PKG_ERRORS=`$PKG_CONFIG --short-errors --errors-to-stdout --print-errors "QtCore"`
+         else
+                 QTCORE_PKG_ERRORS=`$PKG_CONFIG --errors-to-stdout --print-errors "QtCore"`
+         fi
+         # Put the nasty error message in config.log where it belongs
+         echo "$QTCORE_PKG_ERRORS" >&5
+ 
+         { echo "$as_me:$LINENO: result: no" >&5
+ echo "${ECHO_T}no" >&6; }
+                 { { echo "$as_me:$LINENO: error: QtCore is required to build messages-tracker" >&5
+ echo "$as_me: error: QtCore is required to build messages-tracker" >&2;}
+    { (exit 1); exit 1; }; }
+ elif test $pkg_failed = untried; then
+         { { echo "$as_me:$LINENO: error: QtCore is required to build messages-tracker" >&5
+ echo "$as_me: error: QtCore is required to build messages-tracker" >&2;}
+    { (exit 1); exit 1; }; }
+ else
+         QTCORE_CFLAGS=$pkg_cv_QTCORE_CFLAGS
+         QTCORE_LIBS=$pkg_cv_QTCORE_LIBS
+         { echo "$as_me:$LINENO: result: yes" >&5
+ echo "${ECHO_T}yes" >&6; }
+         dummy=yes
+ fi
+ 
+ pkg_failed=no
+ { echo "$as_me:$LINENO: checking for COMMHISTORY" >&5
+ echo $ECHO_N "checking for COMMHISTORY... $ECHO_C" >&6; }
+ 
+ if test -n "$PKG_CONFIG"; then
+     if test -n "$COMMHISTORY_CFLAGS"; then
+         pkg_cv_COMMHISTORY_CFLAGS="$COMMHISTORY_CFLAGS"
+     else
+         if test -n "$PKG_CONFIG" && \
+     { (echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"commhistory\"") >&5
+   ($PKG_CONFIG --exists --print-errors "commhistory") 2>&5
+   ac_status=$?
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   (exit $ac_status); }; then
+   pkg_cv_COMMHISTORY_CFLAGS=`$PKG_CONFIG --cflags "commhistory" 2>/dev/null`
+ else
+   pkg_failed=yes
+ fi
+     fi
+ else
+ 	pkg_failed=untried
+ fi
+ if test -n "$PKG_CONFIG"; then
+     if test -n "$COMMHISTORY_LIBS"; then
+         pkg_cv_COMMHISTORY_LIBS="$COMMHISTORY_LIBS"
+     else
+         if test -n "$PKG_CONFIG" && \
+     { (echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"commhistory\"") >&5
+   ($PKG_CONFIG --exists --print-errors "commhistory") 2>&5
+   ac_status=$?
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   (exit $ac_status); }; then
+   pkg_cv_COMMHISTORY_LIBS=`$PKG_CONFIG --libs "commhistory" 2>/dev/null`
+ else
+   pkg_failed=yes
+ fi
+     fi
+ else
+ 	pkg_failed=untried
+ fi
+ 
+ 
+ 
+ if test $pkg_failed = yes; then
+ 
+ if $PKG_CONFIG --atleast-pkgconfig-version 0.20; then
+         _pkg_short_errors_supported=yes
+ else
+         _pkg_short_errors_supported=no
+ fi
+ 	if test $_pkg_short_errors_supported = yes; then
+ 	        COMMHISTORY_PKG_ERRORS=`$PKG_CONFIG --short-errors --errors-to-stdout --print-errors "commhistory"`
+ 	else
+ 	        COMMHISTORY_PKG_ERRORS=`$PKG_CONFIG --errors-to-stdout --print-errors "commhistory"`
+ 	fi
+ 	# Put the nasty error message in config.log where it belongs
+ 	echo "$COMMHISTORY_PKG_ERRORS" >&5
+ 
+ 	{ echo "$as_me:$LINENO: result: no" >&5
+ echo "${ECHO_T}no" >&6; }
+                 { { echo "$as_me:$LINENO: error: libcommhistory is required to build messages-tracker" >&5
+ echo "$as_me: error: libcommhistory is required to build messages-tracker" >&2;}
+    { (exit 1); exit 1; }; }
+ elif test $pkg_failed = untried; then
+         { { echo "$as_me:$LINENO: error: libcommhistory is required to build messages-tracker" >&5
+ echo "$as_me: error: libcommhistory is required to build messages-tracker" >&2;}
+    { (exit 1); exit 1; }; }
+ else
+ 	COMMHISTORY_CFLAGS=$pkg_cv_COMMHISTORY_CFLAGS
+ 	COMMHISTORY_LIBS=$pkg_cv_COMMHISTORY_LIBS
+         { echo "$as_me:$LINENO: result: yes" >&5
+ echo "${ECHO_T}yes" >&6; }
+ 	dummy=yes
+ fi
+ 		enable_messages_qt="yes";
+ 		( cd messages-qt; qmake )
+ 	fi
+ 
+ fi
+ 
+ 
+ 
+ 
+ if test "${enable_messages_qt}" = "yes"; then
+   MESSAGES_QT_TRUE=
+   MESSAGES_QT_FALSE='#'
+ else
+   MESSAGES_QT_TRUE='#'
+   MESSAGES_QT_FALSE=
  fi
  
  
diff -crN configure.ac configure.ac
*** configure.ac	Tue Oct  2 04:24:19 2012
--- configure.ac	Tue Oct  2 05:04:47 2012
***************
*** 113,126 ****
--- 113,140 ----
  ])
  
  messages_driver=dummy
+ enable_messages_qt=no
  AC_ARG_WITH(messages, AC_HELP_STRING([--with-messages=DRIVER], [select messages driver]), [
  	if (test "${withval}" = "no"); then
  		messages_driver=dummy;
  	else
  		messages_driver=${withval};
  	fi
+ 	if (test "${withval}" = "rtcom"); then
+ 		PKG_CHECK_MODULES(RTCOM_EVENTLOGGER_ASYNC, rtcom-eventlogger-async, dummy=yes, AC_MSG_ERROR(rtcom-eventlogger-async is required to build messages-rtcom)))
+ 	fi
+ 	if (test "${withval}" = "tracker"); then
+ 		PKG_CHECK_MODULES(QTCORE, QtCore, dummy=yes,
+ 			AC_MSG_ERROR([QtCore is required to build messages-tracker]))
+ 		PKG_CHECK_MODULES(COMMHISTORY, commhistory, dummy=yes,
+ 			AC_MSG_ERROR([libcommhistory is required to build messages-tracker]))
+ 		enable_messages_qt="yes";
+ 		( cd messages-qt; qmake )
+ 	fi
  ])
  
+ AM_CONDITIONAL(MESSAGES_QT, test "${enable_messages_qt}" = "yes")
+ 
  AC_SUBST([MESSAGES_DRIVER], [messages-${messages_driver}.c])
  
  phonebook_driver=dummy
diff -crN messages-qt/messagepusher.cpp messages-qt/messagepusher.cpp
*** messages-qt/messagepusher.cpp	Wed Dec 31 19:00:00 1969
--- messages-qt/messagepusher.cpp	Tue Oct  2 04:37:04 2012
***************
*** 0 ****
--- 1,200 ----
+ #include <CommHistory/Group>
+ #include <CommHistory/Event>
+ 
+ #include "messages-qt-log.h"
+ #include "messagepusher.h"
+ 
+ extern "C" {
+ #include <errno.h>
+ }
+ 
+ #define TELEPATHY_ACCOUNT_PREFIX       QLatin1String("/org/freedesktop/Telepathy/Account/")
+ #define TELEPATHY_RING_ACCOUNT_POSTFIX QLatin1String("ring/tel/ring")
+ 
+ #define RING_ACCOUNT TELEPATHY_ACCOUNT_PREFIX + TELEPATHY_RING_ACCOUNT_POSTFIX
+ 
+ 
+ MessagePusher::MessagePusher() :
+ 		callback(NULL),
+ 		aborted(false)
+ {
+ 	QObject::connect(&groupModel,
+ 			SIGNAL(modelReady(bool)),
+ 			this,
+ 			SLOT(modelReady(bool)));
+ 	QObject::connect(&groupModel,
+ 			SIGNAL(groupsCommitted(const QList<int> &, bool)),
+ 			this,
+ 			SLOT(groupsCommitted(const QList<int> &, bool)));
+ 	QObject::connect(&eventModel,
+ 			SIGNAL(eventsCommitted(
+ 					const QList<CommHistory::Event> &,
+ 					bool)),
+ 			this,
+ 			SLOT(eventsCommitted(
+ 					const QList<CommHistory::Event> &,
+ 					bool)));
+ }
+ 
+ void MessagePusher::abort()
+ {
+ 	DBG("%p", this);
+ 
+ 	callback = NULL;
+ 	aborted = true;
+ }
+ 
+ void MessagePusher::reportError(int err)
+ {
+ 	if (callback)
+ 		callback(err, user_data);
+ 
+ 	this->deleteLater();
+ }
+ 
+ void MessagePusher::eventsCommitted(const QList<CommHistory::Event> &,
+ 								bool success)
+ {
+ 	DBG("%p", this);
+ 
+ 	if (!success) {
+ 		DBG("Unsuccessful event commit!");
+ 		reportError(-EIO);
+ 
+ 		return;
+ 	}
+ 
+ 	if (callback)
+ 		callback(eventId, user_data);
+ 
+ 	this->deleteLater();
+ }
+ 
+ void MessagePusher::groupsCommitted(const QList<int> &, bool success)
+ {
+ 	DBG("%p", this);
+ 
+ 	if (aborted)
+ 		DBG("Abort has been requested, but at this point "
+ 							"I'd rather proceed.");
+ 
+ 	if (!success) {
+ 		DBG("Unsuccessful group commit!");
+ 		reportError(-EIO);
+ 
+ 		return;
+ 	}
+ 
+ 	CommHistory::Event event;
+ 
+ 	event.setType(CommHistory::Event::SMSEvent);
+ 	event.setDirection(direction);
+ 	event.setGroupId(groupId);
+ 	event.setLocalUid(RING_ACCOUNT);
+ 	event.setRemoteUid(remoteUid);
+ 	event.setIsRead(false);			/* TODO */
+ 	event.setStartTime(QDateTime::currentDateTime());
+ 	event.setEndTime(QDateTime::currentDateTime());
+ 	event.setFreeText(messageBody);
+ 	event.setStatus(CommHistory::Event::DeliveredStatus);
+ 
+ 	if (!eventModel.addEvent(event)) {
+ 		DBG("EventModel::addEvent failed!");
+ 		reportError(-EIO);
+ 	}
+ 
+ 	eventId = event.id();
+ }
+ 
+ void MessagePusher::modelReady(bool success)
+ {
+ 	DBG("%p", this);
+ 
+ 	if (aborted) {
+ 		DBG("Pushing has been aborted.");
+ 		this->deleteLater();
+ 
+ 		return;
+ 	}
+ 
+ 	if (!success) {
+ 		DBG("Groups retrieval failed!");
+ 		reportError(-EIO);
+ 
+ 		return;
+ 	}
+ 
+ 	if (groupModel.rowCount() > 0) {
+ 		CommHistory::Group group(groupModel.group(
+ 						groupModel.index(0, 0)));
+ 
+ 		groupId = group.id();
+ 
+ 		DBG("Using existing group, id: %d", groupId);
+ 
+ 		QList<int> ids;
+ 		ids << groupId;
+ 		groupsCommitted(ids, true);
+ 
+ 		return;
+ 	}
+ 
+ 
+ 	CommHistory::Group group;
+ 
+ 	group.setLocalUid(RING_ACCOUNT);
+ 	group.setRemoteUids(QStringList(remoteUid));
+ 
+ 	if (!groupModel.addGroup(group)) {
+ 		DBG("GroupModel::addGroup() failed!");
+ 		reportError(-EIO);
+ 	}
+ 
+ 	groupId = group.id();
+ 	DBG("Added new group, id: %d", groupId);
+ }
+ 
+ int MessagePusher::push(MessagePusher **p, const char *remote,
+ 					const char *body,
+ 					const char *folder,
+ 					MessagePusherCallback callback,
+ 					void *user_data)
+ {
+ 	DBG("remote = \"%s\", body = \"%s\", folder = \"%s\"",
+ 							remote, body, folder);
+ 
+ 	CommHistory::Event::EventDirection direction;
+ 	QString destFolder(folder);
+ 
+ 	if (destFolder == QString("/telecom/msg/inbox"))
+ 		direction = CommHistory::Event::Inbound;
+ 	else if (destFolder == QString("/telecom/msg/sent"))
+ 		direction = CommHistory::Event::Outbound;
+ 	else {
+ 		DBG("Tried to push to unsupported folder: %s", folder);
+ 		return -ENOENT;
+ 	}
+ 
+ 	MessagePusher *messagePusher = new MessagePusher();
+ 	DBG("this = %p", messagePusher);
+ 
+ 	messagePusher->callback = callback;
+ 	messagePusher->user_data = user_data;
+ 
+ 	messagePusher->remoteUid = QString(remote);
+ 	messagePusher->messageBody = QString::fromUtf8(body);
+ 	messagePusher->direction = direction;
+ 
+ 	if (!messagePusher->groupModel.getGroups(RING_ACCOUNT, QString(remote)))
+ 	{
+ 		DBG("GroupModel::getGroups() failed!");
+ 		delete messagePusher;
+ 
+ 		return -EIO;
+ 	}
+ 
+ 	if (p)
+ 		*p = messagePusher;
+ 
+ 	return 0;
+ }
diff -crN messages-qt/messagepusher.h messages-qt/messagepusher.h
*** messages-qt/messagepusher.h	Wed Dec 31 19:00:00 1969
--- messages-qt/messagepusher.h	Tue Oct  2 04:37:04 2012
***************
*** 0 ****
--- 1,41 ----
+ #include <QObject>
+ #include <CommHistory/Event>
+ #include <CommHistory/GroupModel>
+ #include <CommHistory/EventModel>
+ 
+ typedef void (*MessagePusherCallback)(int ret, void *user_data);
+ 
+ class MessagePusher : public QObject {
+ 	Q_OBJECT
+ 
+ public:
+ 	static int push(MessagePusher **p, const char *remote,
+ 					const char *body,
+ 					const char *folder,
+ 					MessagePusherCallback callback = NULL,
+ 					void *user_data = NULL);
+ 	void abort();
+ 
+ private:
+ 	MessagePusherCallback callback;
+ 	void *user_data;
+ 
+ 	CommHistory::GroupModel groupModel;
+ 	CommHistory::EventModel eventModel;
+ 
+ 	int groupId;
+ 	int eventId;
+ 
+ 	QString remoteUid;
+ 	QString messageBody;
+ 	CommHistory::Event::EventDirection direction;
+ 	bool aborted;
+ 
+ 	MessagePusher();
+ 	void reportError(int err);
+ 
+ private slots:
+ 	void eventsCommitted(const QList<CommHistory::Event> &ids, bool success);
+ 	void groupsCommitted(const QList<int> &ids, bool success);
+ 	void modelReady(bool success);
+ };
diff -crN messages-qt/messages-qt-log.h messages-qt/messages-qt-log.h
*** messages-qt/messages-qt-log.h	Wed Dec 31 19:00:00 1969
--- messages-qt/messages-qt-log.h	Tue Oct  2 04:37:04 2012
***************
*** 0 ****
--- 1,11 ----
+ extern "C" {
+ #include "log.h"
+ }
+ 
+ /* Original DBG uses C99-style struct initializer which is not compatible
+  * with g++ */
+ 
+ #ifdef DBG
+ #undef DBG
+ #endif
+ #define DBG(fmt, arg...) obex_debug("%s:%s() " fmt,  __FILE__, __FUNCTION__ , ## arg)
diff -crN messages-qt/messages-qt.cpp messages-qt/messages-qt.cpp
*** messages-qt/messages-qt.cpp	Wed Dec 31 19:00:00 1969
--- messages-qt/messages-qt.cpp	Tue Oct  2 04:37:04 2012
***************
*** 0 ****
--- 1,112 ----
+ #include <QCoreApplication>
+ #include <CommHistory/SingleEventModel>
+ #include <CommHistory/GroupModel>
+ #include <CommHistory/Event>
+ 
+ #include "messages-qt-log.h"
+ #include "messagepusher.h"
+ #include "messageupdater.h"
+ 
+ #include "messages-qt.h"
+ 
+ extern "C" {
+ 
+ #ifdef HAVE_CONFIG_H
+ #include <config.h>
+ #endif
+ 
+ #include <errno.h>
+ 
+ #include "messages.h"
+ #include "glib.h"
+ 
+ }
+ 
+ static QCoreApplication *app = NULL;
+ 
+ int messages_qt_init(void)
+ {
+ 	static char *argv[] = {(char *)""};
+ 	static int argc = 1;
+ 
+ 	/* QCoreApplication is required when using libcommhistory */
+ 	if (app == NULL)
+ 		app = new QCoreApplication(argc, argv);
+ 
+ 	return 0;
+ }
+ 
+ void messages_qt_exit(void)
+ {
+ 	if (app != NULL) {
+ 		delete app;
+ 		app = NULL;
+ 	}
+ }
+ 
+ void messages_qt_set_abort(void *p)
+ {
+ 	MessageUpdater *messageUpdater = (MessageUpdater *)p;
+ 	messageUpdater->abort();
+ }
+ 
+ int messages_qt_set_deleted(void **p, const char *handle, gboolean deleted,
+ 			messages_qt_callback_t callback, void *user_data)
+ {
+ 	MessageUpdater *messageUpdater;
+ 	int ret;
+ 
+ 	ret = MessageUpdater::setDeleted(&messageUpdater, handle, deleted,
+ 							callback, user_data);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	if (p)
+ 		*p = messageUpdater;
+ 
+ 	return 0;
+ }
+ 
+ 
+ int messages_qt_set_read(void **p, const char *handle, gboolean read,
+ 			messages_qt_callback_t callback, void *user_data)
+ {
+ 	MessageUpdater *messageUpdater;
+ 	int ret;
+ 
+ 	ret = MessageUpdater::setIsRead(&messageUpdater, handle, read,
+ 							callback, user_data);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	if (p)
+ 		*p = messageUpdater;
+ 
+ 	return 0;
+ }
+ 
+ void messages_qt_insert_message_abort(void *p)
+ {
+ 	MessagePusher *messagePusher = (MessagePusher *)p;
+ 	messagePusher->abort();
+ }
+ 
+ int messages_qt_insert_message(void **p, const char *remote, const char *body,
+ 						const char *folder,
+ 						messages_qt_callback_t callback,
+ 						void *user_data)
+ {
+ 	MessagePusher *messagePusher;
+ 	int ret;
+ 
+ 	ret = MessagePusher::push(&messagePusher, remote, body, folder,
+ 							callback, user_data);
+ 
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	if (p)
+ 		*p = messagePusher;
+ 
+ 	return 0;
+ }
diff -crN messages-qt/messages-qt.h messages-qt/messages-qt.h
*** messages-qt/messages-qt.h	Wed Dec 31 19:00:00 1969
--- messages-qt/messages-qt.h	Tue Oct  2 04:37:04 2012
***************
*** 0 ****
--- 1,24 ----
+ #ifdef __cplusplus
+ extern "C" {
+ #endif
+ 
+ #include <glib.h>
+ 
+ typedef void (*messages_qt_callback_t)(int id, void *user_data);
+ 
+ int messages_qt_init(void);
+ void messages_qt_exit(void);
+ void messages_qt_set_abort(void *p);
+ int messages_qt_set_deleted(void **p, const char *handle, gboolean deleted,
+ 			messages_qt_callback_t callback, void *user_data);
+ int messages_qt_set_read(void **p, const char *handle, gboolean read,
+ 			messages_qt_callback_t callback, void *user_data);
+ void messages_qt_insert_message_abort(void *p);
+ int messages_qt_insert_message(void **p, const char *remote, const char *body,
+ 						const char *folder,
+ 						messages_qt_callback_t callback,
+ 						void *user_data);
+ 
+ #ifdef __cplusplus
+ }
+ #endif
diff -crN messages-qt/messages-qt.pro messages-qt/messages-qt.pro
*** messages-qt/messages-qt.pro	Wed Dec 31 19:00:00 1969
--- messages-qt/messages-qt.pro	Tue Oct  2 04:37:04 2012
***************
*** 0 ****
--- 1,19 ----
+ TEMPLATE = lib
+ CONFIG += staticlib link_pkgconfig
+ 
+ TARGET = messages-qt
+ DEPENDPATH += . ../plugins ../src
+ INCLUDEPATH += . ../plugins ../src
+ PKGCONFIG += glib-2.0
+ PKGCONFIG += commhistory
+ 
+ # Input
+ SOURCES += messages-qt.cpp messagepusher.cpp messageupdater.cpp
+ HEADERS += messages-qt.h messagepusher.h messageupdater.h
+ HEADERS += messages-qt-log.h
+ 
+ mc.target = maintainer-clean
+ mc.commands = 
+ mc.depends = 
+ 
+ QMAKE_EXTRA_TARGETS += mc
diff -crN messages-qt/messageupdater.cpp messages-qt/messageupdater.cpp
*** messages-qt/messageupdater.cpp	Wed Dec 31 19:00:00 1969
--- messages-qt/messageupdater.cpp	Tue Oct  2 04:37:04 2012
***************
*** 0 ****
--- 1,179 ----
+ #include "messages-qt-log.h"
+ #include "messageupdater.h"
+ 
+ extern "C" {
+ #include <errno.h>
+ }
+ 
+ MessageUpdater::MessageUpdater() :
+ 		callback(NULL),
+ 		aborted(false)
+ {
+ 	QObject::connect(&singleEventModel,
+ 			SIGNAL(modelReady(bool)),
+ 			this,
+ 			SLOT(modelReady(bool)));
+ 	QObject::connect(&singleEventModel,
+ 			SIGNAL(eventsCommitted(
+ 					const QList<CommHistory::Event> &,
+ 					bool)),
+ 			this,
+ 			SLOT(eventsCommitted(
+ 					const QList<CommHistory::Event> &,
+ 					bool)));
+ }
+ 
+ void MessageUpdater::abort()
+ {
+ 	callback = NULL;
+ 	aborted = true;
+ }
+ 
+ void MessageUpdater::reportError(int err)
+ {
+ 	if (callback)
+ 		callback(err, user_data);
+ 
+ 	this->deleteLater();
+ }
+ 
+ void MessageUpdater::eventsCommitted(const QList<CommHistory::Event> &,
+ 								bool success)
+ {
+ 	DBG("%p", this);
+ 
+ 	if (!success) {
+ 		DBG("Unsuccessful event commit!");
+ 		reportError(-EIO);
+ 
+ 		return;
+ 	}
+ 
+ 	if (callback)
+ 		callback(0, user_data);
+ 
+ 	this->deleteLater();
+ }
+ 
+ void MessageUpdater::modelReady(bool success)
+ {
+ 	DBG("%p", this);
+ 
+ 	if (aborted) {
+ 		DBG("Updating has been aborted.");
+ 		this->deleteLater();
+ 
+ 		return;
+ 	}
+ 
+ 	if (!success) {
+ 		DBG("Event retrieval failed!");
+ 		reportError(-EIO);
+ 
+ 		return;
+ 	}
+ 
+ 	if (singleEventModel.rowCount() == 0) {
+ 		DBG("Event not found!");
+ 		reportError(-ENOENT);
+ 
+ 		return;
+ 	}
+ 
+ 	(this->*(action))();
+ }
+ 
+ void MessageUpdater::doSetIsRead()
+ {
+ 	CommHistory::Event event =
+ 		singleEventModel.event(singleEventModel.index(0, 0));
+ 
+ 	event.setIsRead(value);
+ 
+ 	if (!singleEventModel.modifyEvent(event)) {
+ 		DBG("SingleEventModel::modifyEvent() failed!");
+ 		reportError(-EIO);
+ 	}
+ }
+ 
+ void MessageUpdater::doSetDeleted()
+ {
+ 	CommHistory::Event event =
+ 		singleEventModel.event(singleEventModel.index(0, 0));
+ 
+ 	event.setDeleted(value);
+ 
+ 	if (!singleEventModel.modifyEvent(event)) {
+ 		DBG("SingleEventModel::modifyEvent() failed!");
+ 		reportError(-EIO);
+ 	}
+ }
+ 
+ int MessageUpdater::getEvent(const char *handle)
+ {
+ 	QString uri = QString("message:");
+ 
+ 	uri += QString::number(QString(handle).toLong());
+ 
+ 	if (!singleEventModel.getEventByUri(QUrl(uri))) {
+ 		DBG("SingleEventModel::getEventsByUri() failed!");
+ 
+ 		return -EIO;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ int MessageUpdater::setIsRead(MessageUpdater **p, const char *handle,
+ 				bool isRead, MessageUpdaterCallback callback,
+ 				void *user_data)
+ {
+ 	MessageUpdater *messageUpdater = new MessageUpdater();
+ 	DBG("this = %p, handle = %s, isRead = %d", messageUpdater, handle,
+ 									isRead);
+ 
+ 	messageUpdater->value = isRead;
+ 	messageUpdater->callback = callback;
+ 	messageUpdater->user_data = user_data;
+ 	messageUpdater->action = &MessageUpdater::doSetIsRead;
+ 
+ 	int ret = messageUpdater->getEvent(handle);
+ 	if (ret < 0) {
+ 		DBG("MessageUpdater::getEvent() failed!");
+ 		delete messageUpdater;
+ 
+ 		return ret;
+ 	}
+ 
+ 	if (p)
+ 		*p = messageUpdater;
+ 
+ 	return 0;
+ }
+ 
+ int MessageUpdater::setDeleted(MessageUpdater **p, const char *handle,
+ 				bool deleted, MessageUpdaterCallback callback,
+ 				void *user_data)
+ {
+ 	MessageUpdater *messageUpdater = new MessageUpdater();
+ 	DBG("this = %p, handle = %s, deleted = %d", messageUpdater,
+ 							handle, deleted);
+ 
+ 	messageUpdater->value = deleted;
+ 	messageUpdater->callback = callback;
+ 	messageUpdater->user_data = user_data;
+ 	messageUpdater->action = &MessageUpdater::doSetDeleted;
+ 
+ 	int ret = messageUpdater->getEvent(handle);
+ 	if (ret < 0) {
+ 		DBG("MessageUpdater::getEvent() failed!");
+ 		delete messageUpdater;
+ 
+ 		return ret;
+ 	}
+ 
+ 	if (p)
+ 		*p = messageUpdater;
+ 
+ 	return 0;
+ }
diff -crN messages-qt/messageupdater.h messages-qt/messageupdater.h
*** messages-qt/messageupdater.h	Wed Dec 31 19:00:00 1969
--- messages-qt/messageupdater.h	Tue Oct  2 04:37:04 2012
***************
*** 0 ****
--- 1,39 ----
+ #include <QObject>
+ #include <CommHistory/SingleEventModel>
+ 
+ typedef void (*MessageUpdaterCallback)(int err, void *user_data);
+ 
+ class MessageUpdater : public QObject {
+ 	Q_OBJECT
+ 
+ public:
+ 	static int setIsRead(MessageUpdater **p, const char *handle,
+ 					bool isRead,
+ 					MessageUpdaterCallback callback = NULL,
+ 					void *user_data = NULL);
+ 	static int setDeleted(MessageUpdater **p, const char *handle,
+ 					bool deleted,
+ 					MessageUpdaterCallback callback = NULL,
+ 					void *user_data = NULL);
+ 	void abort();
+ private:
+ 	MessageUpdaterCallback callback;
+ 	void *user_data;
+ 
+ 	CommHistory::SingleEventModel singleEventModel;
+ 
+ 	void (MessageUpdater::*action)();
+ 	bool value;
+ 	bool aborted;
+ 
+ 	MessageUpdater();
+ 	void reportError(int err);
+ 	int getEvent(const char *handle);
+ 	void doSetIsRead();
+ 	void doSetDeleted();
+ 
+ private slots:
+ 	void eventsCommitted(const QList<CommHistory::Event> &ids,
+ 								bool success);
+ 	void modelReady(bool success);
+ };
diff -crN messages-qt/test/messages-qt-test.pro messages-qt/test/messages-qt-test.pro
*** messages-qt/test/messages-qt-test.pro	Wed Dec 31 19:00:00 1969
--- messages-qt/test/messages-qt-test.pro	Tue Oct  2 04:37:04 2012
***************
*** 0 ****
--- 1,20 ----
+ TEMPLATE = app
+ CONFIG += console debug
+ CONFIG += link_pkgconfig
+ 
+ TARGET = messages-qt-test
+ DEPENDPATH += . .. ../../plugins ../../src
+ INCLUDEPATH += . .. ../../plugins ../../src
+ PKGCONFIG += glib-2.0
+ PKGCONFIG += commhistory
+ 
+ # Input
+ SOURCES += ../messages-qt.cpp ../messagepusher.cpp ../messageupdater.cpp test.cpp
+ HEADERS += ../messages-qt.h ../messagepusher.h ../messageupdater.h
+ HEADERS += ../messages-qt-log.h
+ 
+ mc.target = maintainer-clean
+ mc.commands = 
+ mc.depends = 
+ 
+ QMAKE_EXTRA_TARGETS += mc
diff -crN messages-qt/test/test.cpp messages-qt/test/test.cpp
*** messages-qt/test/test.cpp	Wed Dec 31 19:00:00 1969
--- messages-qt/test/test.cpp	Tue Oct  2 04:37:04 2012
***************
*** 0 ****
--- 1,114 ----
+ #define _BSD_SOURCE
+ 
+ #include <QCoreApplication>
+ #include <QDebug>
+ #include <stdarg.h>
+ #include <string.h>
+ #include "messages-qt.h"
+ 
+ extern "C" {
+ #include <glib.h>
+ 
+ void obex_debug(char *format, ...)
+ {
+ 	va_list ap;
+ 	QString str;
+ 
+ 	va_start(ap, format);
+ 
+ 	str.vsprintf(format, ap);
+ 	qDebug() << str;
+ 
+ 	va_end(ap);
+ }
+ 
+ }
+ 
+ void usage(char *argv0)
+ {
+ 	qDebug() << "Usage: ";
+ 	qDebug() << "\t" << argv0 << "pushmessage REMOTE BODY FOLDER";
+ 	qDebug() << "\t" << argv0 << "setisread HANDLE 0|1";
+ 	qDebug() << "\t" << argv0 << "setdeleted HANDLE 0|1";
+ 
+ 	exit(EXIT_FAILURE);
+ }
+ 
+ void callback(int ret, void *)
+ {
+ 	if (ret < 0) {
+ 		qDebug() << strerror(-ret);
+ 		return;
+ 	}
+ 
+ 	qDebug() << "Id:" << ret;
+ 
+ 	QCoreApplication::exit();
+ }
+ 
+ GMainLoop *loop;
+ 
+ gboolean timeout_dot(void *)
+ {
+ 	putchar('.');
+ 	fflush(stdout);
+ 
+ 	return TRUE;
+ }
+ 
+ gboolean timeout_process(void *)
+ {
+ 	puts("Starting");
+ 	fflush(stdout);
+ 	for (int i = 0; i < 20000; ++i) {
+ 		QCoreApplication::processEvents(QEventLoop::WaitForMoreEvents | QEventLoop::AllEvents);
+ 	}
+ 	puts("Quitting");
+ 	fflush(stdout);
+ 	g_main_loop_quit(loop);
+ 
+ 	return FALSE;
+ }
+ 
+ int main(int argc, char **argv)
+ {
+ 	if (argc < 2)
+ 		usage(argv[0]);
+ 
+ 	if (messages_qt_init() < 0) {
+ 		qDebug() << "messages_qt_init() failed!";
+ 		return EXIT_FAILURE;
+ 	}
+ 
+ 	QString command(argv[1]);
+ 	int ret;
+ 
+ 	if (command == QString("pushmessage")) {
+ 		if (argc != 5)
+ 			usage(argv[0]);
+ 		ret = messages_qt_insert_message(argv[2], argv[3], argv[4],
+ 								callback, NULL);
+ 		qDebug() << strerror(-ret);
+ 		if (ret == 0)
+ 			QCoreApplication::exec();
+ 	} else if (command == QString("setisread")) {
+ 		if (argc != 4)
+ 			usage(argv[0]);
+ 		ret = messages_qt_set_read(argv[2], argv[3][0] == '1');
+ 		qDebug() << strerror(-ret);
+ 	} else if (command == QString("setdeleted")) {
+ 		if (argc != 4)
+ 			usage(argv[0]);
+ 		ret = messages_qt_set_deleted(argv[2], argv[3][0] == '1');
+ 		qDebug() << strerror(-ret);
+ 	} else if (command == QString("looptest")) {
+ 		loop = g_main_loop_new(NULL, FALSE);
+ 		g_timeout_add_seconds(5, timeout_process, NULL);
+ 		g_timeout_add_seconds(1, timeout_dot, NULL);
+ 		g_main_loop_run(loop);
+ 	} else {
+ 		usage(argv[0]);
+ 	}
+ 
+ 	messages_qt_exit();
+ }
diff -crN plugins/bmsg.c plugins/bmsg.c
*** plugins/bmsg.c	Wed Dec 31 19:00:00 1969
--- plugins/bmsg.c	Tue Oct  2 04:37:04 2012
***************
*** 0 ****
--- 1,272 ----
+ /*
+  *  bMessage (MAP) format helpers
+  *
+  *  Copyright (C) 2010, 2011  Bartosz Szatkowski <bulislaw@linux.com>
+  *
+  *
+  *  This program is free software; you can redistribute it and/or modify
+  *  it under the terms of the GNU General Public License as published by
+  *  the Free Software Foundation; either version 2 of the License, or
+  *  (at your option) any later version.
+  *
+  *  This program is distributed in the hope that it will be useful,
+  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  *  GNU General Public License for more details.
+  *
+  *  You should have received a copy of the GNU General Public License
+  *  along with this program; if not, write to the Free Software
+  *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+  *
+  */
+ 
+ #include "bmsg.h"
+ 
+ static void string_append_glist(void *list_item, void *list)
+ {
+ 	GString *buf = list;
+ 
+ 	g_string_append(buf, list_item);
+ }
+ 
+ static void envelope_destroy(struct bmsg_envelope *env)
+ {
+ 	if (env->recipients) {
+ 		g_list_foreach(env->recipients, (GFunc) g_free, NULL);
+ 		g_list_free(env->recipients);
+ 	}
+ 
+ 	if (env->content == NULL)
+ 		return;
+ 
+ 	g_free(env->content->encoding);
+ 	g_free(env->content->charset);
+ 	g_free(env->content->lang);
+ 	g_free(env->content->content);
+ 	g_free(env->content);
+ }
+ 
+ void bmsg_init(struct bmsg *msg, const char *version, const char *status,
+ 		const char *type, const char *folder)
+ {
+ 	msg->version = g_strdup(version);
+ 	msg->status = g_strdup(status);
+ 	msg->type = g_strdup(type);
+ 	msg->folder = g_strdup(folder);
+ 	msg->envelopes = g_array_sized_new(FALSE, TRUE,
+ 					sizeof(struct bmsg_envelope *),
+ 					MAX_ENVELOPES_NUM);
+ }
+ 
+ void bmsg_destroy(struct bmsg *msg)
+ {
+ 	unsigned i;
+ 
+ 	g_free(msg->version);
+ 	g_free(msg->status);
+ 	g_free(msg->type);
+ 	g_free(msg->folder);
+ 
+ 	if (msg->originators) {
+ 		g_list_foreach(msg->originators, (GFunc) g_free, NULL);
+ 		g_list_free(msg->originators);
+ 	}
+ 
+ 	if (msg->envelopes == NULL)
+ 		return;
+ 
+ 	for (i = 0; i < msg->envelopes->len; i++) {
+ 		struct bmsg_envelope *tmp = g_array_index(msg->envelopes,
+ 						struct bmsg_envelope *, i);
+ 
+ 		envelope_destroy(tmp);
+ 		g_free(tmp);
+ 	}
+ 
+ 	g_array_free(msg->envelopes, TRUE);
+ 
+ 	g_free(msg);
+ }
+ 
+ void bmsg_add_originator(struct bmsg *msg, struct phonebook_contact *contact)
+ {
+ 	GString *vcard = g_string_new("");
+ 
+ 	phonebook_add_contact(vcard, contact, 0, FORMAT_VCARD21);
+ 	msg->originators = g_list_append(msg->originators,
+ 						g_string_free(vcard, FALSE));
+ }
+ 
+ gboolean bmsg_add_envelope(struct bmsg *msg)
+ {
+ 	struct bmsg_envelope *tmp;
+ 
+ 	if (msg->envelopes->len == MAX_ENVELOPES_NUM)
+ 		return FALSE;
+ 
+ 	if (msg->envelopes->len && g_array_index(msg->envelopes,
+ 				struct bmsg_envelope *,
+ 				msg->envelopes->len - 1)->content != NULL)
+ 		 return FALSE;
+ 
+ 	tmp = g_new0(struct bmsg_envelope, 1);
+ 
+ 	g_array_append_val(msg->envelopes, tmp);
+ 
+ 	return TRUE;
+ }
+ 
+ void bmsg_add_recipient(struct bmsg *msg, struct phonebook_contact *contact)
+ {
+ 	struct bmsg_envelope *top_env;
+ 	GString *vcard;
+ 
+ 	if (msg->envelopes->len == 0)
+ 		return;
+ 
+ 	top_env = g_array_index(msg->envelopes, struct bmsg_envelope *,
+ 						msg->envelopes->len - 1);
+ 
+ 	vcard = g_string_new("");
+ 	phonebook_add_contact(vcard, contact, 0, FORMAT_VCARD21);
+ 
+ 	top_env->recipients = g_list_append(top_env->recipients,
+ 						g_string_free(vcard, FALSE));
+ }
+ 
+ gboolean bmsg_add_content(struct bmsg *msg, gint32 part_id, char *encoding,
+ 			char *charset, char *lang, const char *content)
+ {
+ 	struct bmsg_envelope *tmp;
+ 	struct bmsg_content *cont;
+ 
+ 	if (content == NULL)
+ 		return FALSE;
+ 
+ 	if (msg->envelopes->len == 0)
+ 		return FALSE;
+ 
+ 	tmp = g_array_index(msg->envelopes, struct bmsg_envelope *,
+ 						msg->envelopes->len - 1);
+ 
+ 	if (tmp->content != NULL)
+ 		return FALSE;
+ 
+ 	cont = g_new0(struct bmsg_content, 1);
+ 	cont->part_id = part_id;
+ 
+ 	if (encoding)
+ 		cont->encoding = g_strdup(encoding);
+ 
+ 	if (charset)
+ 		cont->charset = g_strdup(charset);
+ 
+ 	if (lang)
+ 		cont->lang = g_strdup(lang);
+ 
+ 	cont->content = g_strdup(content);
+ 
+ 	tmp->content = cont;
+ 
+ 	return TRUE;
+ }
+ 
+ static GString *parse_content(struct bmsg_content *cont)
+ {
+ 	GString *buf = g_string_new("");
+ 
+ 	g_string_append_printf(buf, "BEGIN:BBODY\r\n");
+ 
+ 	if (cont->part_id != -1)
+ 		g_string_append_printf(buf, "PARTID:%d\r\n", cont->part_id);
+ 
+ 	if (cont->encoding != NULL)
+ 		g_string_append_printf(buf, "ENCODING:%s\r\n", cont->encoding);
+ 
+ 	if (cont->charset != NULL)
+ 		g_string_append_printf(buf, "CHARSET:%s\r\n", cont->charset);
+ 
+ 	if (cont->lang != NULL)
+ 		g_string_append_printf(buf, "LANGUAGE:%s\r\n", cont->lang);
+ 
+ 	if (cont->len > 0)
+ 		g_string_append_printf(buf, "LENGTH:%d\r\n", cont->len);
+ 	else
+ 		g_string_append_printf(buf, "LENGTH:%d\r\n",
+ 							strlen(cont->content) +
+ 							BMESSAGE_BASE_LEN);
+ 
+ 	g_string_append_printf(buf, "BEGIN:MSG\r\n%s\r\nEND:MSG\r\n",
+ 								cont->content);
+ 	g_string_append_printf(buf, "END:BBODY\r\n");
+ 
+ 	return buf;
+ }
+ 
+ static GString *parse_envelope(struct bmsg *msg, unsigned num)
+ {
+ 	GString *buf;
+ 	struct bmsg_envelope *env;
+ 	GString *tmp;
+ 
+ 	if (num >= msg->envelopes->len)
+ 		return NULL;
+ 
+ 	buf = g_string_new("");
+ 
+ 	env = g_array_index(msg->envelopes, struct bmsg_envelope *, num);
+ 
+ 	g_string_append_printf(buf, "BEGIN:BENV\r\n");
+ 	g_list_foreach(env->recipients, string_append_glist, buf);
+ 
+ 	tmp = parse_envelope(msg, num + 1);
+ 	if (tmp == NULL) {
+ 		if (env->content == NULL) {
+ 			g_string_free(buf, TRUE);
+ 
+ 			return NULL;
+ 		}
+ 
+ 		tmp = parse_content(env->content);
+ 	}
+ 
+ 	g_string_append_printf(buf, "%s", tmp->str);
+ 	g_string_free(tmp, TRUE);
+ 
+ 	g_string_append_printf(buf, "END:BENV\r\n");
+ 
+ 	return buf;
+ }
+ 
+ char *bmsg_text(struct bmsg *msg)
+ {
+ 	GString *buf = g_string_new("");
+ 	GString *env;
+ 	char *ret;
+ 
+ 	g_string_append_printf(buf, "BEGIN:BMSG\r\n");
+ 
+ 	g_string_append_printf(buf, "VERSION:%s\r\n", msg->version);
+ 	g_string_append_printf(buf, "STATUS:%s\r\n", msg->status);
+ 	g_string_append_printf(buf, "TYPE:%s\r\n", msg->type);
+ 	g_string_append_printf(buf, "FOLDER:%s\r\n", msg->folder);
+ 
+ 	g_list_foreach(msg->originators, string_append_glist, buf);
+ 
+ 	env = parse_envelope(msg, 0);
+ 	if (env == NULL) {
+ 		g_string_free(buf, TRUE);
+ 
+ 		return NULL;
+ 	}
+ 
+ 	g_string_append_printf(buf, "%s", env->str);
+ 	g_string_free(env, TRUE);
+ 
+ 	g_string_append_printf(buf, "END:BMSG\r\n");
+ 
+ 	ret = g_strdup(buf->str);
+ 	g_string_free(buf, TRUE);
+ 
+ 	return ret;
+ }
diff -crN plugins/bmsg.h plugins/bmsg.h
*** plugins/bmsg.h	Wed Dec 31 19:00:00 1969
--- plugins/bmsg.h	Tue Oct  2 04:37:04 2012
***************
*** 0 ****
--- 1,88 ----
+ /*
+  *  bMessage (MAP) format helpers
+  *
+  *  Copyright (C) 2010, 2011  Bartosz Szatkowski <bulislaw@linux.com>
+  *
+  *
+  *  This program is free software; you can redistribute it and/or modify
+  *  it under the terms of the GNU General Public License as published by
+  *  the Free Software Foundation; either version 2 of the License, or
+  *  (at your option) any later version.
+  *
+  *  This program is distributed in the hope that it will be useful,
+  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  *  GNU General Public License for more details.
+  *
+  *  You should have received a copy of the GNU General Public License
+  *  along with this program; if not, write to the Free Software
+  *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+  *
+  */
+ 
+ #include <stdio.h>
+ #include <glib.h>
+ #include <string.h>
+ #include <stdint.h>
+ 
+ #include "vcard.h"
+ 
+ #define MAX_ENVELOPES_NUM 3
+ 
+ #define BMSG_VERSION_1_0 "1.0"
+ 
+ #define BMSG_READ "READ"
+ #define BMSG_UNREAD "UNREAD"
+ 
+ #define BMSG_EMAIL "EMAIL"
+ #define BMSG_SMS "SMS_GSM"
+ #define BMSG_CDMA "SMS_CDMA"
+ #define BMSG_MMS "MMS"
+ 
+ /*
+  * As stated in MAP errata bmessage-body-content-length-property should be
+  * length of: "BEGIN:MSG<CRLF>" + <message content> + "END:MSG<CRLF>"
+  */
+ #define BMESSAGE_BASE_LEN (9 + 2 + 2 + 7 + 2)
+ 
+ struct bmsg_vcard {
+ 	char *version;
+ 	char *n;
+ 	char *fn;
+ 	char *tel;
+ 	char *email;
+ };
+ 
+ struct bmsg_content {
+ 	gint32 part_id;
+ 	unsigned int len;
+ 	char *encoding;
+ 	char *charset;
+ 	char *lang;
+ 	char *content;
+ };
+ 
+ struct bmsg_envelope {
+ 	GList *recipients;
+ 	struct bmsg_content *content;
+ };
+ 
+ struct bmsg {
+ 	char *version;
+ 	char *status;
+ 	char *type;
+ 	char *folder;
+ 	GList *originators;
+ 	GArray *envelopes;
+ };
+ 
+ void bmsg_init(struct bmsg *msg, const char *version, const char *status,
+ 					const char *type, const char *folder);
+ void bmsg_destroy(struct bmsg *msg);
+ void bmsg_add_originator(struct bmsg *msg, struct phonebook_contact *contact);
+ void bmsg_add_recipient(struct bmsg *msg, struct phonebook_contact *contact);
+ gboolean bmsg_add_envelope(struct bmsg *msg);
+ gboolean bmsg_add_content(struct bmsg *msg, gint32 part_id, char *encoding,
+ 			char *charset, char *lang, const char* content);
+ struct bmsg * bmsg_parse(char *string);
+ char * bmsg_text(struct bmsg *msg);
diff -crN plugins/bmsg_parser.c plugins/bmsg_parser.c
*** plugins/bmsg_parser.c	Wed Dec 31 19:00:00 1969
--- plugins/bmsg_parser.c	Tue Oct  2 04:37:04 2012
***************
*** 0 ****
--- 1,702 ----
+ #ifdef HAVE_CONFIG_H
+ #include <config.h>
+ #endif
+ 
+ #include <glib.h>
+ #include <string.h>
+ #include <ctype.h>
+ #include <stdlib.h>
+ 
+ #include "log.h"
+ 
+ #include "bmsg_parser.h"
+ #include "glib-helper.h"
+ 
+ static struct {
+ 	enum bmsg_encoding encoding;
+ 	char *s;
+ } bmsg_encodings[] = {
+ 	{ BMSG_E_8BIT, "8BIT" },
+ 	{ BMSG_E_G_7BIT, "G-7BIT" },
+ 	{ BMSG_E_G_7BITEXT, "G-7BITEXT" },
+ 	{ BMSG_E_G_UCS2, "G-UCS2" },
+ 	{ BMSG_E_G_8BIT, "G-8BIT" },
+ 	{ BMSG_E_C_8BIT, "C-8BIT" },
+ 	{ BMSG_E_C_EPM, "C-EPM" },
+ 	{ BMSG_E_C_7ASCII, "C-7ASCII" },
+ 	{ BMSG_E_C_IA5, "C-IA5" },
+ 	{ BMSG_E_C_UNICODE, "C-UNICODE" },
+ 	{ BMSG_E_C_SJIS, "C-SJIS" },
+ 	{ BMSG_E_C_KOREAN, "C-KOREAN" },
+ 	{ BMSG_E_C_LATINHEB, "C-LATINHEB" },
+ 	{ BMSG_E_C_LATIN, "C-LATIN" }
+ };
+ 
+ static struct {
+ 	enum bmsg_language language;
+ 	char *s;
+ } bmsg_languages[] = {
+ 	{ BMSG_L_TURKISH, "TURKISH" },
+ 	{ BMSG_L_SPANISH, "SPANISH" },
+ 	{ BMSG_L_PORTUGUESE, "PORTUGUESE" },
+ 	{ BMSG_L_UNKNOWN, "UNKNOWN" },
+ 	{ BMSG_L_ENGLISH, "ENGLISH" },
+ 	{ BMSG_L_FRENCH, "FRENCH" },
+ 	{ BMSG_L_JAPANESE, "JAPANESE" },
+ 	{ BMSG_L_KOREAN, "KOREAN" },
+ 	{ BMSG_L_CHINESE, "CHINESE" },
+ 	{ BMSG_L_HEBREW, "HEBREW" }
+ };
+ 
+ static int bmsg_parser_begin_bmsg(struct bmsg_parser *);
+ static int bmsg_parser_version(struct bmsg_parser *);
+ static int bmsg_parser_status(struct bmsg_parser *);
+ static int bmsg_parser_type(struct bmsg_parser *);
+ static int bmsg_parser_folder(struct bmsg_parser *);
+ static int bmsg_parser_originator(struct bmsg_parser *);
+ static int bmsg_parser_vcard(struct bmsg_parser *);
+ static int bmsg_parser_begin_envelope(struct bmsg_parser *);
+ static int bmsg_parser_recipient(struct bmsg_parser *);
+ static int bmsg_parser_begin_body(struct bmsg_parser *);
+ static int bmsg_parser_part_id(struct bmsg_parser *);
+ static int bmsg_parser_encoding(struct bmsg_parser *);
+ static int bmsg_parser_charset(struct bmsg_parser *);
+ static int bmsg_parser_language(struct bmsg_parser *);
+ static int bmsg_parser_length(struct bmsg_parser *);
+ 
+ enum bmsg_parser_state {
+ 	BMSG_STATE_BEGIN_BMSG,
+ 	BMSG_STATE_VERSION,
+ 	BMSG_STATE_STATUS,
+ 	BMSG_STATE_TYPE,
+ 	BMSG_STATE_FOLDER,
+ 	BMSG_STATE_ORIGINATOR,
+ 	BMSG_STATE_VCARD,
+ 	BMSG_STATE_BEGIN_ENVELOPE,
+ 	BMSG_STATE_RECIPIENT,
+ 	BMSG_STATE_BEGIN_BODY,
+ 	BMSG_STATE_PART_ID,
+ 	BMSG_STATE_ENCODING,
+ 	BMSG_STATE_CHARSET,
+ 	BMSG_STATE_LANGUAGE,
+ 	BMSG_STATE_LENGTH,
+ 	BMSG_STATE_BEGIN_MSG,
+ 	BMSG_STATE_NSTATES
+ };
+ 
+ int (*actions[BMSG_STATE_NSTATES])(struct bmsg_parser *) = {
+ 	 bmsg_parser_begin_bmsg,
+ 	 bmsg_parser_version,
+ 	 bmsg_parser_status,
+ 	 bmsg_parser_type,
+ 	 bmsg_parser_folder,
+ 	 bmsg_parser_originator,
+ 	 bmsg_parser_vcard,
+ 	 bmsg_parser_begin_envelope,
+ 	 bmsg_parser_recipient,
+ 	 bmsg_parser_begin_body,
+ 	 bmsg_parser_part_id,
+ 	 bmsg_parser_encoding,
+ 	 bmsg_parser_charset,
+ 	 bmsg_parser_language,
+ 	 bmsg_parser_length,
+ 	 NULL
+ };
+ 
+ struct bmsg_parser {
+ 	struct bmsg_bmsg *bmsg;
+ 	enum bmsg_parser_state state;
+ 	enum bmsg_parser_state unwind_state;
+ 	gboolean finished;
+ 	char *input;
+ 	char *eol;
+ 	ssize_t nleft;
+ 	struct bmsg_bmsg_vcard *vcard;
+ 	GRegex *vcard_re;
+ };
+ 
+ static int match_full_line(struct bmsg_parser *pd, const char *pattern)
+ {
+ 	size_t len;
+ 
+ 	len = pd->eol - pd->input;
+ 
+ 	if (strncmp(pattern, pd->input, len) != 0)
+ 		return -1;
+ 
+ 	len += 2;
+ 	pd->input += len;
+ 	pd->nleft -= len;
+ 
+ 	return 0;
+ }
+ 
+ static gboolean match_vcard_item(struct bmsg_parser *pd, const char **name,
+ 				size_t *nlen, const char **value, size_t *vlen)
+ {
+ 	GMatchInfo *minfo = NULL;
+ 	size_t len;
+ 	gint spos, epos;
+ 
+ 	len = pd->eol - pd->input;
+ 	if (!g_regex_match_full(pd->vcard_re, pd->input, len, 0, 0, &minfo,
+ 									NULL))
+ 		return FALSE;
+ 
+ 	g_match_info_fetch_pos(minfo, 1, &spos, &epos);
+ 	*name = pd->input + spos;
+ 	*nlen = epos - spos;
+ 
+ 	g_match_info_fetch_pos(minfo, 3, &spos, &epos);
+ 	*value = pd->input + spos;
+ 	*vlen = epos - spos;
+ 
+ 	g_match_info_free(minfo);
+ 
+ 	len += 2;
+ 	pd->input += len;
+ 	pd->nleft -= len;
+ 
+ 	return TRUE;
+ }
+ 
+ static ssize_t match_with_param(struct bmsg_parser *pd, const char *pattern,
+ 								char **param)
+ {
+ 	size_t len;
+ 	size_t plen;
+ 	size_t vlen;
+ 
+ 	len = pd->eol - pd->input;
+ 	plen = strlen(pattern);
+ 
+ 	if (plen > len || strncmp(pattern, pd->input, plen) != 0)
+ 		return -1;
+ 
+ 	vlen = len - plen;
+ 	*param = pd->input + plen;
+ 
+ 	len += 2;
+ 	pd->input += len;
+ 	pd->nleft -= len;
+ 
+ 	return vlen;
+ }
+ 
+ static int bmsg_parser_begin_bmsg(struct bmsg_parser *pd)
+ {
+ 	if (match_full_line(pd, "BEGIN:BMSG"))
+ 		return -1;
+ 
+ 	pd->state = BMSG_STATE_VERSION;
+ 
+ 	return 0;
+ }
+ 
+ static int bmsg_parser_version(struct bmsg_parser *pd)
+ {
+ 	char *ver;
+ 	ssize_t len;
+ 
+ 	len = match_with_param(pd, "VERSION:", &ver);
+ 	if (len < 0 || strncmp(ver, "1.0", len) != 0)
+ 		return -1;
+ 
+ 	pd->state = BMSG_STATE_STATUS;
+ 
+ 	return 0;
+ }
+ 
+ static int bmsg_parser_status(struct bmsg_parser *pd)
+ {
+ 	char *status;
+ 	ssize_t len;
+ 
+ 	pd->state = BMSG_STATE_TYPE;
+ 
+ 	len = match_with_param(pd, "STATUS:", &status);
+ 	if (len < 0)
+ 		return -1;
+ 
+ 	if (strncmp(status, "READ", len) == 0)
+ 		pd->bmsg->read = TRUE;
+ 	else if (strncmp(status, "UNREAD", len) == 0)
+ 		pd->bmsg->read = FALSE;
+ 	else
+ 		return -1;
+ 
+ 	pd->state = BMSG_STATE_TYPE;
+ 
+ 	return 0;
+ }
+ 
+ static int bmsg_parser_type(struct bmsg_parser *pd)
+ {
+ 	char *type;
+ 	ssize_t len;
+ 
+ 	len = match_with_param(pd, "TYPE:", &type);
+ 	if (len < 0)
+ 		return -1;
+ 
+ 	if (strncmp(type, "SMS_GSM", len) == 0)
+ 		pd->bmsg->type = BMSG_T_SMS_GSM;
+ 	else if (strncmp(type, "SMS_CDMA", len) == 0)
+ 		pd->bmsg->type = BMSG_T_SMS_CDMA;
+ 	else if (strncmp(type, "EMAIL", len) == 0)
+ 		pd->bmsg->type = BMSG_T_EMAIL;
+ 	else if (strncmp(type, "MMS", len) == 0)
+ 		pd->bmsg->type = BMSG_T_MMS;
+ 	else
+ 		return -1;
+ 
+ 	pd->state = BMSG_STATE_FOLDER;
+ 
+ 	return 0;
+ }
+ 
+ static int bmsg_parser_folder(struct bmsg_parser *pd)
+ {
+ 	char *folder;
+ 	ssize_t len;
+ 
+ 	len = match_with_param(pd, "FOLDER:", &folder);
+ 	if (len < 0)
+ 		return -1;
+ 
+ 	pd->bmsg->folder = g_strndup(folder, len);
+ 	pd->state = BMSG_STATE_ORIGINATOR;
+ 
+ 	return 0;
+ }
+ 
+ static int bmsg_parser_originator(struct bmsg_parser *pd)
+ {
+ 	if (match_full_line(pd, "BEGIN:VCARD") == 0) {
+ 		pd->vcard = g_new0(struct bmsg_bmsg_vcard, 1);
+ 		pd->bmsg->originators = g_slist_append(pd->bmsg->originators,
+ 								pd->vcard);
+ 		pd->state = BMSG_STATE_VCARD;
+ 		pd->unwind_state = BMSG_STATE_ORIGINATOR;
+ 	} else {
+ 		pd->state = BMSG_STATE_BEGIN_ENVELOPE;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /* TODO:
+  * support for encoded values
+  * better support for vCard 3.0 (e.g. quoting)
+  * unfolding
+  */
+ static int bmsg_parser_vcard(struct bmsg_parser *pd)
+ {
+ 	ssize_t len;
+ 	const char *name, *val;
+ 	size_t nlen, vlen;
+ 
+ 	if (match_full_line(pd, "END:VCARD") == 0) {
+ 		pd->state = pd->unwind_state;
+ 		return 0;
+ 	}
+ 
+ 	if (!match_vcard_item(pd, &name, &nlen, &val, &vlen)) {
+ 		len = pd->eol - pd->input + 2;
+ 		pd->input += len;
+ 		pd->nleft -= len;
+ 
+ 		return 0;
+ 	}
+ 
+ 	if (g_ascii_strncasecmp(name, "VERSION", nlen) == 0) {
+ 		if (g_ascii_strncasecmp(val, "2.1", vlen) == 0)
+ 			pd->vcard->version = BMSG_VCARD_21;
+ 		else if (g_ascii_strncasecmp(val, "3.0", vlen) == 0)
+ 			pd->vcard->version = BMSG_VCARD_30;
+ 		else {
+ 			DBG("Incorrect vCard version!");
+ 			return -1;
+ 		}
+ 	} else if (g_ascii_strncasecmp(name, "FN", nlen) == 0) {
+ 		if (pd->vcard->fn == NULL)
+ 			pd->vcard->fn = g_strndup(val, vlen);
+ 	} else if (g_ascii_strncasecmp(name, "N", nlen) == 0) {
+ 		if (pd->vcard->n == NULL)
+ 			pd->vcard->n = g_strndup(val, vlen);
+ 	} else if (g_ascii_strncasecmp(name, "TEL", nlen) == 0) {
+ 		if (pd->vcard->tel == NULL)
+ 			pd->vcard->tel = g_strndup(val, vlen);
+ 	} else if (g_ascii_strncasecmp(name, "EMAIL", nlen) == 0) {
+ 		if (pd->vcard->email == NULL)
+ 			pd->vcard->email = g_strndup(val, vlen);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int bmsg_parser_begin_envelope(struct bmsg_parser *pd)
+ {
+ 	if (match_full_line(pd, "BEGIN:BENV") != 0) {
+ 		if (pd->bmsg->nenvelopes == 0)
+ 			return -1;
+ 
+ 		pd->state = BMSG_STATE_BEGIN_BODY;
+ 
+ 		return 0;
+ 	}
+ 
+ 	if (pd->bmsg->nenvelopes >= BMSG_NENVELOPES_MAX)
+ 		return -1;
+ 
+ 	++pd->bmsg->nenvelopes;
+ 	pd->state = BMSG_STATE_RECIPIENT;
+ 
+ 	return 0;
+ }
+ 
+ static int bmsg_parser_recipient(struct bmsg_parser *pd)
+ {
+ 	if (match_full_line(pd, "BEGIN:VCARD") == 0) {
+ 		int i;
+ 
+ 		pd->vcard = g_new0(struct bmsg_bmsg_vcard, 1);
+ 		i = pd->bmsg->nenvelopes - 1;
+ 		pd->bmsg->recipients[i] = g_slist_append(pd->bmsg->recipients[i],
+ 								pd->vcard);
+ 		pd->state = BMSG_STATE_VCARD;
+ 		pd->unwind_state = BMSG_STATE_RECIPIENT;
+ 	} else {
+ 		pd->state = BMSG_STATE_BEGIN_ENVELOPE;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int bmsg_parser_begin_body(struct bmsg_parser *pd)
+ {
+ 	if (match_full_line(pd, "BEGIN:BBODY") != 0)
+ 		return -1;
+ 
+ 	pd->state = BMSG_STATE_PART_ID;
+ 
+ 	return 0;
+ }
+ 
+ static int bmsg_parser_part_id(struct bmsg_parser *pd)
+ {
+ 	ssize_t len;
+ 	char *val, *s, *e;
+ 	unsigned long id;
+ 
+ 	len = match_with_param(pd, "PARTID:", &val);
+ 	if (len < 0)
+ 		goto cont;
+ 
+ 	if (!isdigit(val[0]))
+ 		return -1;
+ 
+ 	s = g_strndup(val, len);
+ 	id = strtoul(val, &e, 10);
+ 	g_free(s);
+ 
+ 	if (*e != '\0')
+ 		return -1;
+ 	if (id > 65535)
+ 		return -1;
+ 
+ 	pd->bmsg->part_id = id;
+ 
+ cont:
+ 	pd->state = BMSG_STATE_ENCODING;
+ 
+ 	return 0;
+ }
+ 
+ static int bmsg_parser_encoding(struct bmsg_parser *pd)
+ {
+ 	ssize_t len;
+ 	char *val;
+ 	unsigned int i;
+ 
+ 	len = match_with_param(pd, "ENCODING:", &val);
+ 	if (len < 0)
+ 		goto cont;
+ 
+ 	for (i = 0; i < sizeof(bmsg_encodings)/sizeof(bmsg_encodings[0]); ++i) {
+ 		if (strncmp(val, bmsg_encodings[i].s, len) == 0) {
+ 			pd->bmsg->encoding = bmsg_encodings[i].encoding;
+ 			goto cont;
+ 		}
+ 	}
+ 
+ 	return -1;	/* No matching encoding */
+ 
+ cont:
+ 	pd->state = BMSG_STATE_CHARSET;
+ 
+ 	return 0;
+ }
+ 
+ static int bmsg_parser_charset(struct bmsg_parser *pd)
+ {
+ 	ssize_t len;
+ 	char *val;
+ 
+ 	len = match_with_param(pd, "CHARSET:", &val);
+ 	if (len < 0)
+ 		goto cont;
+ 
+ 	if (strncmp(val, "UTF-8", len) != 0)
+ 		return -1;
+ 
+ 	pd->bmsg->charset = BMSG_C_UTF8;
+ cont:
+ 	pd->state = BMSG_STATE_LANGUAGE;
+ 
+ 	return 0;
+ }
+ 
+ static int bmsg_parser_language(struct bmsg_parser *pd)
+ {
+ 	ssize_t len;
+ 	char *val;
+ 	unsigned int i;
+ 
+ 	len = match_with_param(pd, "LANGUAGE:", &val);
+ 	if (len < 0)
+ 		goto cont;
+ 
+ 	for (i = 0; i < sizeof(bmsg_languages)/sizeof(bmsg_languages[0]); ++i) {
+ 		if (strncmp(val, bmsg_languages[i].s, len) == 0) {
+ 			pd->bmsg->language = bmsg_languages[i].language;
+ 			goto cont;
+ 		}
+ 	}
+ 
+ 	return -1;	/* No matching language */
+ 
+ cont:
+ 	pd->state = BMSG_STATE_LENGTH;
+ 
+ 	return 0;
+ }
+ 
+ static int bmsg_parser_length(struct bmsg_parser *pd)
+ {
+ 	ssize_t len;
+ 	char *val, *s, *e;
+ 	unsigned long length;
+ 
+ 	len = match_with_param(pd, "LENGTH:", &val);
+ 	if (len < 0)
+ 		return -1;
+ 
+ 	if (!isdigit(val[0]))
+ 		return -1;
+ 
+ 	s = g_strndup(val, len);
+ 
+ 	length = strtoul(s, &e, 10);
+ 	if (*e != '\0')
+ 		return -1;
+ 
+ 	g_free(s);
+ 
+ 	pd->bmsg->length = length;
+ 	pd->state = BMSG_STATE_BEGIN_MSG;
+ 
+ 	return 0;
+ }
+ 
+ struct bmsg_bmsg *bmsg_new(void)
+ {
+ 	struct bmsg_bmsg *bmsg = g_new0(struct bmsg_bmsg, 1);
+ 
+ 	bmsg->part_id = -1;
+ 
+ 	return bmsg;
+ }
+ 
+ static void bmsg_vcard_free(gpointer data)
+ {
+ 	struct bmsg_bmsg_vcard *vc = data;
+ 
+ 	g_free(vc->fn);
+ 	g_free(vc->n);
+ 	g_free(vc->tel);
+ 	g_free(vc->email);
+ 	g_free(vc);
+ }
+ 
+ void bmsg_free(struct bmsg_bmsg *bmsg)
+ {
+ 	if (bmsg == NULL)
+ 		return;
+ 
+ 	g_slist_free_full(bmsg->originators, bmsg_vcard_free);
+ 
+ 	while (bmsg->nenvelopes) {
+ 		--bmsg->nenvelopes;
+ 		g_slist_free_full(bmsg->recipients[bmsg->nenvelopes],
+ 							bmsg_vcard_free);
+ 	}
+ 
+ 	g_free(bmsg->folder);
+ 	g_free(bmsg);
+ }
+ 
+ struct bmsg_parser *bmsg_parser_new(void)
+ {
+ 	struct bmsg_parser *pd;
+ 	GError *gerror = NULL;
+ 	GRegex *re;
+ 
+ 	re = g_regex_new("^(?:[[:alnum:].]+\\.)?([[:alpha:]]+)"
+ 						"(?:;([^:]*?))?:(.*)",
+ 						G_REGEX_CASELESS | G_REGEX_RAW,
+ 						0, &gerror);
+ 	if (gerror != NULL) {
+ 		DBG("g_regex_new error: %s", gerror->message);
+ 		g_error_free(gerror);
+ 
+ 		return NULL;
+ 	}
+ 
+ 	pd = g_new0(struct bmsg_parser, 1);
+ 	pd->bmsg = bmsg_new();
+ 	pd->vcard_re = re;
+ 
+ 	return pd;
+ }
+ 
+ static char *memcrlf(char *s, size_t len)
+ {
+ 	size_t i;
+ 
+ 	len -= 1;
+ 	for (i = 0; i < len; ++i) {
+ 		if (s[i] == '\r' && s[i+1] == '\n')
+ 			return s + i;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ int bmsg_parser_process(struct bmsg_parser *pd, char **data, size_t len)
+ {
+ 	int ret;
+ 
+ 	if (pd->finished)
+ 		return 0;
+ 
+ 	pd->input = *data;
+ 	pd->nleft = len;
+ 
+ 	for (;;) {
+ 		DBG("for %d %p", pd->state, actions[pd->state]);
+ 		if (actions[pd->state] == NULL) {
+ 			pd->finished = TRUE;
+ 			ret = 0;
+ 			break;
+ 		}
+ 
+ 		pd->eol = memcrlf(pd->input, pd->nleft);
+ 		if (pd->eol == NULL) {
+ 			ret = 1;
+ 			break;
+ 		}
+ 
+ 		ret = actions[pd->state](pd);
+ 		if (ret < 0) {
+ 			char *tmp;
+ 
+ 			tmp = pd->input;
+ 			if ((pd->input - *data) > 20)
+ 				tmp = pd->input - 20;
+ 			else
+ 				tmp = *data;
+ 
+ 			/* FIXME: no zero */
+ 			DBG("bmsg parsing error, state %d, context: %.40s",
+ 								pd->state, tmp);
+ 
+ 			pd->finished = TRUE;
+ 			break;
+ 		}
+ 	}
+ 
+ 	*data = pd->input;
+ 
+ 	return ret;
+ }
+ 
+ struct bmsg_bmsg *bmsg_parser_get_bmsg(struct bmsg_parser *pd)
+ {
+ 	struct bmsg_bmsg *bmsg;
+ 
+ 	if (!pd->finished)
+ 		return NULL;
+ 
+ 	bmsg = pd->bmsg;
+ 	pd->bmsg = NULL;
+ 
+ 	return bmsg;
+ }
+ 
+ void bmsg_parser_free(struct bmsg_parser *pd)
+ {
+ 	if (pd == NULL)
+ 		return;
+ 
+ 	bmsg_free(pd->bmsg);
+ 	g_regex_unref(pd->vcard_re);
+ 
+ 	g_free(pd);
+ }
+ 
+ static gboolean match_and_move(char **buf, char *pattern, size_t *len)
+ {
+ 	size_t plen = strlen(pattern);
+ 
+ 	if (*len < plen)
+ 		return FALSE;
+ 
+ 	if (strncmp(*buf, pattern, plen) == 0) {
+ 		*buf += plen;
+ 		*len -= plen;
+ 		return TRUE;
+ 	}
+ 
+ 	return FALSE;
+ }
+ 
+ size_t bmsg_parser_tail_length(struct bmsg_bmsg *bmsg)
+ {
+ 	/* strlen("END:BBODY\r\n") + bmsg->nenvelopes * strlen("END:BENV\r\n") +
+ 	 * strlen("END:BMSG\r\n")
+ 	 */
+ 	return (11 + bmsg->nenvelopes * 10 + 10);
+ }
+ 
+ gboolean bmsg_parser_tail_correct(struct bmsg_bmsg *bmsg, char *tail, size_t len)
+ {
+ 	int nenv = bmsg->nenvelopes;
+ 	char *t = tail;
+ 
+ 	if (!match_and_move(&t, "END:BBODY\r\n", &len))
+ 		return FALSE;
+ 
+ 	while (nenv-- > 0)
+ 		if (!match_and_move(&t, "END:BENV\r\n", &len))
+ 			return FALSE;
+ 
+ 	if (!match_and_move(&t, "END:BMSG\r\n", &len))
+ 		return FALSE;
+ 
+ 	if (len != 0)
+ 		return FALSE;
+ 
+ 	return TRUE;
+ }
+ 
diff -crN plugins/bmsg_parser.h plugins/bmsg_parser.h
*** plugins/bmsg_parser.h	Wed Dec 31 19:00:00 1969
--- plugins/bmsg_parser.h	Tue Oct  2 04:37:04 2012
***************
*** 0 ****
--- 1,96 ----
+ #ifndef BMSG_PARSER_H
+ #define BMSG_PARSER_H 1
+ 
+ #define BMSG_NENVELOPES_MAX 3
+ 
+ /* As MAP errata accepted proposal says, LENGTH of bMsg shall include initial
+  * "BEGIN:MSG\r\n", the "\r\n" terminating actual data and "END:MSG\r\n".
+  */
+ #define MSG_BLOCK_OVERHEAD (9 + 2 + 2 + 7 + 2)
+ 
+ 
+ enum bmsg_type {
+ 	BMSG_T_UNSPECIFIED,
+ 	BMSG_T_SMS_GSM,
+ 	BMSG_T_SMS_CDMA,
+ 	BMSG_T_EMAIL,
+ 	BMSG_T_MMS
+ };
+ 
+ enum bmsg_encoding {
+ 	BMSG_E_UNSPECIFIED,
+ 	BMSG_E_8BIT,
+ 	BMSG_E_G_7BIT,
+ 	BMSG_E_G_7BITEXT,
+ 	BMSG_E_G_UCS2,
+ 	BMSG_E_G_8BIT,
+ 	BMSG_E_C_8BIT,
+ 	BMSG_E_C_EPM,
+ 	BMSG_E_C_7ASCII,
+ 	BMSG_E_C_IA5,
+ 	BMSG_E_C_UNICODE,
+ 	BMSG_E_C_SJIS,
+ 	BMSG_E_C_KOREAN,
+ 	BMSG_E_C_LATINHEB,
+ 	BMSG_E_C_LATIN
+ };
+ 
+ enum bmsg_language {
+ 	BMSG_L_UNSPECIFIED,
+ 	BMSG_L_TURKISH,
+ 	BMSG_L_SPANISH,
+ 	BMSG_L_PORTUGUESE,
+ 	BMSG_L_UNKNOWN,
+ 	BMSG_L_ENGLISH,
+ 	BMSG_L_FRENCH,
+ 	BMSG_L_JAPANESE,
+ 	BMSG_L_KOREAN,
+ 	BMSG_L_CHINESE,
+ 	BMSG_L_HEBREW
+ };
+ 
+ enum bmsg_charset {
+ 	BMSG_C_UNSPECIFIED,
+ 	BMSG_C_UTF8
+ };
+ 
+ enum bmsg_vcard_version {
+ 	BMSG_VCARD_21,
+ 	BMSG_VCARD_30
+ };
+ 
+ struct bmsg_bmsg_vcard {
+ 	enum bmsg_vcard_version version;
+ 	char *n;
+ 	char *fn;
+ 	char *tel;
+ 	char *email;
+ };
+ 
+ struct bmsg_bmsg {
+ 	gboolean read;
+ 	enum bmsg_type type;
+ 	char *folder;
+ 	GSList *originators;
+ 	int nenvelopes;
+ 	GSList *recipients[BMSG_NENVELOPES_MAX];
+ 	long int part_id;
+ 	enum bmsg_encoding encoding;
+ 	enum bmsg_charset charset;
+ 	enum bmsg_language language;
+ 	size_t length;
+ };
+ 
+ struct bmsg_parser;
+ 
+ struct bmsg_bmsg *bmsg_new(void);
+ void bmsg_free(struct bmsg_bmsg *bmsg);
+ struct bmsg_parser *bmsg_parser_new(void);
+ int bmsg_parser_process(struct bmsg_parser *pd, char **data, size_t len);
+ struct bmsg_bmsg *bmsg_parser_get_bmsg(struct bmsg_parser *pd);
+ void bmsg_parser_free(struct bmsg_parser *pd);
+ size_t bmsg_parser_tail_length(struct bmsg_bmsg *bmsg);
+ gboolean bmsg_parser_tail_correct(struct bmsg_bmsg *bmsg, char *tail, size_t len);
+ 
+ 
+ #endif
diff -crN plugins/mas.c plugins/mas.c
*** plugins/mas.c	Tue Oct  2 04:11:18 2012
--- plugins/mas.c	Tue Oct  2 05:02:12 2012
***************
*** 44,49 ****
--- 44,50 ----
  #include "map_ap.h"
  
  #include "messages.h"
+ #include "bmsg_parser.h"
  
  /* Channel number according to bluez doc/assigned-numbers.txt */
  #define MAS_CHANNEL	16
***************
*** 89,95 ****
    </attribute>								\
  									\
    <attribute id=\"0x0316\">						\
!     <uint8 value=\"0x0F\"/>						\
    </attribute>								\
  </record>"
  
--- 90,96 ----
    </attribute>								\
  									\
    <attribute id=\"0x0316\">						\
!     <uint8 value=\"0x02\"/>						\
    </attribute>								\
  </record>"
  
***************
*** 107,126 ****
  #define ML_BODY_END "</MAP-msg-listing>"
  
  struct mas_session {
! 	struct mas_request *request;
  	void *backend_data;
  	gboolean finished;
- 	gboolean nth_call;
  	GString *buffer;
  	map_ap_t *inparams;
  	map_ap_t *outparams;
  	gboolean ap_sent;
  };
  
  static const uint8_t MAS_TARGET[TARGET_SIZE] = {
  			0xbb, 0x58, 0x2b, 0x40, 0x42, 0x0c, 0x11, 0xdb,
  			0xb0, 0xde, 0x08, 0x00, 0x20, 0x0c, 0x9a, 0x66  };
  
  static int get_params(struct obex_session *os, struct mas_session *mas)
  {
  	const uint8_t *buffer;
--- 108,463 ----
  #define ML_BODY_END "</MAP-msg-listing>"
  
  struct mas_session {
! 	char *remote_addr;
  	void *backend_data;
  	gboolean finished;
  	GString *buffer;
  	map_ap_t *inparams;
  	map_ap_t *outparams;
  	gboolean ap_sent;
+ 	DBusConnection *dbus;
+ 	gboolean mns_enabled;
+ 	DBusPendingCall *pending_session;
+ 	DBusPendingCall *pending_event;
+ 	char *mns_path;
+ 	gboolean disconnected;
+ 	struct obex_session *obex_os;
+ 	void *request;
+ 	GDestroyNotify request_free;
+ 	GQueue *events_queue;
+ };
+ 
+ struct any_object {
+ 	struct mas_session *mas;
+ };
+ 
+ struct notification_registration_request {
+ 	uint8_t status;
+ };
+ 
+ struct msg_listing_request {
+ 	gboolean nth_call;
+ 	gboolean only_count;
+ 	struct messages_filter filter;
+ 	uint8_t subject_len;
+ };
+ 
+ struct folder_listing_request {
+ 	gboolean nth_call;
+ 	gboolean only_count;
+ };
+ 
+ struct get_message_request {
+ 	unsigned long flags;
+ };
+ 
+ struct message_put_request {
+ 	GString *buf; 		/* FIXME: use mas_session.buffer instead */
+ 	const char *name;
+ 	struct bmsg_bmsg *bmsg;
+ 	struct bmsg_parser *parser;
+ 	unsigned long flags;
+ 	gboolean parsed;
+ 	size_t remaining;
+ 	char *handle;
+ 	gsize handle_len;
+ 	gboolean hnd_sent;
  };
  
  static const uint8_t MAS_TARGET[TARGET_SIZE] = {
  			0xbb, 0x58, 0x2b, 0x40, 0x42, 0x0c, 0x11, 0xdb,
  			0xb0, 0xde, 0x08, 0x00, 0x20, 0x0c, 0x9a, 0x66  };
  
+ static void append_entry(DBusMessageIter *dict,
+ 				const char *key, void *val)
+ {
+ 	DBusMessageIter entry, value;
+ 
+ 	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
+ 								NULL, &entry);
+ 
+ 	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
+ 
+ 	dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT,
+ 					DBUS_TYPE_STRING_AS_STRING, &value);
+ 	dbus_message_iter_append_basic(&value, DBUS_TYPE_STRING, val);
+ 	dbus_message_iter_close_container(&entry, &value);
+ 
+ 	dbus_message_iter_close_container(dict, &entry);
+ }
+ 
+ static void event_free(struct messages_event *event)
+ {
+ 	g_free(event->handle);
+ 	g_free(event->folder);
+ 	g_free(event->old_folder);
+ 	g_free(event);
+ }
+ 
+ static void clear_events_queue(struct mas_session *mas)
+ {
+ 	GList *cur;
+ 
+ 	for (cur = mas->events_queue->head; cur != NULL; cur = cur->next)
+ 		event_free(cur->data);
+ 
+ 	g_queue_clear(mas->events_queue);
+ }
+ 
+ static void messages_event_pcn(DBusPendingCall *pc, void *user_data);
+ 
+ static void send_next_event(struct mas_session *mas)
+ {
+ 	struct messages_event *event;
+ 	DBusMessage *outgoing;
+ 	unsigned char evt;
+ 	unsigned char msgtype = 2;
+ 
+ 	event = g_queue_pop_head(mas->events_queue);
+ 	if (event == NULL)
+ 		return;
+ 
+ 	evt = (unsigned char)event->type + 1;
+ 
+ 	outgoing = dbus_message_new_method_call("org.openobex.client",
+ 			mas->mns_path, "org.openobex.MNS", "SendEvent");
+ 
+ 	dbus_message_append_args(outgoing,
+ 			DBUS_TYPE_BYTE, &event->instance_id,
+ 			DBUS_TYPE_BYTE, &evt,
+ 			DBUS_TYPE_STRING, &event->handle,
+ 			DBUS_TYPE_STRING, &event->folder,
+ 			DBUS_TYPE_STRING, &event->old_folder,
+ 			DBUS_TYPE_BYTE, &msgtype,
+ 			DBUS_TYPE_INVALID);
+ 
+ 	dbus_connection_send_with_reply(mas->dbus, outgoing,
+ 			&mas->pending_event, -1);
+ 
+ 	dbus_message_unref(outgoing);
+ 
+ 	dbus_pending_call_set_notify(mas->pending_event,
+ 			messages_event_pcn, mas, NULL);
+ 
+ 	event_free(event);
+ }
+ 
+ static int mns_stop_session(struct mas_session *mas);
+ 
+ static void mns_start_session_pcn(DBusPendingCall *pc, void *user_data)
+ {
+ 	struct mas_session *mas = user_data;
+ 	DBusMessage *incoming;
+ 	char *path;
+ 
+ 	DBG("");
+ 	incoming = dbus_pending_call_steal_reply(pc);
+ 
+ 	if (!incoming) {
+ 		DBG("No reply!");       /* This probably should not happen */
+ 		goto cleanup;
+ 	}
+ 
+ 	if (dbus_message_get_type(incoming) != DBUS_MESSAGE_TYPE_METHOD_RETURN) {
+ 		DBG("Error when starting session!");
+ 		goto cleanup;
+ 	}
+ 
+ 	if (!dbus_message_has_signature(incoming,
+ 				DBUS_TYPE_OBJECT_PATH_AS_STRING)) {
+ 		DBG("Wrong signature!");
+ 		goto cleanup;
+ 	}
+ 
+ 	dbus_message_get_args(incoming, NULL, DBUS_TYPE_OBJECT_PATH,
+ 			&path, DBUS_TYPE_INVALID);
+ 
+ 	mas->mns_path = g_strdup(path);
+ 	DBG("Path: %s", mas->mns_path);
+ 
+ cleanup:
+ 	dbus_message_unref(incoming);
+ 	dbus_pending_call_unref(pc);
+ 	mas->pending_session = NULL;
+ 
+ 	if (mas->mns_enabled == FALSE)
+ 		mns_stop_session(mas);
+ 	else
+ 		send_next_event(mas);
+ }
+ 
+ /* XXX: How to act when connection is unexpectedly closed. */
+ static int mns_start_session(struct mas_session *mas)
+ {
+ 	DBusMessage *outgoing;
+ 	DBusMessageIter iter, dict;
+ 	char *mns = "MNS";
+ 
+ 	DBG("");
+ 	mas->mns_enabled = TRUE;
+ 
+ 	if (mas->mns_path)
+ 		return 0;
+ 
+ 	if (mas->pending_session)
+ 		return 0;
+ 
+ 	if (!mas->dbus)
+ 		mas->dbus = manager_dbus_get_connection();
+ 
+ 	outgoing = dbus_message_new_method_call("org.openobex.client", "/",
+ 			"org.openobex.Client", "CreateSession");
+ 
+ 	if (!outgoing) {
+ 		DBG("Failed message creation.");
+ 		return -1;
+ 	}
+ 
+ 	dbus_message_iter_init_append(outgoing, &iter);
+ 
+ 	dbus_message_iter_open_container(&iter, DBUS_TYPE_ARRAY,
+ 			DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+ 			DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING
+ 			DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
+ 
+ 	append_entry(&dict, "Destination", &mas->remote_addr);
+ 	append_entry(&dict, "Target", &mns);
+ 
+ 	dbus_message_iter_close_container(&iter, &dict);
+ 	dbus_connection_send_with_reply(mas->dbus, outgoing,
+ 			&mas->pending_session, -1);
+ 
+ 	dbus_message_unref(outgoing);
+ 
+ 	DBG("before set notify");
+ 	dbus_pending_call_set_notify(mas->pending_session,
+ 			mns_start_session_pcn, mas, NULL);
+ 
+ 	return 0;
+ }
+ 
+ static void mas_clean(struct mas_session *mas);
+ 
+ static void mns_stop_session_pcn(DBusPendingCall *pc, void *user_data)
+ {
+ 	struct mas_session *mas = user_data;
+ 
+ 	DBG("");
+ 
+ 	/* Ignore errors */
+ 	dbus_pending_call_unref(pc);
+ 	mas->pending_session = NULL;
+ 
+ 	g_free(mas->mns_path);
+ 	mas->mns_path = NULL;
+ 
+ 	if (mas->mns_enabled)
+ 		mns_start_session(mas);
+ 
+ 	if (mas->disconnected)
+ 		mas_clean(mas);
+ }
+ 
+ static int mns_stop_session(struct mas_session *mas)
+ {
+ 	DBusMessage *outgoing;
+ 
+ 	DBG("");
+ 
+ 	clear_events_queue(mas);
+ 	mas->mns_enabled = FALSE;
+ 
+ 	if (mas->pending_session)
+ 		return 0;
+ 
+ 	if (!mas->mns_path)
+ 		return -1;
+ 
+ 	if (!mas->dbus)
+ 		mas->dbus = manager_dbus_get_connection();
+ 
+ 	outgoing = dbus_message_new_method_call("org.openobex.client", "/",
+ 			"org.openobex.Client", "RemoveSession");
+ 
+ 	if (!outgoing) {
+ 		DBG("Failed message creation.");
+ 		return -1;
+ 	}
+ 
+ 	dbus_message_append_args(outgoing, DBUS_TYPE_OBJECT_PATH,
+ 			&mas->mns_path, DBUS_TYPE_INVALID);
+ 
+ 	dbus_connection_send_with_reply(mas->dbus, outgoing,
+ 			&mas->pending_session, -1);
+ 
+ 	dbus_message_unref(outgoing);
+ 
+ 	dbus_pending_call_set_notify(mas->pending_session,
+ 			mns_stop_session_pcn, mas, NULL);
+ 
+ 	return 0;
+ }
+ 
+ static void messages_event_pcn(DBusPendingCall *pc, void *user_data)
+ {
+ 	struct mas_session *mas = user_data;
+ 	DBusMessage *incoming;
+ 
+ 	incoming = dbus_pending_call_steal_reply(pc);
+ 
+ 	if (!incoming || dbus_message_get_type(incoming)
+ 			!= DBUS_MESSAGE_TYPE_METHOD_RETURN) {
+ 		DBG("Error when sending notification!");
+ 		mas->mns_enabled = FALSE;
+ 	}
+ 
+ 	dbus_message_unref(incoming);
+ 	dbus_pending_call_unref(pc);
+ 	mas->pending_event = NULL;
+ 
+ 	/*
+ 	 * XXX: Or maybe better call ResetSession without waiting for event
+ 	 * sending to finish
+ 	 */
+ 	if (!mas->mns_enabled)
+ 		mns_stop_session(mas);
+ 	else
+ 		send_next_event(mas);
+ }
+ 
+ static void my_messages_event_cb(void *session, const struct messages_event *data, void *user_data)
+ {
+ 	struct mas_session *mas = user_data;
+ 
+ 	DBG("");
+ 
+ 	if (!mas->mns_path) {
+ 		DBG("Backend tried to pushed event, but MNS is not connected!");
+ 		return;
+ 	}
+ 
+ 	g_queue_push_tail(mas->events_queue, (gpointer)data);   /* FIXME */
+ 
+ 	if (mas->pending_session || mas->pending_event) {
+ 		DBG("MNS session connection or event sending in progress.");
+ 		return;
+ 	}
+ 
+ 	send_next_event(mas);
+ }
+ 
+ static int set_notification_registration(struct mas_session *mas, int state)
+ {
+ 	if (state == 1)
+ 		mns_start_session(mas);
+ 	else if (state == 0)
+ 		mns_stop_session(mas);
+ 	else
+ 		return -EBADR;
+ 
+ 	return 0;
+ }
+ 
  static int get_params(struct obex_session *os, struct mas_session *mas)
  {
  	const uint8_t *buffer;
***************
*** 141,165 ****
  	return 0;
  }
  
! static void reset_request(struct mas_session *mas)
  {
  	if (mas->buffer) {
  		g_string_free(mas->buffer, TRUE);
  		mas->buffer = NULL;
  	}
  
  	map_ap_free(mas->inparams);
  	mas->inparams = NULL;
  	map_ap_free(mas->outparams);
  	mas->outparams = NULL;
  
! 	mas->nth_call = FALSE;
  	mas->finished = FALSE;
  }
  
  static void mas_clean(struct mas_session *mas)
  {
! 	reset_request(mas);
  	g_free(mas);
  }
  
--- 478,514 ----
  	return 0;
  }
  
! static void mas_reset(struct obex_session *os, void *user_data)
  {
+ 	struct mas_session *mas = user_data;
+ 
+ 	DBG("");
+ 
  	if (mas->buffer) {
  		g_string_free(mas->buffer, TRUE);
  		mas->buffer = NULL;
  	}
  
+ 	if (mas->request_free != NULL) {
+ 		mas->request_free(mas->request);
+ 
+ 		mas->request_free = NULL;
+ 		mas->request = NULL;
+ 	}
+ 
  	map_ap_free(mas->inparams);
  	mas->inparams = NULL;
  	map_ap_free(mas->outparams);
  	mas->outparams = NULL;
  
! 	mas->ap_sent = FALSE;
  	mas->finished = FALSE;
  }
  
  static void mas_clean(struct mas_session *mas)
  {
! 	g_queue_free(mas->events_queue);
! 	g_free(mas->remote_addr);
  	g_free(mas);
  }
  
***************
*** 175,180 ****
--- 524,535 ----
  	if (*err < 0)
  		goto failed;
  
+ 	/* This gets bluetooth remote party address */
+ 	obex_getpeername(os, &mas->remote_addr);
+ 
+ 	mas->obex_os = os;
+ 	mas->events_queue = g_queue_new();
+ 
  	manager_register_session(os);
  
  	return mas;
***************
*** 194,200 ****
  	manager_unregister_session(os);
  	messages_disconnect(mas->backend_data);
  
! 	mas_clean(mas);
  }
  
  static int mas_get(struct obex_session *os, void *user_data)
--- 549,561 ----
  	manager_unregister_session(os);
  	messages_disconnect(mas->backend_data);
  
! 	mas->disconnected = TRUE;
! 	clear_events_queue(mas);
! 
! 	if (mas->mns_enabled || mas->pending_event || mas->pending_session)
! 		set_notification_registration(mas, 0);
! 	else
! 		mas_clean(mas);
  }
  
  static int mas_get(struct obex_session *os, void *user_data)
***************
*** 207,229 ****
  	DBG("GET: name %s type %s mas %p",
  			name, type, mas);
  
  	if (type == NULL)
  		return -EBADR;
  
  	ret = get_params(os, mas);
  	if (ret < 0)
! 		goto failed;
  
  	ret = obex_get_stream_start(os, name);
  	if (ret < 0)
! 		goto failed;
  
  	return 0;
- 
- failed:
- 	reset_request(mas);
- 
- 	return ret;
  }
  
  static int mas_put(struct obex_session *os, void *user_data)
--- 568,587 ----
  	DBG("GET: name %s type %s mas %p",
  			name, type, mas);
  
+ 	mas->buffer = g_string_new("");
+ 
  	if (type == NULL)
  		return -EBADR;
  
  	ret = get_params(os, mas);
  	if (ret < 0)
! 		return ret;
  
  	ret = obex_get_stream_start(os, name);
  	if (ret < 0)
! 		return ret;
  
  	return 0;
  }
  
  static int mas_put(struct obex_session *os, void *user_data)
***************
*** 235,257 ****
  
  	DBG("PUT: name %s type %s mas %p", name, type, mas);
  
  	if (type == NULL)
  		return -EBADR;
  
  	ret = get_params(os, mas);
  	if (ret < 0)
! 		goto failed;
  
  	ret = obex_put_stream_start(os, name);
  	if (ret < 0)
! 		goto failed;
  
  	return 0;
- 
- failed:
- 	reset_request(mas);
- 
- 	return ret;
  }
  
  /* FIXME: Preserve whitespaces */
--- 593,612 ----
  
  	DBG("PUT: name %s type %s mas %p", name, type, mas);
  
+ 	mas->buffer = g_string_new("");
+ 
  	if (type == NULL)
  		return -EBADR;
  
  	ret = get_params(os, mas);
  	if (ret < 0)
! 		return ret;
  
  	ret = obex_put_stream_start(os, name);
  	if (ret < 0)
! 		return ret;
  
  	return 0;
  }
  
  /* FIXME: Preserve whitespaces */
***************
*** 276,311 ****
  	return "no";
  }
  
  static void get_messages_listing_cb(void *session, int err, uint16_t size,
  					gboolean newmsg,
  					const struct messages_message *entry,
  					void *user_data)
  {
  	struct mas_session *mas = user_data;
! 	uint16_t max = 1024;
  
  	if (err < 0 && err != -EAGAIN) {
  		obex_object_set_io_flags(mas, G_IO_ERR, err);
  		return;
  	}
  
! 	map_ap_get_u16(mas->inparams, MAP_AP_MAXLISTCOUNT, &max);
! 
! 	if (max == 0) {
! 		if (!entry)
! 			mas->finished = TRUE;
! 
  		goto proceed;
- 	}
  
! 	if (!mas->nth_call) {
  		g_string_append(mas->buffer, ML_BODY_BEGIN);
! 		mas->nth_call = TRUE;
  	}
  
  	if (!entry) {
  		g_string_append(mas->buffer, ML_BODY_END);
- 		mas->finished = TRUE;
  
  		goto proceed;
  	}
--- 631,677 ----
  	return "no";
  }
  
+ static char *trim_utf8(char *s, size_t len)
+ {
+ 	char *end;
+ 	size_t l;
+ 
+ 	l = strlen(s);
+ 	if (l > len)
+ 		l = len;
+ 
+ 	g_utf8_validate(s, len, (const gchar **)&end);
+ 	*end = '\0';
+ 
+ 	return s;
+ }
+ 
  static void get_messages_listing_cb(void *session, int err, uint16_t size,
  					gboolean newmsg,
  					const struct messages_message *entry,
  					void *user_data)
  {
  	struct mas_session *mas = user_data;
! 	struct msg_listing_request *request = mas->request;
! 	char timebuf[21];
! 	char *timestr = timebuf;
! 	time_t t;
  
  	if (err < 0 && err != -EAGAIN) {
  		obex_object_set_io_flags(mas, G_IO_ERR, err);
  		return;
  	}
  
! 	if (request->only_count)
  		goto proceed;
  
! 	if (!request->nth_call) {
  		g_string_append(mas->buffer, ML_BODY_BEGIN);
! 		request->nth_call = TRUE;
  	}
  
  	if (!entry) {
  		g_string_append(mas->buffer, ML_BODY_END);
  
  		goto proceed;
  	}
***************
*** 315,388 ****
  	g_string_append_escaped_printf(mas->buffer, " handle=\"%s\"",
  								entry->handle);
  
! 	if (entry->mask & PMASK_SUBJECT)
  		g_string_append_escaped_printf(mas->buffer, " subject=\"%s\"",
! 				entry->subject);
  
! 	if (entry->mask & PMASK_DATETIME)
  		g_string_append_escaped_printf(mas->buffer, " datetime=\"%s\"",
  				entry->datetime);
  
! 	if (entry->mask & PMASK_SENDER_NAME)
  		g_string_append_escaped_printf(mas->buffer,
  						" sender_name=\"%s\"",
  						entry->sender_name);
  
! 	if (entry->mask & PMASK_SENDER_ADDRESSING)
  		g_string_append_escaped_printf(mas->buffer,
  						" sender_addressing=\"%s\"",
  						entry->sender_addressing);
  
! 	if (entry->mask & PMASK_REPLYTO_ADDRESSING)
  		g_string_append_escaped_printf(mas->buffer,
  						" replyto_addressing=\"%s\"",
  						entry->replyto_addressing);
  
! 	if (entry->mask & PMASK_RECIPIENT_NAME)
  		g_string_append_escaped_printf(mas->buffer,
  						" recipient_name=\"%s\"",
  						entry->recipient_name);
  
! 	if (entry->mask & PMASK_RECIPIENT_ADDRESSING)
  		g_string_append_escaped_printf(mas->buffer,
  						" recipient_addressing=\"%s\"",
  						entry->recipient_addressing);
  
! 	if (entry->mask & PMASK_TYPE)
  		g_string_append_escaped_printf(mas->buffer, " type=\"%s\"",
  				entry->type);
  
! 	if (entry->mask & PMASK_RECEPTION_STATUS)
  		g_string_append_escaped_printf(mas->buffer,
  						" reception_status=\"%s\"",
  						entry->reception_status);
  
! 	if (entry->mask & PMASK_SIZE)
  		g_string_append_escaped_printf(mas->buffer, " size=\"%s\"",
  				entry->size);
  
! 	if (entry->mask & PMASK_ATTACHMENT_SIZE)
  		g_string_append_escaped_printf(mas->buffer,
  						" attachment_size=\"%s\"",
  						entry->attachment_size);
  
! 	if (entry->mask & PMASK_TEXT)
  		g_string_append_escaped_printf(mas->buffer, " text=\"%s\"",
  				yesorno(entry->text));
  
! 	if (entry->mask & PMASK_READ)
  		g_string_append_escaped_printf(mas->buffer, " read=\"%s\"",
  				yesorno(entry->read));
  
! 	if (entry->mask & PMASK_SENT)
  		g_string_append_escaped_printf(mas->buffer, " sent=\"%s\"",
  				yesorno(entry->sent));
  
! 	if (entry->mask & PMASK_PROTECTED)
  		g_string_append_escaped_printf(mas->buffer, " protected=\"%s\"",
  				yesorno(entry->protect));
  
! 	if (entry->mask & PMASK_PRIORITY)
  		g_string_append_escaped_printf(mas->buffer, " priority=\"%s\"",
  				yesorno(entry->priority));
  
--- 681,778 ----
  	g_string_append_escaped_printf(mas->buffer, " handle=\"%s\"",
  								entry->handle);
  
! 	if (request->filter.parameter_mask & PMASK_SUBJECT &&
! 			entry->mask & PMASK_SUBJECT) {
! 		char *subject;
! 
! 		subject = g_strdup(entry->subject);
! 		trim_utf8(subject, request->subject_len);
! 
  		g_string_append_escaped_printf(mas->buffer, " subject=\"%s\"",
! 				subject);
  
! 		g_free(subject);
! 	}
! 
! 	if (request->filter.parameter_mask & PMASK_DATETIME &&
! 			entry->mask & PMASK_DATETIME)
  		g_string_append_escaped_printf(mas->buffer, " datetime=\"%s\"",
  				entry->datetime);
  
! 	if (request->filter.parameter_mask & PMASK_SENDER_NAME &&
! 			entry->mask & PMASK_SENDER_NAME)
  		g_string_append_escaped_printf(mas->buffer,
  						" sender_name=\"%s\"",
  						entry->sender_name);
  
! 	if (request->filter.parameter_mask & PMASK_SENDER_ADDRESSING &&
! 			entry->mask & PMASK_SENDER_ADDRESSING)
  		g_string_append_escaped_printf(mas->buffer,
  						" sender_addressing=\"%s\"",
  						entry->sender_addressing);
  
! 	if (request->filter.parameter_mask & PMASK_REPLYTO_ADDRESSING &&
! 			entry->mask & PMASK_REPLYTO_ADDRESSING)
  		g_string_append_escaped_printf(mas->buffer,
  						" replyto_addressing=\"%s\"",
  						entry->replyto_addressing);
  
! 	if (request->filter.parameter_mask & PMASK_RECIPIENT_NAME &&
! 			entry->mask & PMASK_RECIPIENT_NAME)
  		g_string_append_escaped_printf(mas->buffer,
  						" recipient_name=\"%s\"",
  						entry->recipient_name);
  
! 	if (request->filter.parameter_mask & PMASK_RECIPIENT_ADDRESSING &&
! 			entry->mask & PMASK_RECIPIENT_ADDRESSING)
  		g_string_append_escaped_printf(mas->buffer,
  						" recipient_addressing=\"%s\"",
  						entry->recipient_addressing);
  
! 	if (request->filter.parameter_mask & PMASK_TYPE &&
! 			entry->mask & PMASK_TYPE)
  		g_string_append_escaped_printf(mas->buffer, " type=\"%s\"",
  				entry->type);
  
! 	if (request->filter.parameter_mask & PMASK_RECEPTION_STATUS &&
! 			entry->mask & PMASK_RECEPTION_STATUS)
  		g_string_append_escaped_printf(mas->buffer,
  						" reception_status=\"%s\"",
  						entry->reception_status);
  
! 	if (request->filter.parameter_mask & PMASK_SIZE &&
! 			entry->mask & PMASK_SIZE)
  		g_string_append_escaped_printf(mas->buffer, " size=\"%s\"",
  				entry->size);
  
! 	if (request->filter.parameter_mask & PMASK_ATTACHMENT_SIZE &&
! 			entry->mask & PMASK_ATTACHMENT_SIZE)
  		g_string_append_escaped_printf(mas->buffer,
  						" attachment_size=\"%s\"",
  						entry->attachment_size);
  
! 	if (request->filter.parameter_mask & PMASK_TEXT &&
! 			entry->mask & PMASK_TEXT)
  		g_string_append_escaped_printf(mas->buffer, " text=\"%s\"",
  				yesorno(entry->text));
  
! 	if (request->filter.parameter_mask & PMASK_READ &&
! 			entry->mask & PMASK_READ)
  		g_string_append_escaped_printf(mas->buffer, " read=\"%s\"",
  				yesorno(entry->read));
  
! 	if (request->filter.parameter_mask & PMASK_SENT &&
! 			entry->mask & PMASK_SENT)
  		g_string_append_escaped_printf(mas->buffer, " sent=\"%s\"",
  				yesorno(entry->sent));
  
! 	if (request->filter.parameter_mask & PMASK_PROTECTED &&
! 			entry->mask & PMASK_PROTECTED)
  		g_string_append_escaped_printf(mas->buffer, " protected=\"%s\"",
  				yesorno(entry->protect));
  
! 	if (request->filter.parameter_mask & PMASK_PRIORITY &&
! 			entry->mask & PMASK_PRIORITY)
  		g_string_append_escaped_printf(mas->buffer, " priority=\"%s\"",
  				yesorno(entry->priority));
  
***************
*** 390,399 ****
--- 780,795 ----
  
  proceed:
  	if (!entry) {
+ 		mas->finished = TRUE;
+ 
  		map_ap_set_u16(mas->outparams, MAP_AP_MESSAGESLISTINGSIZE,
  							size);
  		map_ap_set_u8(mas->outparams, MAP_AP_NEWMESSAGE,
  							newmsg ? 1 : 0);
+ 		time(&t);
+ 		strftime(timestr, sizeof(timebuf), "%Y%m%dT%H%M%S%z",
+ 				localtime(&t));
+ 		map_ap_set_string(mas->outparams, MAP_AP_MSETIME, timestr);
  	}
  
  	if (err != -EAGAIN)
***************
*** 404,409 ****
--- 800,806 ----
  					const char *chunk, void *user_data)
  {
  	struct mas_session *mas = user_data;
+ 	struct get_message_request *request = mas->request;
  
  	DBG("");
  
***************
*** 414,419 ****
--- 811,821 ----
  
  	if (!chunk) {
  		mas->finished = TRUE;
+ 
+ 		if (request->flags & MESSAGES_FRACTION)
+ 			map_ap_set_u8(mas->outparams, MAP_AP_FRACTIONDELIVER,
+ 					fmore ? 1 : 0);
+ 
  		goto proceed;
  	}
  
***************
*** 428,443 ****
  					const char *name, void *user_data)
  {
  	struct mas_session *mas = user_data;
! 	uint16_t max = 1024;
  
  	if (err < 0 && err != -EAGAIN) {
  		obex_object_set_io_flags(mas, G_IO_ERR, err);
  		return;
  	}
  
! 	map_ap_get_u16(mas->inparams, MAP_AP_MAXLISTCOUNT, &max);
! 
! 	if (max == 0) {
  		if (err != -EAGAIN)
  			map_ap_set_u16(mas->outparams,
  					MAP_AP_FOLDERLISTINGSIZE, size);
--- 830,843 ----
  					const char *name, void *user_data)
  {
  	struct mas_session *mas = user_data;
! 	struct folder_listing_request *request = mas->request;
  
  	if (err < 0 && err != -EAGAIN) {
  		obex_object_set_io_flags(mas, G_IO_ERR, err);
  		return;
  	}
  
! 	if (request->only_count) {
  		if (err != -EAGAIN)
  			map_ap_set_u16(mas->outparams,
  					MAP_AP_FOLDERLISTINGSIZE, size);
***************
*** 448,463 ****
  		goto proceed;
  	}
  
! 	if (!mas->nth_call) {
  		g_string_append(mas->buffer, XML_DECL);
  		g_string_append(mas->buffer, FL_DTD);
  		if (!name) {
  			g_string_append(mas->buffer, FL_BODY_EMPTY);
  			mas->finished = TRUE;
  			goto proceed;
  		}
  		g_string_append(mas->buffer, FL_BODY_BEGIN);
! 		mas->nth_call = TRUE;
  	}
  
  	if (!name) {
--- 848,865 ----
  		goto proceed;
  	}
  
! 	if (!request->nth_call) {
  		g_string_append(mas->buffer, XML_DECL);
  		g_string_append(mas->buffer, FL_DTD);
+ 
  		if (!name) {
  			g_string_append(mas->buffer, FL_BODY_EMPTY);
  			mas->finished = TRUE;
  			goto proceed;
  		}
+ 
  		g_string_append(mas->buffer, FL_BODY_BEGIN);
! 		request->nth_call = TRUE;
  	}
  
  	if (!name) {
***************
*** 518,523 ****
--- 920,926 ----
  				void *driver_data, size_t *size, int *err)
  {
  	struct mas_session *mas = driver_data;
+ 	struct folder_listing_request *request;
  	/* 1024 is the default when there was no MaxListCount sent */
  	uint16_t max = 1024;
  	uint16_t offset = 0;
***************
*** 529,553 ****
  
  	DBG("name = %s", name);
  
  	map_ap_get_u16(mas->inparams, MAP_AP_MAXLISTCOUNT, &max);
  	map_ap_get_u16(mas->inparams, MAP_AP_STARTOFFSET, &offset);
  
  	*err = messages_get_folder_listing(mas->backend_data, name, max,
  					offset, get_folder_listing_cb, mas);
  
- 	mas->buffer = g_string_new("");
- 
  	if (*err < 0)
  		return NULL;
  	else
  		return mas;
  }
  
  static void *msg_listing_open(const char *name, int oflag, mode_t mode,
  				void *driver_data, size_t *size, int *err)
  {
  	struct mas_session *mas = driver_data;
! 	struct messages_filter filter = { 0, };
  	/* 1024 is the default when there was no MaxListCount sent */
  	uint16_t max = 1024;
  	uint16_t offset = 0;
--- 932,966 ----
  
  	DBG("name = %s", name);
  
+ 	request = g_new0(struct folder_listing_request, 1);
+ 	mas->request = request;
+ 	mas->request_free = g_free;
+ 
  	map_ap_get_u16(mas->inparams, MAP_AP_MAXLISTCOUNT, &max);
+ 	request->only_count = max > 0 ? FALSE : TRUE;
  	map_ap_get_u16(mas->inparams, MAP_AP_STARTOFFSET, &offset);
  
  	*err = messages_get_folder_listing(mas->backend_data, name, max,
  					offset, get_folder_listing_cb, mas);
  
  	if (*err < 0)
  		return NULL;
  	else
  		return mas;
  }
  
+ static void msg_listing_free(gpointer data)
+ {
+ 	struct msg_listing_request *request = data;
+ 
+ 	g_free(request);
+ }
+ 
  static void *msg_listing_open(const char *name, int oflag, mode_t mode,
  				void *driver_data, size_t *size, int *err)
  {
  	struct mas_session *mas = driver_data;
! 	struct msg_listing_request *request;
  	/* 1024 is the default when there was no MaxListCount sent */
  	uint16_t max = 1024;
  	uint16_t offset = 0;
***************
*** 559,596 ****
  		return NULL;
  	}
  
  	map_ap_get_u16(mas->inparams, MAP_AP_MAXLISTCOUNT, &max);
  	map_ap_get_u16(mas->inparams, MAP_AP_STARTOFFSET, &offset);
  
  	map_ap_get_u32(mas->inparams, MAP_AP_PARAMETERMASK,
! 						&filter.parameter_mask);
  	map_ap_get_u8(mas->inparams, MAP_AP_FILTERMESSAGETYPE,
! 						&filter.type);
! 	filter.period_begin = map_ap_get_string(mas->inparams,
  						MAP_AP_FILTERPERIODBEGIN);
! 	filter.period_end = map_ap_get_string(mas->inparams,
  						MAP_AP_FILTERPERIODEND);
  	map_ap_get_u8(mas->inparams, MAP_AP_FILTERREADSTATUS,
! 						&filter.read_status);
! 	filter.recipient = map_ap_get_string(mas->inparams,
  						MAP_AP_FILTERRECIPIENT);
! 	filter.originator = map_ap_get_string(mas->inparams,
  						MAP_AP_FILTERORIGINATOR);
  	map_ap_get_u8(mas->inparams, MAP_AP_FILTERPRIORITY,
! 						&filter.priority);
  
  	*err = messages_get_messages_listing(mas->backend_data, name, max,
! 			offset, &filter,
  			get_messages_listing_cb, mas);
  
- 	mas->buffer = g_string_new("");
- 
  	if (*err < 0)
  		return NULL;
  	else
  		return mas;
  }
  
  static void *message_open(const char *name, int oflag, mode_t mode,
  				void *driver_data, size_t *size, int *err)
  {
--- 972,1127 ----
  		return NULL;
  	}
  
+ 	request = g_new0(struct msg_listing_request, 1);
+ 	mas->request = request;
+ 	mas->request_free = msg_listing_free;
+ 	
  	map_ap_get_u16(mas->inparams, MAP_AP_MAXLISTCOUNT, &max);
+ 	request->only_count = max > 0 ? FALSE : TRUE;
  	map_ap_get_u16(mas->inparams, MAP_AP_STARTOFFSET, &offset);
  
  	map_ap_get_u32(mas->inparams, MAP_AP_PARAMETERMASK,
! 						&request->filter.parameter_mask);
! 
! 	if (request->filter.parameter_mask == 0)
! 		request->filter.parameter_mask = 0xFFFF;
! 
! 	map_ap_get_u8(mas->inparams, MAP_AP_SUBJECTLENGTH, &request->subject_len);
! 
! 	if (request->subject_len == 0)
! 		request->subject_len = 255;
! 
  	map_ap_get_u8(mas->inparams, MAP_AP_FILTERMESSAGETYPE,
! 						&request->filter.type);
! 	request->filter.period_begin = map_ap_get_string(mas->inparams,
  						MAP_AP_FILTERPERIODBEGIN);
! 	request->filter.period_end = map_ap_get_string(mas->inparams,
  						MAP_AP_FILTERPERIODEND);
  	map_ap_get_u8(mas->inparams, MAP_AP_FILTERREADSTATUS,
! 						&request->filter.read_status);
! 	request->filter.recipient = map_ap_get_string(mas->inparams,
  						MAP_AP_FILTERRECIPIENT);
! 	request->filter.originator = map_ap_get_string(mas->inparams,
  						MAP_AP_FILTERORIGINATOR);
  	map_ap_get_u8(mas->inparams, MAP_AP_FILTERPRIORITY,
! 						&request->filter.priority);
  
  	*err = messages_get_messages_listing(mas->backend_data, name, max,
! 			offset, &request->filter,
  			get_messages_listing_cb, mas);
  
  	if (*err < 0)
  		return NULL;
  	else
  		return mas;
  }
  
+ static void push_message_cb(void *session, int err, const char *handle,
+ 								void *user_data)
+ {
+ 	struct mas_session *mas = user_data;
+ 
+ 	DBG("");
+ 
+ 	mas->finished = TRUE;
+ 
+ 	if (handle == NULL) {
+ 		DBG("err: %d", err);
+ 		obex_object_set_io_flags(mas, G_IO_ERR, err);
+ 	} else {
+ 		DBG("handle: %s", handle);
+ 
+ 		if (mas->request != NULL) {
+ 			struct message_put_request *request = mas->request;
+ 			char *name16be;
+ 			gsize len;
+ 
+ 			name16be = g_convert(handle, strlen(handle),
+ 					"UTF16BE", "UTF8", NULL, &len, NULL);
+ 
+ 			if (name16be) {
+ 				request->handle = name16be;
+ 				request->handle_len = len;
+ 			}
+ 		}
+ 
+ 		obex_object_set_io_flags(mas, G_IO_OUT, 0);
+ 
+ 	}
+ }
+ 
+ static void message_put_free(gpointer data)
+ {
+ 	struct message_put_request *request = data;
+ 
+ 	bmsg_parser_free(request->parser);
+ 	bmsg_free(request->bmsg);
+ 	g_string_free(request->buf, TRUE);
+ 	g_free(request->handle);
+ 	g_free(request);
+ }
+ 
+ static void message_put(struct mas_session *mas, const char *name, int *err)
+ {
+ 	struct message_put_request *request;
+ 	uint8_t value;
+ 
+ 	DBG("");
+ 
+ 	request = g_new0(struct message_put_request, 1);
+ 
+ 	mas->request = request;
+ 	mas->request_free = message_put_free;
+ 
+ 	map_ap_get_u8(mas->inparams, MAP_AP_CHARSET, &value);
+ 
+ 	if (value & 0x01)
+ 		request->flags |= MESSAGES_UTF8;
+ 
+ 	map_ap_get_u8(mas->inparams, MAP_AP_TRANSPARENT, &value);
+ 
+ 	if (value & 0x01)
+ 		request->flags |= MESSAGES_TRANSPARENT;
+ 
+ 	map_ap_get_u8(mas->inparams, MAP_AP_RETRY, &value);
+ 
+ 	if (value & 0x01)
+ 		request->flags |= MESSAGES_RETRY;
+ 
+ 	request->parser = bmsg_parser_new();
+ 	request->buf = g_string_new("");
+ 	request->name = name;
+ 
+ 	*err = 0;
+ }
+ 
+ static void message_get(struct mas_session *mas, const char *name, int *err)
+ {
+ 	struct get_message_request *request;
+ 	uint8_t value;
+ 
+ 	DBG("");
+ 
+ 	request = g_new0(struct get_message_request, 1);
+ 	mas->request = request;
+ 	mas->request_free = g_free;
+ 
+ 	if (map_ap_get_u8(mas->inparams, MAP_AP_FRACTIONREQUEST, &value)) {
+ 		request->flags |= MESSAGES_FRACTION;
+ 
+ 		if (value & 0x01)
+ 			request->flags |= MESSAGES_NEXT;
+ 	}
+ 
+ 	value = 0;
+ 	map_ap_get_u8(mas->inparams, MAP_AP_CHARSET, &value);
+ 	if (value & 0x01)
+ 		request->flags |= MESSAGES_UTF8;
+ 
+ 	*err = messages_get_message(mas->backend_data, name, request->flags,
+ 			get_message_cb, mas);
+ }
+ 
  static void *message_open(const char *name, int oflag, mode_t mode,
  				void *driver_data, size_t *size, int *err)
  {
***************
*** 598,616 ****
  
  	DBG("");
  
! 	if (oflag != O_RDONLY) {
! 		DBG("Message pushing unsupported");
! 		*err = -ENOSYS;
  
  		return NULL;
  	}
  
! 	*err = messages_get_message(mas->backend_data, name, 0,
! 			get_message_cb, mas);
  
! 	mas->buffer = g_string_new("");
  
! 	if (*err < 0)
  		return NULL;
  	else
  		return mas;
--- 1129,1402 ----
  
  	DBG("");
  
! 	if (oflag == O_RDONLY)
! 		message_get(mas, name, err);
! 	else
! 		message_put(mas, name, err);
  
+ 	if (*err < 0)
  		return NULL;
+ 	else
+ 		return mas;
+ }
+ 
+ static ssize_t message_write_body(struct mas_session *mas, const void *buf,
+ 								size_t count)
+ {
+ 	struct message_put_request *request = mas->request;
+ 	size_t n;
+ 	ssize_t ret;
+ 
+ 	if (request->remaining == 0) {
+ 		g_string_append_len(request->buf, buf, count);
+ 		return count;
  	}
  
! 	if (request->remaining > count)
! 		n = count;
! 	else
! 		n = request->remaining;
  
! 	ret = messages_push_message_body(mas->backend_data, buf, n);
! 
! 	if (ret < 0)
! 		return ret;
! 
! 	request->remaining -= ret;
! 
! 	return ret;
! }
! 
! static ssize_t message_write_header(struct mas_session *mas, const void *buf,
! 								size_t count)
! {
! 	struct message_put_request *request = mas->request;
! 	char *pos;
! 	int ret;
! 	ssize_t size;
! 
! 	DBG("");
! 
! 	g_string_append_len(request->buf, buf, count);
! 	pos = request->buf->str;
! 
! 	ret = bmsg_parser_process(request->parser, &pos, count);
! 
! 	if (ret < 0)
! 		return ret;
! 
! 	size = pos - request->buf->str;
! 	g_string_erase(request->buf, 0, size);
! 
! 	if (ret > 0)
! 		return count;
! 
! 	DBG("Parsing done");
! 
! 	request->bmsg = bmsg_parser_get_bmsg(request->parser);
! 
! 	bmsg_parser_free(request->parser);
! 	request->parser = NULL;
! 
! 	request->parsed = TRUE;
! 	request->remaining = request->bmsg->length;
! 
! 	g_string_set_size(request->buf, 0);
! 
! 	ret = messages_push_message(mas->backend_data, request->bmsg,
! 			request->name, MESSAGES_UTF8, push_message_cb, mas);
! 
! 	if (ret < 0)
! 		return ret;
! 
! 	return size;
! }
! 
! static ssize_t message_write(void *object, const void *buf, size_t count)
! {
! 	struct mas_session *mas = object;
! 	struct message_put_request *request = mas->request;
! 
! 	if (request->parsed)
! 		return message_write_body(mas, buf, count);
! 	else
! 		return message_write_header(mas, buf, count);
! }
! 
! static int message_flush(void *obj)
! {
! 	struct mas_session *mas = obj;
! 	struct message_put_request *request = mas->request;
! 	char *tail;
! 	size_t len;
! 	int ret;
! 
! 	if (mas->finished)
! 		return 0;
! 
! 	if (request->bmsg == NULL) {
! 		DBG("Flushing and no bmsg - this should not happened.");
! 		return -EIO;
! 	}
! 
! 	len = bmsg_parser_tail_length(request->bmsg);
! 
! 	if (request->buf->len < len) {
! 		DBG("Not enough bytes received!");
! 		return -EBADR;
! 	}
! 
! 	tail = request->buf->str + request->buf->len - len;
! 
! 	if (!bmsg_parser_tail_correct(request->bmsg, tail, len)) {
! 		DBG("BMSG tail check failed!");
! 		DBG("!!! Falling back to hopelessly broken PTS strategy !!!");
! 		g_string_append(request->buf, "\r\n");
! 		tail += 2;
! 
! 		if (!bmsg_parser_tail_correct(request->bmsg, tail, len)) {
! 			DBG("This doesn't help either!");
! 			return -EBADR;
! 		}
! 	}
! 
! 	if (request->buf->len > len) {
! 		ret = messages_push_message_body(mas->backend_data,
! 						request->buf->str,
! 						request->buf->len - len);
! 
! 		if (ret < 0)
! 			return ret;
! 	}
! 
! 	ret = messages_push_message_body(mas->backend_data, NULL, 0);
! 
! 	if (ret < 0)
! 		return ret;
! 
! 	return -EAGAIN;
! }
! 
! static void *notification_registration_open(const char *name, int oflag,
! 		mode_t mode, void *driver_data, size_t *size, int *err)
! {
! 	struct mas_session *mas = driver_data;
! 	struct notification_registration_request *nr;
! 	uint8_t status;
! 
! 	if (!(oflag & O_WRONLY)) {
! 		DBG("Tried GET on a PUT-only type");
! 		*err = -EBADR;
! 
! 		return NULL;
! 	}
! 
! 	if (map_ap_get_u8(mas->inparams, MAP_AP_NOTIFICATIONSTATUS, &status) == FALSE) {
! 		DBG("Missing status parameter");
! 		*err = -EBADR;
! 
! 		return NULL;
! 	}
! 
! 	DBG("status: %d", status);
! 
! 	if (status > 1) {
! 		DBG("Status parameter carrying incorrect value");
! 		*err = -EBADR;
! 
! 		return NULL;
! 	}
! 
! 	nr = g_new0(struct notification_registration_request, 1);
! 	nr->status = status;
! 	mas->request = nr;
! 
! 	/*
! 	 * MNS connection operations take place in
! 	 * notification_registration_close() - PTS requires that MAS responds to
! 	 * SetNotificationReqistration first before changing state of MNS.
! 	 */
! 	*err = 0;
! 	mas->finished = TRUE;
! 
! 	return mas;
! }
! 
! static int notification_registration_close(void *obj)
! {
! 	struct mas_session *mas = obj;
! 	struct notification_registration_request *nr = mas->request;
! 
! 	DBG("");
! 
! 	set_notification_registration(mas, nr->status);
! 
! 	if (nr->status) {
! 		messages_set_notification_registration(mas->backend_data,
! 				my_messages_event_cb,
! 				mas);
! 	} else {
! 		messages_set_notification_registration(mas->backend_data,
! 				NULL,
! 				NULL);
! 	}
! 
! 	g_free(nr);
! 	mas->request = NULL;
! 
! 	return 0;
! }
! 
! static void message_status_cb(void *session, int err, void *user_data)
! {
! 	struct mas_session *mas = user_data;
! 
! 	DBG("");
! 
! 	if (err == -EAGAIN)
! 		return;
! 
! 	mas->finished = TRUE;
! 
! 	if (err < 0)
! 		obex_object_set_io_flags(mas, G_IO_ERR, err);
! 	else
! 		obex_object_set_io_flags(mas, G_IO_OUT, 0);
! }
! 
! static void *message_status_open(const char *name, int oflag, mode_t mode,
! 				void *driver_data, size_t *size, int *err)
! {
! 	struct mas_session *mas = driver_data;
! 	uint8_t indicator;
! 	uint8_t value;
! 
! 	if (!(oflag & O_WRONLY)) {
! 		DBG("Tried GET on a PUT-only type");
! 		*err = -EBADR;
  
! 		return NULL;
! 	}
! 
! 	if (map_ap_get_u8(mas->inparams, MAP_AP_STATUSINDICATOR, &indicator) == FALSE) {
! 		DBG("Missing status indicator parameter");
! 		*err = -EBADR;
! 
! 		return NULL;
! 	}
! 
! 	if (map_ap_get_u8(mas->inparams, MAP_AP_STATUSVALUE, &value) == FALSE) {
! 		DBG("Missing status value parameter");
! 		*err = -EBADR;
! 
! 		return NULL;
! 	}
! 
! 	DBG("indicator: %d, value: %d", indicator, value);
! 	*err = messages_set_message_status(mas->backend_data, name, indicator,
! 						value, message_status_cb, mas);
! 
! 	if (*err)
  		return NULL;
  	else
  		return mas;
***************
*** 624,635 ****
  
  	DBG("");
  
! 	if (oflag != O_WRONLY) {
  		*err = -EBADR;
  		return NULL;
  	}
  
  	*err = messages_update_inbox(mas->backend_data, update_inbox_cb, mas);
  	if (*err < 0)
  		return NULL;
  	else
--- 1410,1422 ----
  
  	DBG("");
  
! 	if (oflag == O_RDONLY) {
  		*err = -EBADR;
  		return NULL;
  	}
  
  	*err = messages_update_inbox(mas->backend_data, update_inbox_cb, mas);
+ 
  	if (*err < 0)
  		return NULL;
  	else
***************
*** 642,653 ****
--- 1429,1458 ----
  	struct mas_session *mas = object;
  	size_t len;
  	uint8_t *apbuf;
+ 	char *part;
  
  	DBG("");
  
  	if (mas->buffer->len == 0 && !mas->finished)
  		return -EAGAIN;
  
+ 	if (mas->request_free == message_put_free && mas->request != NULL) {
+ 		struct message_put_request *request = mas->request;
+ 	    
+ 		if (request->handle != NULL && !request->hnd_sent) {
+ 			*hi = G_OBEX_HDR_NAME;
+ 
+ 			DBG("G_OBEX_HDR_NAME to send");
+ 
+ 			request->hnd_sent = TRUE;
+ 			len = request->handle_len;
+ 			apbuf = (uint8_t *) request->handle;
+ 			part = "name";
+ 		
+ 			goto send;
+ 		}
+ 	}
+ 
  	*hi = G_OBEX_HDR_APPARAM;
  
  	if (mas->ap_sent)
***************
*** 655,669 ****
  
  	mas->ap_sent = TRUE;
  	apbuf = map_ap_encode(mas->outparams, &len);
  
  	if (len > mtu) {
! 		DBG("MTU is to small to fit application parameters header!");
  		g_free(apbuf);
  
  		return -EIO;
  	}
  
  	memcpy(buf, apbuf, len);
  
  	return len;
  }
--- 1460,1477 ----
  
  	mas->ap_sent = TRUE;
  	apbuf = map_ap_encode(mas->outparams, &len);
+ 	part = "application parameters";
  
+ send:
  	if (len > mtu) {
! 		DBG("MTU is to small to fit %s header!", part);
  		g_free(apbuf);
  
  		return -EIO;
  	}
  
  	memcpy(buf, apbuf, len);
+ 	g_free(apbuf);
  
  	return len;
  }
***************
*** 709,716 ****
  	if (!mas->finished)
  		messages_abort(mas->backend_data);
  
- 	reset_request(mas);
- 
  	return 0;
  }
  
--- 1517,1522 ----
***************
*** 727,732 ****
--- 1533,1539 ----
  	.put = mas_put,
  	.setpath = mas_setpath,
  	.disconnect = mas_disconnect,
+ 	.reset = mas_reset,
  };
  
  static struct obex_mime_type_driver mime_map = {
***************
*** 743,752 ****
  	.target = MAS_TARGET,
  	.target_size = TARGET_SIZE,
  	.mimetype = "x-bt/message",
  	.open = message_open,
  	.close = any_close,
  	.read = any_read,
! 	.write = any_write,
  };
  
  static struct obex_mime_type_driver mime_folder_listing = {
--- 1550,1561 ----
  	.target = MAS_TARGET,
  	.target_size = TARGET_SIZE,
  	.mimetype = "x-bt/message",
+ 	.get_next_header = any_get_next_header,
  	.open = message_open,
  	.close = any_close,
  	.read = any_read,
! 	.write = message_write,
! 	.flush = message_flush,
  };
  
  static struct obex_mime_type_driver mime_folder_listing = {
***************
*** 764,769 ****
--- 1573,1579 ----
  	.target = MAS_TARGET,
  	.target_size = TARGET_SIZE,
  	.mimetype = "x-bt/MAP-msg-listing",
+ 	.get_next_header = any_get_next_header,
  	.open = msg_listing_open,
  	.close = any_close,
  	.read = any_read,
***************
*** 774,781 ****
  	.target = MAS_TARGET,
  	.target_size = TARGET_SIZE,
  	.mimetype = "x-bt/MAP-NotificationRegistration",
! 	.open = any_open,
! 	.close = any_close,
  	.read = any_read,
  	.write = any_write,
  };
--- 1584,1591 ----
  	.target = MAS_TARGET,
  	.target_size = TARGET_SIZE,
  	.mimetype = "x-bt/MAP-NotificationRegistration",
! 	.open = notification_registration_open,
! 	.close = notification_registration_close,
  	.read = any_read,
  	.write = any_write,
  };
***************
*** 784,790 ****
  	.target = MAS_TARGET,
  	.target_size = TARGET_SIZE,
  	.mimetype = "x-bt/messageStatus",
! 	.open = any_open,
  	.close = any_close,
  	.read = any_read,
  	.write = any_write,
--- 1594,1600 ----
  	.target = MAS_TARGET,
  	.target_size = TARGET_SIZE,
  	.mimetype = "x-bt/messageStatus",
! 	.open = message_status_open,
  	.close = any_close,
  	.read = any_read,
  	.write = any_write,
***************
*** 845,850 ****
--- 1655,1663 ----
  {
  	int i;
  
+ 	/* XXX: Is mas_disconnect() guaranteed before mas_exit()? */
+ 	/* XXX: Shall I keep waiting here for closing MNS connections? */
+ 
  	obex_service_driver_unregister(&mas);
  
  	for (i = 0; map_drivers[i] != NULL; ++i)
diff -crN plugins/messages-dummy.c plugins/messages-dummy.c
*** plugins/messages-dummy.c	Tue Oct  2 04:23:38 2012
--- plugins/messages-dummy.c	Tue Oct  2 05:04:08 2012
***************
*** 42,47 ****
--- 42,49 ----
  	char *cwd;
  	char *cwd_absolute;
  	void *request;
+ 	messages_event_cb cb;
+ 	void *ev_data;
  };
  
  struct folder_listing_data {
***************
*** 252,263 ****
  	g_free(session);
  }
  
! int messages_set_notification_registration(void *session,
  		void (*send_event)(void *session,
  			const struct messages_event *event, void *user_data),
  		void *user_data)
  {
! 	return -ENOSYS;
  }
  
  int messages_set_folder(void *s, const char *name, gboolean cdup)
--- 254,289 ----
  	g_free(session);
  }
  
! static gboolean trigger(gpointer data)
! {
! 	struct session *session = data;
! 	struct messages_event ev = { 0, };
! 
! 	DBG("Triggeeerrrring");
! 	ev.type = MET_NEW_MESSAGE;
! 	ev.handle = "012345";
! 	ev.folder = "";
! 	ev.old_folder = "";
! 	ev.msg_type = "";
! 
! 	if (session->cb)
! 		session->cb(session, &ev, session->ev_data);
! 
! 	return FALSE;
! }
! 
! int messages_set_notification_registration(void *s,
  		void (*send_event)(void *session,
  			const struct messages_event *event, void *user_data),
  		void *user_data)
  {
! 	struct session *session = s;
! 	session->cb = send_event;
! 	session->ev_data = user_data;
! 
! 	g_timeout_add(1000*20, trigger, session);
! 
! 	return -EINVAL;
  }
  
  int messages_set_folder(void *s, const char *name, gboolean cdup)
***************
*** 321,326 ****
--- 347,353 ----
  	fld->offset = offset;
  	fld->callback = callback;
  	fld->user_data = user_data;
+ 	session->request = fld;
  
  	session->request = fld;
  
***************
*** 347,352 ****
--- 374,399 ----
  	return -ENOSYS;
  }
  
+ int messages_set_message_status(void *session, const char *handle, uint8_t indicator,
+ 			uint8_t value, messages_set_message_status_cb callback,
+ 			void *user_data)
+ {
+ 	return -EINVAL;
+ }
+ 
+ int messages_push_message(void *session, struct bmsg_bmsg *bmsg,
+ 					const char *name, unsigned long flags,
+ 					messages_push_message_cb cb, void *user_data)
+ {
+ 	return -EINVAL;
+ }
+ 
+ int messages_push_message_body(void *session, const char *body, size_t len)
+ {
+ 	return -EINVAL;
+ }
+ 
+ 
  int messages_update_inbox(void *session, messages_update_inbox_cb callback,
  							void *user_data)
  {
***************
*** 358,364 ****
  	struct session *session = s;
  
  	if (session->request) {
! 		g_idle_remove_by_data(session->request);
  		session->request = NULL;
  	}
  }
--- 405,411 ----
  	struct session *session = s;
  
  	if (session->request) {
! 		g_free(session->request);
  		session->request = NULL;
  	}
  }
diff -crN plugins/messages-rtcom.c plugins/messages-rtcom.c
*** plugins/messages-rtcom.c	Wed Dec 31 19:00:00 1969
--- plugins/messages-rtcom.c	Tue Oct  2 05:02:12 2012
***************
*** 0 ****
--- 1,1933 ----
+ /*
+  *
+  *  OBEX Server
+  *
+  *  Copyright (C) 2010-2011  Nokia Corporation
+  *
+  *
+  *  This program is free software; you can redistribute it and/or modify
+  *  it under the terms of the GNU General Public License as published by
+  *  the Free Software Foundation; either version 2 of the License, or
+  *  (at your option) any later version.
+  *
+  *  This program is distributed in the hope that it will be useful,
+  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  *  GNU General Public License for more details.
+  *
+  *  You should have received a copy of the GNU General Public License
+  *  along with this program; if not, write to the Free Software
+  *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+  *
+  */
+ 
+ #ifdef HAVE_CONFIG_H
+ #include <config.h>
+ #endif
+ 
+ #include <errno.h>
+ #include <glib.h>
+ #include <stdlib.h>
+ #include <string.h>
+ 
+ #include "log.h"
+ #include "messages.h"
+ #include "bmsg.h"
+ #include "bmsg_parser.h"
+ 
+ #include <rtcom-eventlogger/eventlogger-async.h>
+ 
+ /* 16 chars and terminating \0 */
+ #define HANDLE_LEN (16 + 1)
+ 
+ #define QUERY_RESPONSE_SIZE 21
+ #define MESSAGE_HANDLE_SIZE 16
+ #define MESSAGE_HANDLE_PREFIX_LEN 8
+ 
+ #define SMS_DEFAULT_CHARSET "UTF-8"
+ 
+ #define STATUS_NOT_SET 0xFF
+ 
+ #define RTCOM_MSG_INTS "event-type-id,id,start-time,end-time,storage-time,is-read,bytes-sent,bytes-received,outgoing"
+ #define RTCOM_MSG_INTS_COUNT		9
+ #define RTCOM_MSG_TYPE			0
+ #define RTCOM_MSG_ID			1
+ #define RTCOM_MSG_START_TIME		2
+ #define RTCOM_MSG_END			3
+ #define RTCOM_MSG_STORAGE_TIME		4
+ #define RTCOM_MSG_IS_READ		5
+ #define RTCOM_MSG_BYTES_SENT		6
+ #define RTCOM_MSG_BYTES_RECEIVED	7
+ #define RTCOM_MSG_OUTGOING		8
+ 
+ #define RTCOM_MSG_STRS "remote-ebook-uid,remote-uid,remote-name,free-text"
+ #define RTCOM_MSG_STRS_COUNT		4
+ #define RTCOM_MSG_REMOTE_EBOOK_UID	0
+ #define RTCOM_MSG_REMOTE_UID		1
+ #define RTCOM_MSG_REMOTE_NAME		2
+ #define RTCOM_MSG_TEXT			3
+ 
+ #define LIST_MESSAGES_QUERY	"service-id;3;0" 			\
+ 				";local-uid;\"ring/tel/ring\";0"	\
+ 				";event-type-id;11;0"			\
+ 				"%s"
+ 
+ enum event_direction {
+ 	DIRECTION_UNKNOWN,
+ 	DIRECTION_INBOUND,
+ 	DIRECTION_OUTBOUND
+ };
+ 
+ struct message_folder {
+ 	char *name;
+ 	GSList *subfolders;
+ 	char *query;
+ };
+ 
+ #if 0
+ /*
+  * TODO: PUSH messages
+  */
+ struct push_message_request {
+ 	GString *body;
+ 	messages_push_message_cb cb;
+ 	struct bmsg_bmsg *bmsg;
+ 	void *user_data;
+ 	char *uuid;
+ 	char *name;
+ 	guint watch;
+ 	gboolean retry;
+ 	DBusPendingCall *send_sms, *get_handle;
+ 	void *insert_message_call;
+ };
+ #endif
+ 
+ struct request {
+ 	char *name;
+ 	uint16_t max;
+ 	uint16_t offset;
+ 	uint16_t size;
+ 	void *user_data;
+ 	gboolean count;
+ 	gboolean new_message;
+ 	struct messages_filter *filter;
+ 	unsigned long flags;
+ 	gboolean deleted;
+ 	void *set_status_call;
+ 	union {
+ 		messages_folder_listing_cb folder_list;
+ 		messages_get_messages_listing_cb messages_list;
+ 		messages_get_message_cb message;
+ 		messages_set_message_status_cb status;
+ 	} cb;
+ };
+ 
+ struct message_status {
+ 	uint8_t read;
+ 	uint8_t deleted;
+ };
+ 
+ struct session {
+ 	char *cwd;
+ 	struct message_folder *folder;
+ 	gboolean aborted;
+ 	void *user_data;
+ 	messages_event_cb event_cb;
+ 	struct request *request;
+ 	GHashTable *msg_stat;
+ 	GDestroyNotify abort_request;
+ 	void *request_data;
+ 	gboolean destroy;
+ #if 0
+ /*
+  * TODO: PUSH messages
+  */
+ 	gboolean push_in_progress;
+ #endif
+ 	GSList *mns_event_cache;
+ };
+ 
+ static struct message_folder *folder_tree = NULL;
+ #if 0
+ /*
+  * TODO: inform about new messages
+  */
+ static DBusConnection *session_connection = NULL;
+ #endif
+ #if 0
+ /*
+  * TODO: PUSH messages
+  */
+ static unsigned long message_id_tracker_id;
+ #endif
+ #if 0
+ /*
+  * TODO: inform about new messages
+  */
+ static GSList *mns_srv;
+ static gint newmsg_watch_id, delmsg_watch_id;
+ #endif
+ 
+ static void free_msg_data(struct messages_message *msg)
+ {
+ 	g_free(msg->handle);
+ 	g_free(msg->subject);
+ 	g_free(msg->datetime);
+ 	g_free(msg->sender_name);
+ 	g_free(msg->sender_addressing);
+ 	g_free(msg->replyto_addressing);
+ 	g_free(msg->recipient_name);
+ 	g_free(msg->recipient_addressing);
+ 	g_free(msg->type);
+ 	g_free(msg->reception_status);
+ 	g_free(msg->size);
+ 	g_free(msg->attachment_size);
+ 
+ 	g_free(msg);
+ }
+ 
+ #if 0
+ /*
+  * TODO: PUSH messages
+  */
+ static void free_event_data(struct messages_event *event)
+ {
+ 	g_free(event->handle);
+ 	g_free(event->folder);
+ 	g_free(event->old_folder);
+ 	g_free(event->msg_type);
+ 
+ 	g_free(event);
+ }
+ #endif
+ 
+ static struct messages_filter *copy_messages_filter(
+ 					const struct messages_filter *orig)
+ {
+ 	struct messages_filter *filter = g_new0(struct messages_filter, 1);
+ 
+ 	filter->parameter_mask = orig->parameter_mask;
+ 	filter->type = orig->type;
+ 	filter->period_begin = g_strdup(orig->period_begin);
+ 	filter->period_end = g_strdup(orig->period_end);
+ 	filter->read_status = orig->read_status;
+ 	filter->recipient = g_strdup(orig->recipient);
+ 	filter->originator = g_strdup(orig->originator);
+ 	filter->priority = orig->priority;
+ 
+ 	return filter;
+ }
+ 
+ static void messages_filter_free(struct messages_filter *filter)
+ {
+ 	if (filter == NULL)
+ 		return;
+ 
+ 	if (filter->period_begin)
+ 		g_free((char *) filter->period_begin);
+ 	if (filter->period_end)
+ 		g_free((char *) filter->period_end);
+ 	if (filter->originator)
+ 		g_free((char *) filter->originator);
+ 	if (filter->recipient)
+ 		g_free((char *) filter->recipient);
+ 
+ 	g_free(filter);
+ }
+ 
+ static gboolean validate_handle(const char *h)
+ {
+ 	while(*h && *h >= '0' && *h <= '9')
+ 		h++;
+ 
+ 	return *h == '\0' ? TRUE : FALSE;
+ }
+ 
+ static char *fill_handle(const char *handle)
+ {
+ 	int fill_size;
+ 	char *fill, *ret;
+ 
+ 	if (handle == NULL)
+ 		return NULL;
+ 
+ 	fill_size = MESSAGE_HANDLE_SIZE - strlen(handle);
+ 	fill = g_strnfill(fill_size, '0');
+ 	ret = g_strdup_printf("%s%s", fill, handle);
+ 
+ 	g_free(fill);
+ 
+ 	return ret;
+ }
+ 
+ static char *strip_handle(const char *handle)
+ {
+ 	const char *ptr_new = handle;
+ 
+ 	while (*ptr_new++ == '0') ;
+ 
+ 	return g_strdup(ptr_new - 1);
+ }
+ 
+ static char *folder2query(const struct message_folder *folder,
+ 							const char *query)
+ {
+ 	return g_strdup_printf(query, folder->query, "");
+ }
+ 
+ static struct message_folder *get_folder(const char *folder)
+ {
+ 	GSList *folders = folder_tree->subfolders;
+ 	struct message_folder *last = NULL;
+ 	char **path;
+ 	int i;
+ 
+ 	if (g_strcmp0(folder, "/") == 0)
+ 		return folder_tree;
+ 
+ 	path = g_strsplit(folder, "/", 0);
+ 
+ 	for (i = 1; path[i] != NULL; i++) {
+ 		gboolean match_found = FALSE;
+ 		GSList *l;
+ 
+ 		for (l = folders; l != NULL; l = g_slist_next(l)) {
+ 			struct message_folder *folder = l->data;
+ 
+ 			if (g_strcmp0(folder->name, path[i]) == 0) {
+ 				match_found = TRUE;
+ 				last = l->data;
+ 				folders = folder->subfolders;
+ 				break;
+ 			}
+ 		}
+ 
+ 		if (!match_found) {
+ 			g_strfreev(path);
+ 			return NULL;
+ 		}
+ 	}
+ 
+ 	g_strfreev(path);
+ 
+ 	return last;
+ }
+ 
+ static struct message_folder *create_folder(const char *name, const char *query)
+ {
+ 	struct message_folder *folder = g_new0(struct message_folder, 1);
+ 
+ 	folder->name = g_strdup(name);
+ 	folder->query = g_strdup(query);
+ 
+ 	return folder;
+ }
+ 
+ static void destroy_folder_tree(void *root)
+ {
+ 	struct message_folder *folder = root;
+ 	GSList *tmp, *next;
+ 
+ 	if (folder == NULL)
+ 		return;
+ 
+ 	g_free(folder->name);
+ 	g_free(folder->query);
+ 
+ 	tmp = folder->subfolders;
+ 	while (tmp != NULL) {
+ 		next = g_slist_next(tmp);
+ 		destroy_folder_tree(tmp->data);
+ 		tmp = next;
+ 	}
+ 
+ 	g_slist_free(folder->subfolders);
+ 	g_free(folder);
+ }
+ 
+ static void create_folder_tree(void)
+ {
+ 	struct message_folder *parent, *child;
+ 
+ 	/*
+ 	 * TODO: What does tracker " FILTER (!BOUND(?msg)) " means?
+ 	 * DONE: It should return no message
+ 	 */
+ 	folder_tree = create_folder("/", ";service-id;0;0");
+ 
+ 	parent = create_folder("telecom", ";service-id;0;0");
+ 	folder_tree->subfolders = g_slist_append(folder_tree->subfolders,
+ 								parent);
+ 
+ 	child = create_folder("msg", ";service-id;0;0");
+ 	parent->subfolders = g_slist_append(parent->subfolders, child);
+ 
+ 	parent = child;
+ 
+ 	child = create_folder("inbox", ";outgoing;0;0");
+ 	parent->subfolders = g_slist_append(parent->subfolders, child);
+ 
+ 	child = create_folder("sent", ";outgoing;1;0");
+ 	parent->subfolders = g_slist_append(parent->subfolders, child);
+ 
+ 	child = create_folder("outbox", ";outgoing;1;0"			\
+ 				";service-id;0;0");
+ 	parent->subfolders = g_slist_append(parent->subfolders, child);
+ 
+ #if 0
+ 	/*
+ 	 * TODO: I don't think rtcom store deleted SMS
+ 	 */
+ 	child = create_folder("deleted", "?msg nmo:isDeleted \"true\" . ");
+ 	parent->subfolders = g_slist_append(parent->subfolders, child);
+ #endif
+ }
+ 
+ static char *message2folder(const struct messages_message *data)
+ {
+ 	if (data->sent == TRUE)
+ 		return g_strdup("telecom/msg/sent");
+ 
+ 	if (data->sent == FALSE)
+ 		return g_strdup("telecom/msg/inbox");
+ 
+ 	return NULL;
+ }
+ 
+ static gboolean filter_message(struct messages_message *message,
+ 						struct messages_filter *filter)
+ {
+ 	if (filter == NULL)
+ 		return TRUE;
+ 
+ 	if (filter->type != 0) {
+ 		if (g_strcmp0(message->type, "SMS_GSM") == 0 &&
+ 				(filter->type & 0x01))
+ 			return FALSE;
+ 
+ 		if (g_strcmp0(message->type, "SMS_CDMA") == 0 &&
+ 				(filter->type & 0x02))
+ 			return FALSE;
+ 
+ 		if (g_strcmp0(message->type, "SMS_EMAIL") == 0 &&
+ 				(filter->type & 0x04))
+ 			return FALSE;
+ 
+ 		if (g_strcmp0(message->type, "SMS_MMS") == 0 &&
+ 				(filter->type & 0x08))
+ 			return FALSE;
+ 	}
+ 
+ 	if (filter->read_status != 0) {
+ 		if (filter->read_status == 0x01 && message->read != FALSE)
+ 			return FALSE;
+ 
+ 		if (filter->read_status == 0x02 && message->read != TRUE)
+ 			return FALSE;
+ 	}
+ 
+ 	if (filter->priority != 0) {
+ 		if (filter->priority == 0x01 && message->priority == FALSE)
+ 			return FALSE;
+ 
+ 		if (filter->priority == 0x02 && message->priority == TRUE)
+ 			return FALSE;
+ 	}
+ 
+ 	if (filter->period_begin != NULL &&
+ 			g_strcmp0(filter->period_begin, message->datetime) > 0)
+ 		return FALSE;
+ 
+ 	if (filter->period_end != NULL &&
+ 			g_strcmp0(filter->period_end, message->datetime) < 0)
+ 		return FALSE;
+ 
+ 	if (filter->originator != NULL) {
+ 		char *orig = g_strdup_printf("*%s*", filter->originator);
+ 
+ 		if (g_pattern_match_simple(orig,
+ 					message->sender_addressing != NULL ?
+ 					message->sender_addressing : "") == FALSE &&
+ 				g_pattern_match_simple(orig,
+ 					message->sender_name != NULL ?
+ 					message->sender_name : "") == FALSE) {
+ 			g_free(orig);
+ 			return FALSE;
+ 		}
+ 
+ 		g_free(orig);
+ 	}
+ 
+ 	if (filter->recipient != NULL) {
+ 		char *recip = g_strdup_printf("*%s*", filter->recipient);
+ 
+ 		if (g_pattern_match_simple(recip,
+ 					message->recipient_addressing != NULL ?
+ 					message->recipient_addressing : "") ==
+ 					FALSE &&
+ 				g_pattern_match_simple(recip,
+ 					message->recipient_name != NULL ?
+ 					message->recipient_name : "") == FALSE) {
+ 			g_free(recip);
+ 			return FALSE;
+ 		}
+ 
+ 		g_free(recip);
+ 	}
+ 
+ 	return TRUE;
+ }
+ 
+ static struct phonebook_contact *pull_message_contact(
+ 			struct messages_message *msg_data,
+ 			GArray *intvals, char **strvals)
+ {
+ 	struct phonebook_contact *contact;
+ 	struct phonebook_field *number;
+ 
+ 	contact = g_new0(struct phonebook_contact, 1);
+ 
+ 	contact->fullname = g_strdup(strvals[RTCOM_MSG_REMOTE_NAME]);
+ 	contact->given = NULL;
+ 	contact->family = g_strdup(strvals[RTCOM_MSG_REMOTE_NAME]);
+ 	contact->additional = NULL;
+ 	contact->prefix = NULL;
+ 	contact->suffix = NULL;
+ 
+ 	number = g_new0(struct phonebook_field, 1);
+ 	number->text = g_strdup(strvals[RTCOM_MSG_REMOTE_UID]);
+ 	number->type = TEL_TYPE_NONE;
+ 	contact->numbers = g_slist_append(contact->numbers, number);
+ 
+ 	return contact;
+ }
+ 
+ static char *format_tstamp(const time_t datetime)
+ {
+ 	const struct tm *tm = localtime(&datetime);
+ 	gchar *local_time = g_new0(char, 16); /* format: "YYYYMMDDTHHMMSS\0" */
+ 			                        
+ 	if (tm == NULL || strftime(local_time, 16, "%Y%m%dT%H%M%S", tm) <= 0) {
+ 		g_free(local_time);
+ 
+ 		return NULL;
+ 	}
+ 
+ 	return local_time;
+ }
+ 
+ static struct messages_message *pull_message_data(GArray *intvals,
+ 							char **strvals)
+ {
+ 	time_t datetime;
+ 	struct messages_message *data;
+ 
+ 	if (intvals == NULL || intvals->len != RTCOM_MSG_INTS_COUNT ||
+ 	    strvals == NULL || g_strv_length(strvals) != RTCOM_MSG_STRS_COUNT)
+ 		return NULL;
+ 
+ 	data = g_new0(struct messages_message, 1);
+ 
+ 	data->handle = g_strdup_printf("%d",
+ 			g_array_index(intvals, gint, RTCOM_MSG_ID));
+ 		
+ 	data->subject = g_strdup(strvals[RTCOM_MSG_TEXT]);
+ 
+ 	data->mask |= PMASK_SUBJECT;
+ 
+ 	datetime = g_array_index(intvals, time_t, RTCOM_MSG_START_TIME);
+ 
+ 	if (datetime > 0)
+ 		data->datetime = format_tstamp(datetime);
+ 
+ 	if (data->datetime == NULL) {
+ 		datetime = g_array_index(intvals, time_t, RTCOM_MSG_STORAGE_TIME);
+ 
+ 		if (datetime > 0)
+ 			data->datetime = format_tstamp(datetime);
+ 	}
+ 
+ 	if (data->datetime == NULL)
+ 		data->datetime = g_strdup("");
+ 
+ 	data->mask |= PMASK_DATETIME;
+ 
+ 	data->sent = g_array_index(intvals, int, RTCOM_MSG_OUTGOING) == 0 ? FALSE : TRUE;
+ 	data->mask |= PMASK_SENT;
+ 
+ 	if (!data->sent) {
+ 		data->sender_name = g_strdup(strvals[RTCOM_MSG_REMOTE_NAME]);
+ 
+ 		if (data->sender_name[0] != '\0')
+ 			data->mask |= PMASK_SENDER_NAME;
+ 
+ 		data->sender_addressing = 
+ 				g_strdup(strvals[RTCOM_MSG_REMOTE_UID]);
+ 		data->mask |= PMASK_SENDER_ADDRESSING;
+ 
+ 		data->recipient_addressing = g_strdup("");
+ 	} else {
+ 		data->recipient_name = g_strdup(strvals[RTCOM_MSG_REMOTE_NAME]);
+ 
+ 		if (data->recipient_name[0] != '\0')
+ 			data->mask |= PMASK_RECIPIENT_NAME;
+ 
+ 		data->recipient_addressing =
+ 				g_strdup(strvals[RTCOM_MSG_REMOTE_UID]);
+ 	}
+ 	data->mask |= PMASK_RECIPIENT_ADDRESSING;
+ 
+ 	data->type = g_strdup("SMS_GSM");
+ 	data->mask |= PMASK_TYPE;
+ 
+ 	data->size = g_strdup_printf("%d", strlen(strvals[RTCOM_MSG_TEXT]));
+ 	data->mask |= PMASK_SIZE;
+ 
+ 	data->text = TRUE;
+ 	data->mask |= PMASK_TEXT;
+ 
+ 	data->reception_status = g_strdup("complete");
+ 	data->mask |= PMASK_RECEPTION_STATUS;
+ 
+ 	data->attachment_size = g_strdup("0");
+ 	data->mask |= PMASK_ATTACHMENT_SIZE;
+ 
+ 	data->priority = FALSE;
+ 	data->mask |= PMASK_PRIORITY;
+ 
+ 	data->read = g_array_index(intvals, int, RTCOM_MSG_IS_READ) == 0 ? FALSE : TRUE;
+ 	data->mask |= PMASK_READ;
+ 
+ 	data->protect = FALSE;
+ 	data->mask |= PMASK_PROTECTED;
+ 
+ 	return data;
+ }
+ 
+ static void get_messages_listing_cb(GPtrArray *inttable, GPtrArray *strtable,
+ 					GError *gerr, gpointer user_data)
+ {
+ 	struct session *session = user_data;
+ 	struct request *request = session->request;
+ 	struct messages_message *msg_data;
+ 	struct message_status *stat;
+ 	guint index;
+ 
+ 	DBG("");
+ 
+ 	if (session->aborted)
+ 		goto aborted;
+ 
+ 	if (gerr != NULL) {
+ 		error("RTCOM query failed: %s", gerr->message);
+ 		goto end;
+ 	}
+ 	if (inttable == NULL || strtable == NULL || inttable->len != strtable->len) {
+ 		error("RTCOM query failed: different count of inttable and strtable records");
+ 		goto end;
+ 	}
+ 
+ 	if (request->size >= request->max)
+ 		goto end;
+ 
+ 	for (index = 0; index < inttable->len; index++) {
+ 		GArray *intvals = (GArray *) g_ptr_array_index(inttable, index);
+ 		char **strvals = (char **) g_ptr_array_index(strtable, index);
+ 
+ 		if ((msg_data = pull_message_data(intvals, strvals)) == NULL)
+ 			continue;
+ 
+ 		stat = g_hash_table_lookup(session->msg_stat, msg_data->handle);
+ 
+ 		if (stat == NULL) {
+ 			if (request->deleted)
+ 				goto fordone;
+ 			stat = g_new0(struct message_status, 1);
+ 			stat->read = msg_data->read;
+ 
+ 			g_hash_table_insert(session->msg_stat,
+ 						g_strdup(msg_data->handle), stat);
+ 
+ 		} else {
+ 			if (stat->read != STATUS_NOT_SET)
+ 				msg_data->read = stat->read;
+ 			if ((request->deleted == TRUE) != (stat->deleted != 0))
+ 				goto fordone;
+ 		}
+ 
+ 		/* It isn't clear whether or not NewMessage header should take into
+ 		 * account full folder contents or only filtered messages */
+ 		if (!msg_data->read)
+ 			request->new_message = TRUE;
+ 
+ 		if (!filter_message(msg_data, request->filter))
+ 			goto fordone;
+ 
+ 		request->size++;
+ 
+ 		if (request->count == TRUE)
+ 			goto fordone;
+ 
+ 		request->cb.messages_list(session, -EAGAIN, 1,
+ 						request->new_message, msg_data,
+ 						request->user_data);
+ 
+ fordone:
+ 		free_msg_data(msg_data);
+ 
+ 		if (request->size >= request->max)
+ 			goto end;
+ 	}
+ 
+ end:
+ 	request->cb.messages_list(session, 0, request->size,
+ 						request->new_message, NULL,
+ 						request->user_data);
+ 
+ aborted:
+ 	messages_filter_free(request->filter);
+ 
+ 	g_free(request->name);
+ 	g_free(request);
+ 	session->request = NULL;
+ 
+ 	if (session->destroy)
+ 		messages_disconnect(session);
+ }
+ 
+ static void get_message_cb(GArray *intvals, char **strvals,
+ 				GError *gerr, gpointer user_data)
+ {
+ 	struct session *session = user_data;
+ 	struct request *request = session->request;
+ 	struct messages_message *msg_data;
+ 	struct bmsg *bmsg;
+ 	char *final_bmsg, *status, *folder, *handle;
+ 	struct phonebook_contact *contact;
+ 	struct message_status *stat;
+ 	gint err = 0;
+ 
+ 	DBG("");
+ 
+ 	if (session->aborted)
+ 		goto aborted;
+ 
+ 	if (gerr != NULL) {
+ 		if (g_strcmp0(gerr->message, "Unable to prepare iteration")) {
+ 			error("RTCOM query failed: %s", gerr->message);
+ 			err = -EINVAL;
+ 		}
+ 
+ 		goto end;
+ 	}
+ 
+ 	if ((msg_data = pull_message_data(intvals, strvals)) == NULL) {
+ 		error("RTCOM query failed: wrong count of intvals or strvals records");
+ 		err = -EINVAL;
+ 
+ 		goto end;
+ 	}
+ 
+ 	handle = fill_handle(msg_data->handle);
+ 	g_free(msg_data->handle);
+ 	msg_data->handle = handle;
+ 
+ 	contact = pull_message_contact(msg_data, intvals, strvals);
+ 
+ 	stat = g_hash_table_lookup(session->msg_stat, msg_data->handle);
+ 
+ 	if (stat != NULL && stat->read != STATUS_NOT_SET)
+ 		msg_data->read = stat->read;
+ 
+ 	status = msg_data->read ? "READ" : "UNREAD";
+ 
+ 	folder = message2folder(msg_data);
+ 
+ 	bmsg = g_new0(struct bmsg, 1);
+ 	bmsg_init(bmsg, BMSG_VERSION_1_0, status, BMSG_SMS, folder);
+ 
+ 	if (!msg_data->sent)
+ 		bmsg_add_originator(bmsg, contact);
+ 
+ 	bmsg_add_envelope(bmsg);
+ 
+ 	if (msg_data->sent)
+ 		bmsg_add_recipient(bmsg, contact);
+ 
+ 	bmsg_add_content(bmsg, -1, NULL, SMS_DEFAULT_CHARSET, NULL,
+ 						strvals[RTCOM_MSG_TEXT]);
+ 
+ 	final_bmsg = bmsg_text(bmsg);
+ 
+ 	request->cb.message(session, 0, FALSE, final_bmsg, request->user_data);
+ 
+ 	bmsg_destroy(bmsg);
+ 	g_free(folder);
+ 	g_free(final_bmsg);
+ 	free_msg_data(msg_data);
+ 	phonebook_contact_free(contact);
+ 
+ 	request->count++;
+ 
+ end:
+ 	if (request->count == 0 && err == 0)
+ 		err = -ENOENT;
+ 
+ 	request->cb.message(session, err, FALSE, NULL, request->user_data);
+ 
+ 	return;
+ 
+ aborted:
+ 	g_free(request->name);
+ 	g_free(request);
+ 	session->request = NULL;
+ 
+ 	if (session->destroy)
+ 		messages_disconnect(session);
+ }
+ 
+ #if 0
+ /*
+  * TODO: inform about new messages
+  */
+ static void session_dispatch_event(struct session *session,
+ 						struct messages_event *event)
+ {
+ 	if (session->push_in_progress) {
+ 		struct messages_event *data;
+ 
+ 		data = g_new0(struct messages_event, 1);
+ 		data->type = event->type;
+ 		data->msg_type = g_strdup(event->msg_type);
+ 		data->old_folder = g_strdup(event->old_folder);
+ 		data->handle = g_strdup(event->handle);
+ 		data->folder = g_strdup(event->folder);
+ 
+ 		session->mns_event_cache = g_slist_append(
+ 						session->mns_event_cache,
+ 						data);
+ 
+ 		DBG("Event cached");
+ 	} else {
+ 		session->event_cb(session, event, session->event_user_data);
+ 
+ 		DBG("Event dispatched");
+ 	}
+ }
+ 
+ static void notify_new_sms(const char *handle, enum messages_event_type type,
+ 						enum event_direction direction)
+ {
+ 	struct messages_event *data;
+ 	GSList *next;
+ 
+ 	DBG("");
+ 
+ 	data = g_new0(struct messages_event, 1);
+ 	data->type = type;
+ 	data->msg_type = g_strdup("SMS_GSM");
+ 	data->old_folder = g_strdup("");
+ 	data->handle = fill_handle(handle);
+ 
+ 	switch (direction) {
+ 		case DIRECTION_INBOUND:
+ 			data->folder = g_strdup("telecom/msg/inbox");
+ 			break;
+ 		case DIRECTION_OUTBOUND:
+ 			data->folder = g_strdup("telecom/msg/sent");
+ 			break;
+ 		default:
+ 			data->folder = g_strdup("");
+ 			break;
+ 	}
+ 
+ 	for (next = mns_srv; next != NULL; next = g_slist_next(next)) {
+ 		struct session *session = next->data;
+ 
+ 		session_dispatch_event(session, data);
+ 	}
+ }
+ #endif
+ 
+ #if 0
+ /*
+  * TODO: PUSH messages
+  */
+ static void notify_cached_events(struct session *session, const char *h)
+ {
+ 	GSList *event;
+ 	char *handle = fill_handle(h);
+ 
+ 	DBG("");
+ 
+ 	for (event = session->mns_event_cache; event != NULL;
+ 						event = g_slist_next(event)) {
+ 		struct messages_event *data = event->data;
+ 
+ 		if (handle != NULL && g_strcmp0(handle, data->handle) == 0) {
+ 			free_event_data(data);
+ 
+ 			continue;
+ 		}
+ 
+ 		if (g_slist_find(mns_srv, session) != NULL)
+ 			session->event_cb(session, data,
+ 						session->event_user_data);
+ 	}
+ 
+ 	g_slist_free(session->mns_event_cache);
+ 	session->mns_event_cache = NULL;
+ 	g_free(handle);
+ }
+ #endif
+ 
+ #if 0
+ /*
+  * TODO: inform about new messages
+  */
+ static gboolean handle_new_sms(DBusConnection * connection, DBusMessage * msg,
+ 							void *user_data)
+ {
+ 	DBusMessageIter arg, inner_arg, struct_arg;
+ 	unsigned ihandle = 0;
+ 	int32_t direction;
+ 	char *handle;
+ 
+ 	DBG("");
+ 
+ 	if (!dbus_message_iter_init(msg, &arg))
+ 		return TRUE;
+ 
+ 	if (dbus_message_iter_get_arg_type(&arg) != DBUS_TYPE_ARRAY)
+ 		return TRUE;
+ 
+ 	dbus_message_iter_recurse(&arg, &inner_arg);
+ 
+ 	if (dbus_message_iter_get_arg_type(&inner_arg) != DBUS_TYPE_STRUCT)
+ 		return TRUE;
+ 
+ 	dbus_message_iter_recurse(&inner_arg, &struct_arg);
+ 
+ 	if (dbus_message_iter_get_arg_type(&struct_arg) != DBUS_TYPE_INT32)
+ 		return TRUE;
+ 
+ 	dbus_message_iter_get_basic(&struct_arg, &ihandle);
+ 
+ 	handle = g_strdup_printf("%d", ihandle);
+ 
+ 	dbus_message_iter_next(&struct_arg); /* Type */
+ 	dbus_message_iter_next(&struct_arg); /* StartTime */
+ 	dbus_message_iter_next(&struct_arg); /* EndTime */
+ 	dbus_message_iter_next(&struct_arg); /* Direction */
+ 
+ 	if (dbus_message_iter_get_arg_type(&struct_arg) != DBUS_TYPE_INT32)
+ 		return TRUE;
+ 
+ 	dbus_message_iter_get_basic(&struct_arg, &direction);
+ 
+ 	DBG("new message: %s", handle);
+ 
+ 	notify_new_sms(handle, MET_NEW_MESSAGE, direction);
+ 
+ 	g_free(handle);
+ 
+ 	return TRUE;
+ }
+ 
+ static gboolean handle_del_sms(DBusConnection * connection, DBusMessage * msg,
+ 							void *user_data)
+ {
+ 	DBusMessageIter arg;
+ 	unsigned ihandle = 0;
+ 	char *handle;
+ 
+ 	DBG("");
+ 
+ 	if (!dbus_message_iter_init(msg, &arg))
+ 		return TRUE;
+ 
+ 	if (dbus_message_iter_get_arg_type(&arg) != DBUS_TYPE_INT32)
+ 		return TRUE;
+ 
+ 	dbus_message_iter_get_basic(&arg, &ihandle);
+ 
+ 	handle = g_strdup_printf("%d", ihandle);
+ 
+ 	DBG("message deleted: %s", handle);
+ 
+ 	notify_new_sms(handle, MET_MESSAGE_DELETED, DIRECTION_UNKNOWN);
+ 
+ 	g_free(handle);
+ 
+ 	return TRUE;
+ }
+ #endif
+ 
+ int messages_init(void)
+ {
+ #if 0
+ /*
+  * TODO: inform about new messages
+  */
+ 	session_connection = dbus_bus_get(DBUS_BUS_SESSION, NULL);
+ 
+ 	if (session_connection == NULL) {
+ 		error("Unable to connect to the session bus.");
+ 
+ 		return -1;
+ 	}
+ #endif
+ 
+ 	create_folder_tree();
+ 
+ 	return 0;
+ }
+ 
+ void messages_exit(void)
+ {
+ 	destroy_folder_tree(folder_tree);
+ 
+ #if 0
+ /*
+  * TODO: inform about new messages
+  */
+ 	dbus_connection_unref(session_connection);
+ 
+ 	messages_qt_exit();
+ #endif
+ }
+ 
+ int messages_connect(void **sess)
+ {
+ 	struct session *session = g_new0(struct session, 1);
+ 
+ 	session->cwd = g_strdup("/");
+ 	session->folder = folder_tree;
+ 
+ 	session->msg_stat = g_hash_table_new_full(g_str_hash, g_str_equal,
+ 							g_free, g_free);
+ 
+ 	*sess = session;
+ 
+ 	return 0;
+ }
+ 
+ void messages_disconnect(void *sess)
+ {
+ 	struct session *session = sess;
+ 
+ 	messages_set_notification_registration(session, NULL, NULL);
+ 
+ 	if (session->request != NULL) {
+ 		session->destroy = TRUE;
+ 
+ 		return;
+ 	}
+ 
+ 	g_hash_table_destroy(session->msg_stat);
+ 	g_free(session->cwd);
+ 	g_free(session);
+ }
+ 
+ int messages_set_notification_registration(void *sess,
+ 						messages_event_cb callback,
+ 						void *user_data)
+ {
+ #if 0
+ 	struct session *session = sess;
+ 
+ 	/*
+ 	 * TODO: inform about new messages
+ 	 */
+ 	if (callback != NULL) {
+ 		if (g_slist_find(mns_srv, session) != NULL)
+ 			return 0;
+ 
+ 		if (g_slist_length(mns_srv) == 0) {
+ 			newmsg_watch_id = g_dbus_add_signal_watch(
+ 							session_connection,
+ 							NULL, NULL,
+ 							"com.nokia.commhistory",
+ 							"eventsAdded",
+ 							handle_new_sms,
+ 							NULL, NULL);
+ 			delmsg_watch_id = g_dbus_add_signal_watch(
+ 							session_connection,
+ 							NULL, NULL,
+ 							"com.nokia.commhistory",
+ 							"eventDeleted",
+ 							handle_del_sms,
+ 							NULL, NULL);
+ 		}
+ 
+ 		if (newmsg_watch_id == 0 || delmsg_watch_id == 0)
+ 			return -EIO;
+ 
+ 		session->event_user_data = user_data;
+ 		session->event_cb = callback;
+ 
+ 		mns_srv = g_slist_prepend(mns_srv, session);
+ 	} else {
+ 		mns_srv = g_slist_remove(mns_srv, session);
+ 
+ 		if (g_slist_length(mns_srv) == 0) {
+ 			g_dbus_remove_watch(session_connection,
+ 							newmsg_watch_id);
+ 			g_dbus_remove_watch(session_connection,
+ 							delmsg_watch_id);
+ 		}
+ 	}
+ #endif
+ 
+ 	return 0;
+ }
+ 
+ int messages_set_folder(void *sess, const char *name, gboolean cdup)
+ {
+ 	struct session *session = sess;
+ 	char *newrel = NULL;
+ 	char *newabs;
+ 	char *tmp;
+ 
+ 	if (name && (strchr(name, '/') || strcmp(name, "..") == 0))
+ 		return -EBADR;
+ 
+ 	if (cdup) {
+ 		if (session->cwd[0] == 0)
+ 			return -ENOENT;
+ 
+ 		newrel = g_path_get_dirname(session->cwd);
+ 
+ 		/* We use empty string for indication of the root directory */
+ 		if (newrel[0] == '.' && newrel[1] == 0)
+ 			newrel[0] = 0;
+ 	}
+ 
+ 	tmp = newrel;
+ 	if (!cdup && (!name || name[0] == 0))
+ 		newrel = g_strdup("");
+ 	else
+ 		newrel = g_build_filename(newrel ? newrel : session->cwd, name,
+ 									NULL);
+ 	g_free(tmp);
+ 
+ 	if (newrel[0] != '/')
+ 		newabs = g_build_filename("/", newrel, NULL);
+ 	else
+ 		newabs = g_strdup(newrel);
+ 
+ 	session->folder = get_folder(newabs);
+ 	if (session->folder == NULL) {
+ 		g_free(newrel);
+ 		g_free(newabs);
+ 
+ 		return -ENOENT;
+ 	}
+ 
+ 	g_free(newrel);
+ 	g_free(session->cwd);
+ 	session->cwd = newabs;
+ 
+ 	return 0;
+ }
+ 
+ static gboolean async_get_folder_listing(void *sess)
+ {
+ 	struct session *session = sess;
+ 	struct request *request = session->request;
+ 	gboolean count = FALSE;
+ 	int folder_count = 0;
+ 	char *path = NULL;
+ 	struct message_folder *folder;
+ 	GSList *dir;
+ 
+ 	if (session->aborted)
+ 		goto aborted;
+ 
+ 	if (request->name && strchr(request->name, '/') != NULL)
+ 		goto done;
+ 
+ 	path = g_build_filename(session->cwd, request->name, NULL);
+ 
+ 	if (path == NULL || strlen(path) == 0)
+ 		goto done;
+ 
+ 	folder = get_folder(path);
+ 
+ 	if (folder == NULL)
+ 		goto done;
+ 
+ 	if (request->max == 0) {
+ 		request->max = 0xffff;
+ 		request->offset = 0;
+ 		count = TRUE;
+ 	}
+ 
+ 	for (dir = folder->subfolders; dir &&
+ 				(folder_count - request->offset) < request->max;
+ 				folder_count++, dir = g_slist_next(dir)) {
+ 		struct message_folder *dir_data = dir->data;
+ 
+ 		if (count == FALSE && request->offset <= folder_count)
+ 			request->cb.folder_list(session, -EAGAIN, 0,
+ 					dir_data->name, request->user_data);
+ 	}
+ 
+  done:
+ 	request->cb.folder_list(session, 0, folder_count, NULL,
+ 							request->user_data);
+ 
+ 	g_free(path);
+ 
+ aborted:
+ 	g_free(request->name);
+ 	g_free(request);
+ 	session->request = NULL;
+ 
+ 	if (session->destroy)
+ 		messages_disconnect(session);
+ 
+ 	return FALSE;
+ }
+ 
+ int messages_get_folder_listing(void *sess, const char *name,
+ 					uint16_t max, uint16_t offset,
+ 					messages_folder_listing_cb callback,
+ 					void *user_data)
+ {
+ 	struct session *session = sess;
+ 	struct request *request = g_new0(struct request, 1);
+ 
+ 	request->name = g_strdup(name);
+ 	request->max = max;
+ 	request->offset = offset;
+ 	request->cb.folder_list = callback;
+ 	request->user_data = user_data;
+ 
+ 	session->aborted = FALSE;
+ 	session->request = request;
+ 
+ 	g_idle_add_full(G_PRIORITY_DEFAULT_IDLE, async_get_folder_listing,
+ 						session, NULL);
+ 
+ 	return 0;
+ }
+ 
+ int messages_get_messages_listing(void *sess, const char *name,
+ 				uint16_t max, uint16_t offset,
+ 				const struct messages_filter *filter,
+ 				messages_get_messages_listing_cb callback,
+ 				void *user_data)
+ {
+ 	struct session *session = sess;
+ 	struct request *request;
+ 	char *path, *query;
+ 	struct message_folder *folder = NULL;
+ 	int err = 0;
+ 
+ 	if (name == NULL || strlen(name) == 0) {
+ 		path = g_strdup(session->cwd);
+ 
+ 		folder = session->folder;
+ 		if (folder == NULL)
+ 			folder = get_folder(path);
+ 	} else {
+ 		if (strchr(name, '/') != NULL)
+ 			return -EBADR;
+ 
+ 		path = g_build_filename(session->cwd, name, NULL);
+ 		folder = get_folder(path);
+ 	}
+ 
+ 	g_free(path);
+ 
+ 	if (folder == NULL)
+ 		return -EBADR;
+ 
+ 	query = folder2query(folder, LIST_MESSAGES_QUERY);
+ 	if (query == NULL)
+ 		return -ENOENT;
+ 
+ 	request = g_new0(struct request, 1);
+ 
+ 	request->filter = copy_messages_filter(filter);
+ 	request->cb.messages_list = callback;
+ 	request->offset = offset;
+ 	request->max = max;
+ 	request->user_data = user_data;
+ 	request->deleted = g_strcmp0(folder->name, "deleted") ? FALSE : TRUE;
+ 
+ 	session->aborted = FALSE;
+ 
+ 	if (session->request) {
+ 		messages_filter_free(session->request->filter);
+ 		g_free(session->request->name);
+ 		g_free(session->request);
+ 	}
+ 
+ 	session->request = request;
+ 
+ 	if (max == 0) {
+ 		request->max = 0xffff;
+ 		request->offset = 0;
+ 		request->count = TRUE;
+ 	}
+ 
+ 	if ((err = rtcomel_get_event_list_async(get_messages_listing_cb, query,
+ 				RTCOM_MSG_INTS, RTCOM_MSG_STRS,
+ 				request->offset, request->max, session))) {
+ 		error("Unable to get messages query %s with: %d",
+ 				query, err);
+ 		g_free(query);
+ 
+ 		return -EPERM;
+ 	}
+ 
+ 	g_free(query);
+ 
+ 	return err;
+ }
+ 
+ int messages_get_message(void *sess, const char *handle,
+ 				unsigned long flags,
+ 				messages_get_message_cb callback,
+ 				void *user_data)
+ {
+ 	struct session *session = sess;
+ 	struct request *request;
+ 	int err = 0;
+ 	char *query_handle;
+ 
+ 	if (!validate_handle(handle))
+ 		return -ENOENT;
+ 
+ 	query_handle = strip_handle(handle);
+ 
+ 	if (flags & MESSAGES_FRACTION && flags & MESSAGES_NEXT) {
+ 		err = -EBADR;
+ 
+ 		goto failed;
+ 	}
+ 
+ 	request = g_new0(struct request, 1);
+ 
+ 	request->name = g_strdup(handle);
+ 	request->flags = flags;
+ 	request->cb.message = callback;
+ 	request->user_data = user_data;
+ 
+ 	session->aborted = FALSE;
+ 
+ 	if (session->request) {
+ 		messages_filter_free(session->request->filter);
+ 		g_free(session->request->name);
+ 		g_free(session->request);
+ 	}
+ 
+ 	session->request = request;
+ 
+ 	if ((err = rtcomel_get_event_async(get_message_cb, atoi(query_handle), 
+ 					RTCOM_MSG_INTS, RTCOM_MSG_STRS,
+ 					session))) {
+ 		error("Unable to get call history id %s with: %d",
+ 							query_handle, err);
+ 		g_free(query_handle);
+ 
+ 		return -EPERM;
+ 	}
+ 
+ 
+ failed:
+ 	g_free(query_handle);
+ 
+ 	return err;
+ }
+ 
+ #if 0
+ /*
+  * TODO: update message status to read or delete the message
+  */
+ static void messages_qt_callback(int err, void *user_data)
+ {
+ 	struct session *session = user_data;
+ 	struct request *request = session->request;
+ 
+ 	if (!session->aborted && request->cb.status)
+ 		request->cb.status(session, err, request->user_data);
+ 
+ 	g_free(request);
+ 	session->request = NULL;
+ }
+ #endif
+ 
+ int messages_set_message_status(void *sess, const char *handle, uint8_t indicator,
+ 			uint8_t value, messages_set_message_status_cb callback,
+ 			void *user_data)
+ {
+ #if 0
+ /*
+  * TODO: update message status to read or delete the message
+  */
+ 	struct session *session = sess;
+ 	struct message_status *stat = NULL;
+ 	int ret;
+ 	struct request *request;
+ 
+ 	stat = g_hash_table_lookup(session->msg_stat, handle);
+ 	if (stat == NULL) {
+ 		stat = g_new0(struct message_status, 1);
+ 		stat->read = STATUS_NOT_SET;
+ 
+ 		g_hash_table_insert(session->msg_stat, g_strdup(handle), stat);
+ 	}
+ 
+ 	request = g_new0(struct request, 1);
+ 	request->cb.status = callback;
+ 	request->user_data = user_data;
+ 	session->request = request;
+ 
+ 	switch (indicator) {
+ 		case 0x0:
+ 			ret = messages_qt_set_read(&request->set_status_call,
+ 						handle, value & 0x01,
+ 						messages_qt_callback, session);
+ 			if (ret < 0)
+ 				return ret;
+ 
+ 			stat->read = value;
+ 			break;
+ 		case 0x1:
+ 			ret = messages_qt_set_deleted(&request->set_status_call,
+ 						handle, value & 0x01,
+ 						messages_qt_callback, session);
+ 			if (ret < 0)
+ 				return ret;
+ 
+ 			stat->deleted = value;
+ 			break;
+ 		default:
+ 			g_free(request);
+ 			session->request = NULL;
+ 			return -EBADR;
+ 	}
+ 
+ 	return 0;
+ #else
+ 	return -ENOSYS;
+ #endif
+ }
+ 
+ #if 0
+ /*
+  * TODO: PUSH messages
+  */
+ static void push_message_abort(gpointer sess)
+ {
+ 	struct session *session = sess;
+ 	struct push_message_request *request = session->request_data;
+ 
+ 	DBG("");
+ 
+ 	if (request == NULL)
+ 		return;
+ 
+ 	if (request->send_sms != NULL) {
+ 		dbus_pending_call_cancel(request->send_sms);
+ 		dbus_pending_call_unref(request->send_sms);
+ 	}
+ 
+ 	if (request->get_handle != NULL) {
+ 		DBG("Cancelled get_handle");
+ 		dbus_pending_call_cancel(request->get_handle);
+ 		dbus_pending_call_unref(request->get_handle);
+ 	}
+ 
+ 	if (request->insert_message_call != NULL)
+ 		messages_qt_insert_message_abort(request->insert_message_call);
+ 
+ 	g_dbus_remove_watch(session_connection, request->watch);
+ 
+ 	if (request->body)
+ 		g_string_free(request->body, TRUE);
+ 
+ 	if (request->name)
+ 		g_free(request->name);
+ 
+ 	g_free(request->uuid);
+ 	g_free(request);
+ 
+ 	session->push_in_progress = FALSE;
+ 	notify_cached_events(session, NULL);
+ }
+ 
+ static void push_message_finalize(struct session *session)
+ {
+ 	DBG("");
+ 
+ 	push_message_abort(session);
+ 	session->request_data = NULL;
+ 	session->abort_request = NULL;
+ }
+ 
+ static void send_sms_finalize(struct session *session, const char *uri)
+ {
+ 	struct push_message_request *request = session->request_data;
+ 	char handle[HANDLE_LEN];
+ 	unsigned long uri_no;
+ 
+ 	if (sscanf(uri, "message:%lu", &uri_no) != 1)
+ 		request->cb(session, -EIO, NULL, request->user_data);
+ 	else {
+ 		snprintf(handle, HANDLE_LEN, "%016lu", uri_no);
+ 		request->cb(session, 0, handle, request->user_data);
+ 	}
+ 
+ 	notify_cached_events(session, handle);
+ 	push_message_finalize(session);
+ }
+ 
+ static int get_uri_by_uuid(void *sess, const char *id);
+ 
+ static void get_uri_by_uuid_pc(DBusPendingCall *pc, void *user_data)
+ {
+ 	struct session *session = user_data;
+ 	struct push_message_request *request = session->request_data;
+ 	DBusMessage *reply;
+ 	DBusError error;
+ 	DBusMessageIter iargs, irows, icols;
+ 	char *uri;
+ 
+ 	reply = dbus_pending_call_steal_reply(pc);
+ 	dbus_error_init(&error);
+ 
+ 	if (dbus_set_error_from_message(&error, reply)) {
+ 		DBG("%s: %s", error.name, error.message);
+ 		dbus_error_free(&error);
+ 
+ 		goto cont;
+ 	}
+ 
+ 	if (!dbus_message_has_signature(reply, "aas")) {
+ 		DBG("Unexpected signature: %s",
+ 					dbus_message_get_signature(reply));
+ 
+ 		goto cont;
+ 	}
+ 
+ 	dbus_message_iter_init(reply, &iargs);
+ 	dbus_message_iter_recurse(&iargs, &irows);
+ 
+ 	if (dbus_message_iter_get_arg_type(&irows) != DBUS_TYPE_ARRAY) {
+ 		DBG("Message not yet in Tracker");
+ 		goto cont;
+ 	}
+ 
+ 	dbus_message_iter_recurse(&irows, &icols);
+ 	dbus_message_iter_get_basic(&icols, &uri);
+ 	DBG("URI: %s", uri);
+ 	dbus_message_unref(reply);
+ 	send_sms_finalize(session, uri);
+ 
+ 	return;
+ 
+ cont:
+ 	dbus_message_unref(reply);
+ 	dbus_pending_call_unref(request->get_handle);
+ 	request->get_handle = NULL;
+ 
+ 	if (request->retry) {
+ 		request->retry = FALSE;
+ 		get_uri_by_uuid(session, request->uuid);
+ 	}
+ }
+ 
+ static int get_uri_by_uuid(void *sess, const char *id)
+ {
+ 	struct session *session = sess;
+ 	struct push_message_request *request = session->request_data;
+ 	DBusMessage *msg;
+ 	DBusPendingCall *pc;
+ 	char *query;
+ 
+ 	if (request->get_handle != NULL) {
+ 		request->retry = TRUE;
+ 		return 0;
+ 	}
+ 
+ 	msg = dbus_message_new_method_call(TRACKER_SERVICE,
+ 						TRACKER_RESOURCES_PATH,
+ 						TRACKER_RESOURCES_INTERFACE,
+ 						"SparqlQuery");
+ 	if (msg == NULL)
+ 		goto failed;
+ 
+ 	query = g_strdup_printf(HANDLE_BY_UUID_QUERY, id);
+ 	if (!dbus_message_append_args(msg, DBUS_TYPE_STRING, &query,
+ 							DBUS_TYPE_INVALID)) {
+ 		g_free(query);
+ 		goto failed;
+ 	}
+ 	g_free(query);
+ 
+ 	if (!dbus_connection_send_with_reply(session_connection, msg, &pc, -1))
+ 		goto failed;
+ 
+ 	if (!dbus_pending_call_set_notify(pc, get_uri_by_uuid_pc, session,
+ 									NULL)) {
+ 		dbus_pending_call_cancel(pc);
+ 		goto failed;
+ 	}
+ 
+ 	dbus_message_unref(msg);
+ 	request->get_handle = pc;
+ 
+ 	return 0;
+ 
+ failed:
+ 	if (pc != NULL)
+ 		dbus_pending_call_unref(pc);
+ 
+ 	if (msg != NULL)
+ 		dbus_message_unref(msg);
+ 
+ 	push_message_finalize(session);
+ 
+ 	return -ENOMEM;
+ }
+ 
+ static gboolean send_sms_graph_updated(DBusConnection *connection,
+ 					DBusMessage *msg, void *user_data)
+ {
+ 	struct session *session = user_data;
+ 	struct push_message_request *request = session->request_data;
+ 	DBusMessageIter iargs, irows, icols;
+ 	char *class;
+ 	dbus_uint32_t predicate;
+ 
+ 	dbus_message_iter_init(msg, &iargs);
+ 	if (dbus_message_iter_get_arg_type(&iargs) != DBUS_TYPE_STRING)
+ 		return TRUE;
+ 
+ 	dbus_message_iter_get_basic(&iargs, &class);
+ 	if (g_strcmp0("http://www.semanticdesktop.org/ontologies"
+ 					"/2007/03/22/nmo#Message", class) != 0)
+ 		return TRUE;
+ 
+ 	dbus_message_iter_next(&iargs);
+ 	if (dbus_message_iter_get_arg_type(&iargs) != DBUS_TYPE_ARRAY)
+ 		return TRUE;
+ 
+ 	dbus_message_iter_recurse(&iargs, &irows);
+ 
+ 	while (dbus_message_iter_get_arg_type(&irows) == DBUS_TYPE_STRUCT) {
+ 		dbus_message_iter_recurse(&irows, &icols);
+ 		dbus_message_iter_next(&icols);
+ 		dbus_message_iter_next(&icols);
+ 		dbus_message_iter_get_basic(&icols, &predicate);
+ 		if (predicate == message_id_tracker_id) {
+ 			DBG("Predicate hit!");
+ 			get_uri_by_uuid(session, request->uuid);
+ 		}
+ 		dbus_message_iter_next(&irows);
+ 	}
+ 
+ 	return TRUE;
+ }
+ 
+ static void send_sms_messaging_pc(DBusPendingCall *pc, void *user_data)
+ {
+ 	struct session *session = user_data;
+ 	struct push_message_request *request = session->request_data;
+ 	DBusMessage *reply;
+ 	DBusError error;
+ 	char *uuid;
+ 	int err;
+ 
+ 	DBG("");
+ 
+ 	reply = dbus_pending_call_steal_reply(pc);
+ 	dbus_error_init(&error);
+ 
+ 	if (dbus_set_error_from_message(&error, reply)) {
+ 		DBG("%s: %s", error.name, error.message);
+ 		dbus_error_free(&error);
+ 		err = -EIO;
+ 
+ 		goto failed;
+ 	}
+ 
+ 	if (!dbus_message_has_signature(reply, DBUS_TYPE_STRING_AS_STRING)) {
+ 		DBG("Unexpected signature: %s",
+ 					dbus_message_get_signature(reply));
+ 		err = -EIO;
+ 
+ 		goto failed;
+ 	}
+ 
+ 	dbus_message_get_args(reply, NULL, DBUS_TYPE_STRING, &uuid,
+ 							DBUS_TYPE_INVALID);
+ 	if (uuid[0] == '\0') {
+ 		DBG("Empty response from SendSMS, possibly wrong phone number");
+ 		err = -EBADR;
+ 
+ 		goto failed;
+ 	}
+ 
+ 
+ 	DBG("Message UUID: %s", uuid);
+ 	request->uuid = g_strdup(uuid);
+ 
+ 	request->watch = g_dbus_add_signal_watch(session_connection,
+ 					NULL, NULL,
+ 					"org.freedesktop.Tracker1.Resources",
+ 					"GraphUpdated",
+ 					send_sms_graph_updated,
+ 					session, NULL);
+ 	get_uri_by_uuid(session, uuid);
+ 
+ 	dbus_message_unref(reply);
+ 	dbus_pending_call_unref(request->send_sms);
+ 	request->send_sms = NULL;
+ 
+ 	return;
+ 
+ failed:
+ 	request->cb(session, err, NULL, request->user_data);
+ 	push_message_finalize(session);
+ 	dbus_message_unref(reply);
+ }
+ 
+ static int send_sms(struct session *session, const char *recipient,
+ 					const char *body, gboolean store)
+ {
+ 	struct push_message_request *request = session->request_data;
+ 	DBusMessage *msg = NULL;
+ 	DBusPendingCall *pc = NULL;
+ 
+ 	msg = dbus_message_new_method_call("com.nokia.Messaging", "/",
+ 					"com.nokia.MessagingIf", "sendSMS");
+ 	if (msg == NULL)
+ 		goto failed;
+ 
+ 	if (!dbus_message_append_args(msg, DBUS_TYPE_STRING, &recipient,
+ 						DBUS_TYPE_STRING, &body,
+ 						DBUS_TYPE_BOOLEAN, &store,
+ 						DBUS_TYPE_INVALID))
+ 		goto failed;
+ 
+ 	if (!dbus_connection_send_with_reply(session_connection, msg,
+ 							&pc, -1))
+ 		goto failed;
+ 
+ 	if (!dbus_pending_call_set_notify(pc, send_sms_messaging_pc,
+ 							session, NULL)) {
+ 		/* XXX: Now, that's kind of a problem */
+ 		dbus_pending_call_cancel(pc);
+ 		goto failed;
+ 	}
+ 
+ 	dbus_message_unref(msg);
+ 	request->send_sms = pc;
+ 
+ 	return 0;
+ 
+ failed:
+ 	if (pc != NULL)
+ 		dbus_pending_call_unref(pc);
+ 	if (msg != NULL)
+ 		dbus_message_unref(msg);
+ 
+ 	return -ENOMEM;
+ }
+ 
+ static void insert_message_cb(int id, void *sess)
+ {
+ 	struct session *session = sess;
+ 	struct push_message_request *request = session->request_data;
+ 	char handle[HANDLE_LEN];
+ 
+ 	DBG("");
+ 
+ 	if (id < 0) {
+ 		request->cb(session, id, NULL, request->user_data);
+ 		goto finalize;
+ 	}
+ 
+ 	request->insert_message_call = NULL;
+ 
+ 	snprintf(handle, HANDLE_LEN, "%016d", id);
+ 	request->cb(session, 0, handle, request->user_data);
+ 
+ 	notify_cached_events(session, handle);
+ 
+ finalize:
+ 	push_message_finalize(session);
+ }
+ 
+ static int store_sms(struct session *session, const char *recipient,
+ 					const char *body)
+ {
+ 	struct push_message_request *request = session->request_data;
+ 
+ 	DBG("");
+ 
+ 	return messages_qt_insert_message(&request->insert_message_call,
+ 						recipient, body, request->name,
+ 						insert_message_cb, session);
+ }
+ #endif
+ 
+ int messages_push_message(void *sess, struct bmsg_bmsg *bmsg, const char *name,
+ 						unsigned long flags,
+ 						messages_push_message_cb cb,
+ 						void *user_data)
+ {
+ #if 0
+ /*
+  * TODO: PUSH messages
+  */
+ 	struct session *session = sess;
+ 	struct push_message_request *request;
+ 
+ 	session->push_in_progress = TRUE;
+ 
+ 	if ((flags & MESSAGES_UTF8) != MESSAGES_UTF8) {
+ 		DBG("Tried to push non-utf message");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if ((flags & MESSAGES_TRANSPARENT) == MESSAGES_TRANSPARENT)
+ 		DBG("Warning! Transparent flag is ignored");
+ 
+ 	if ((flags & MESSAGES_RETRY) != MESSAGES_RETRY)
+ 		DBG("Warning! Retry flag is ignored.");
+ 
+ 	if (bmsg->type != BMSG_T_SMS_GSM ||
+ 					bmsg->charset != BMSG_C_UTF8 ||
+ 					bmsg->part_id != -1 ||
+ 					bmsg->nenvelopes < 1) {
+ 		DBG("Incorrect BMSG format!");
+ 		return -EBADR;
+ 	}
+ 
+ 	request = g_new0(struct push_message_request, 1);
+ 	session->request_data = request;
+ 	session->abort_request = push_message_abort;
+ 
+ 	request->bmsg = bmsg;
+ 	request->cb = cb;
+ 	request->body = g_string_new("");
+ 	request->user_data = user_data;
+ 
+ 	request->name = g_build_filename(session->cwd, name, NULL);
+ 	DBG("Push destination: %s", request->name);
+ 
+ 	return 0;
+ #else
+ 	return -ENOSYS;
+ #endif
+ }
+ 
+ #if 0
+ /*
+  * TODO: PUSH messages
+  */
+ static int prepare_body(GString *body)
+ {
+ 	if (body->len < MSG_BLOCK_OVERHEAD)
+ 		return -EBADR;
+ 
+ 	if (!g_str_has_prefix(body->str, "BEGIN:MSG\r\n"))
+ 		return -EBADR;
+ 
+ 	if (!g_str_has_prefix(body->str + body->len - 11, "\r\nEND:MSG\r\n"))
+ 		return -EBADR;
+ 
+ 	g_string_erase(body, 0, 11);
+ 	g_string_set_size(body, body->len - 10);
+ 	body->str[body->len - 1] = '\0';
+ 
+ 	return 0;
+ }
+ #endif
+ 
+ int messages_push_message_body(void *sess, const char *body, size_t len)
+ {
+ #if 0
+ /*
+  * TODO: PUSH messages
+  */
+ 	struct session *session = sess;
+ 	struct push_message_request *request = session->request_data;
+ 	struct bmsg_bmsg_vcard *vcard;
+ 	int env, ret;
+ 
+ 	if (len > 0) {
+ 		g_string_append_len(request->body, body, len);
+ 		return len;
+ 	}
+ 
+ 	env = request->bmsg->nenvelopes - 1;
+ 	if (env < 0 || request->bmsg->recipients[env] == NULL)
+ 	{
+ 		ret = -EBADR;
+ 		goto failed;
+ 	}
+ 
+ 	if (request->bmsg->recipients[env]->next != NULL)
+ 	{
+ 		ret = -EINVAL;
+ 		goto failed;
+ 	}
+ 
+ 	vcard = request->bmsg->recipients[request->bmsg->nenvelopes - 1]->data;
+ 	if (vcard->tel == NULL) {
+ 		ret = -EBADR;
+ 		goto failed;
+ 	}
+ 
+ 	ret = prepare_body(request->body);
+ 	if (ret < 0)
+ 		goto failed;
+ 
+ 	if (g_strcmp0(request->name, "/telecom/msg/outbox") == 0)
+ 		ret = send_sms(session, vcard->tel, request->body->str, TRUE);
+ 	else
+ 		ret = store_sms(session, vcard->tel, request->body->str);
+ 
+ 	if (ret < 0)
+ 		goto failed;
+ 
+ 	g_string_free(request->body, TRUE);
+ 	request->body = NULL;
+ 
+ 	return 0;
+ 
+ failed:
+ 	push_message_finalize(session);
+ 
+ 	return ret;
+ #else
+ 	return -ENOSYS;
+ #endif
+ }
+ 
+ int messages_update_inbox(void *sess, messages_update_inbox_cb callback,
+ 							void *user_data)
+ {
+ 	return -ENOSYS;
+ }
+ 
+ void messages_abort(void *sess)
+ {
+ 	struct session *session = sess;
+ 
+ 	DBG("");
+ 
+ 	if (session->abort_request != NULL)
+ 		session->abort_request(session);
+ 
+ 	session->aborted = TRUE;
+ 	session->abort_request = NULL;
+ 	session->request_data = NULL;
+ }
diff -crN plugins/messages-tracker.c plugins/messages-tracker.c
*** plugins/messages-tracker.c	Tue Oct  2 04:11:18 2012
--- plugins/messages-tracker.c	Tue Oct  2 05:02:12 2012
***************
*** 29,35 ****
--- 29,133 ----
  #include <glib.h>
  #include <string.h>
  
+ #include "log.h"
  #include "messages.h"
+ #include "bmsg.h"
+ #include "bmsg_parser.h"
+ #include "messages-qt/messages-qt.h"
+ 
+ /* 16 chars and terminating \0 */
+ #define HANDLE_LEN (16 + 1)
+ 
+ #define TRACKER_SERVICE "org.freedesktop.Tracker1"
+ #define TRACKER_RESOURCES_PATH "/org/freedesktop/Tracker1/Resources"
+ #define TRACKER_RESOURCES_INTERFACE "org.freedesktop.Tracker1.Resources"
+ 
+ #define TRACKER_MESSAGE_TSTAMP_FORMAT "%Y-%m-%dT%T"
+ 
+ #define QUERY_RESPONSE_SIZE 21
+ #define MESSAGE_HANDLE_SIZE 16
+ #define MESSAGE_HANDLE_PREFIX_LEN 8
+ 
+ #define SMS_DEFAULT_CHARSET "UTF-8"
+ 
+ #define STATUS_NOT_SET 0xFF
+ 
+ #define MESSAGES_FILTER_BY_HANDLE "FILTER (xsd:string(?msg) = \"message:%s\" ) ."
+ 
+ #define MESSAGE_HANDLE 0
+ #define MESSAGE_SUBJECT 1
+ #define MESSAGE_SDATE 2
+ #define MESSAGE_RDATE 3
+ #define MESSAGE_CONTACT_FN 4
+ #define MESSAGE_CONTACT_GIVEN 5
+ #define MESSAGE_CONTACT_FAMILY 6
+ #define MESSAGE_CONTACT_ADDITIONAL 7
+ #define MESSAGE_CONTACT_PREFIX 8
+ #define MESSAGE_CONTACT_SUFFIX 9
+ #define MESSAGE_CONTACT_PHONE 10
+ #define MESSAGE_READ 11
+ #define MESSAGE_SENT 12
+ #define MESSAGE_CONTENT 13
+ 
+ #define LIST_MESSAGES_QUERY                                             \
+ 	"SELECT "                                                               \
+ "?msg "                                                                 \
+ "nmo:messageSubject(?msg) "                                             \
+ "nmo:sentDate(?msg) "                                                   \
+ "nmo:receivedDate(?msg) "                                               \
+ "nco:fullname(?cont) "                                                  \
+ "nco:nameGiven(?cont) "                                                 \
+ "nco:nameFamily(?cont) "                                                \
+ "nco:nameAdditional(?cont) "                                            \
+ "nco:nameHonorificPrefix(?cont) "                                       \
+ "nco:nameHonorificSuffix(?cont) "                                       \
+ "nco:phoneNumber(?phone) "                                              \
+ "nmo:isRead(?msg) "                                                     \
+ "nmo:isSent(?msg) "                                                     \
+ "nie:plainTextContent(?msg) "                                           \
+ "WHERE { "                                                              \
+ 	"?msg a nmo:SMSMessage . "                                      \
+ 	"%s "                                                           \
+ 	"%s "                                                           \
+ 	"{ "                                                            \
+ 	"       ?msg nmo:from ?msg_cont .  "                            \
+ 	"       ?msg nmo:isSent false "                                 \
+ 	"} UNION { "                                                    \
+ 	"       ?msg nmo:to ?msg_cont . "                               \
+ 	"       ?msg nmo:isSent true "                                  \
+ 	"} "                                                            \
+ 	"?msg_cont nco:hasPhoneNumber ?phone . "                        \
+ 	"?phone maemo:localPhoneNumber ?lphone . "                      \
+ 	"OPTIONAL { "                                                   \
+ 		"{ SELECT ?cont ?lphone "                               \
+ 			"count(?cont) as ?cnt "                         \
+ 		"WHERE { "                                              \
+ 			"?cont a nco:PersonContact . "                  \
+ 			"{ "                                            \
+ 				"?cont nco:hasAffiliation ?_role . "    \
+ 				"?_role nco:hasPhoneNumber ?_phone . "  \
+ 			"} UNION { "                                    \
+ 				"?cont nco:hasPhoneNumber ?_phone "     \
+ 			"} "                                            \
+ 			"?_phone maemo:localPhoneNumber ?lphone. "      \
+ 		"} GROUP BY ?lphone } "                                 \
+ 		"FILTER(?cnt = 1) "                                     \
+ 	"} "                                                            \
+ "} ORDER BY DESC(nmo:sentDate(?msg)) "
+ 
+ #define HANDLE_BY_UUID_QUERY            \
+ 	"SELECT ?msg { "                        \
+         "?msg a nmo:SMSMessage "        \
+         "; nmo:messageId \"%s\" "       \
+ "}"
+ 
+ typedef void (*reply_list_foreach_cb)(const char **reply, void *user_data);
+ 
+ enum event_direction {
+ 	DIRECTION_UNKNOWN,
+ 	DIRECTION_INBOUND,
+ 	DIRECTION_OUTBOUND
+ };
  
  struct message_folder {
  	char *name;
***************
*** 37,54 ****
--- 135,418 ----
  	char *query;
  };
  
+ struct push_message_request {
+ 	GString *body;
+ 	messages_push_message_cb cb;
+ 	struct bmsg_bmsg *bmsg;
+ 	void *user_data;
+ 	char *uuid;
+ 	char *name;
+ 	guint watch;
+ 	gboolean retry;
+ 	DBusPendingCall *send_sms, *get_handle;
+ 	void *insert_message_call;
+ };
+ 
+ struct request {
+ 	char *name;
+ 	uint16_t max;
+ 	uint16_t offset;
+ 	uint16_t size;
+ 	void *user_data;
+ 	gboolean count;
+ 	gboolean new_message;
+ 	reply_list_foreach_cb generate_response;
+ 	struct messages_filter *filter;
+ 	unsigned long flags;
+ 	gboolean deleted;
+ 	void *set_status_call;
+ 	union {
+ 		messages_folder_listing_cb folder_list;
+ 		messages_get_messages_listing_cb messages_list;
+ 		messages_get_message_cb message;
+ 		messages_set_message_status_cb status;
+ 	} cb;
+ };
+ 
+ struct message_status {
+ 	uint8_t read;
+ 	uint8_t deleted;
+ };
+ 
  struct session {
  	char *cwd;
  	struct message_folder *folder;
+ #if OBEXD_VERSION < 0.46
  	char *name;
  	uint16_t max;
  	uint16_t offset;
+ #else
+ 	gboolean aborted;
+ #endif
  	void *user_data;
+ #if OBEXD_VERSION < 0.46
  	void (*folder_list_cb)(void *session, int err, uint16_t size,
  					const char *name, void *user_data);
+ #else
+ 	messages_event_cb event_cb;
+ 	struct request *request;
+ 	GHashTable *msg_stat;
+ 	GDestroyNotify abort_request;
+ 	void *request_data;
+ 	gboolean destroy;
+ 	gboolean push_in_progress;
+ 	GSList *mns_event_cache;
+ #endif
  };
  
  static struct message_folder *folder_tree = NULL;
+ static DBusConnection *session_connection = NULL;
+ static unsigned long message_id_tracker_id;
+ static GSList *mns_srv;
+ static gint newmsg_watch_id, delmsg_watch_id;
+ 
+ static void free_msg_data(struct messages_message *msg)
+ {
+ 	g_free(msg->handle);
+ 	g_free(msg->subject);
+ 	g_free(msg->datetime);
+ 	g_free(msg->sender_name);
+ 	g_free(msg->sender_addressing);
+ 	g_free(msg->replyto_addressing);
+ 	g_free(msg->recipient_name);
+ 	g_free(msg->recipient_addressing);
+ 	g_free(msg->type);
+ 	g_free(msg->reception_status);
+ 	g_free(msg->size);
+ 	g_free(msg->attachment_size);
+ 
+ 	g_free(msg);
+ }
+ 
+ static void free_event_data(struct messages_event *event)
+ {
+ 	g_free(event->handle);
+ 	g_free(event->folder);
+ 	g_free(event->old_folder);
+ 	g_free(event->msg_type);
+ 
+ 	g_free(event);
+ }
+ 
+ static struct messages_filter *copy_messages_filter(
+ 					const struct messages_filter *orig)
+ {
+ 	struct messages_filter *filter = g_new0(struct messages_filter, 1);
+ 
+ 	filter->parameter_mask = orig->parameter_mask;
+ 	filter->type = orig->type;
+ 	filter->period_begin = g_strdup(orig->period_begin);
+ 	filter->period_end = g_strdup(orig->period_end);
+ 	filter->read_status = orig->read_status;
+ 	filter->recipient = g_strdup(orig->recipient);
+ 	filter->originator = g_strdup(orig->originator);
+ 	filter->priority = orig->priority;
+ 
+ 	return filter;
+ }
+ 
+ static gboolean validate_handle(const char *h)
+ {
+ 	while(*h && *h >= '0' && *h <= '9')
+ 		h++;
+ 
+ 	return *h == '\0' ? TRUE : FALSE;
+ }
+ 
+ static char *fill_handle(const char *handle)
+ {
+ 	int fill_size;
+ 	char *fill, *ret;
+ 
+ 	if (handle == NULL)
+ 		return NULL;
+ 
+ 	fill_size = MESSAGE_HANDLE_SIZE - strlen(handle);
+ 	fill = g_strnfill(fill_size, '0');
+ 	ret = g_strdup_printf("%s%s", fill, handle);
+ 
+ 	g_free(fill);
+ 
+ 	return ret;
+ }
+ 
+ static char *strip_handle(const char *handle)
+ {
+ 	const char *ptr_new = handle;
+ 
+ 	while (*ptr_new++ == '0') ;
+ 
+ 	return g_strdup(ptr_new - 1);
+ }
+ 
+ static char **string_array_from_iter(DBusMessageIter iter, int array_len)
+ {
+ 	DBusMessageIter sub;
+ 	char **result;
+ 	int i;
+ 
+ 	if (dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_ARRAY)
+ 		return NULL;
+ 
+ 	result = g_new0(char *, array_len + 1);
+ 
+ 	dbus_message_iter_recurse(&iter, &sub);
+ 
+ 	i = 0;
+ 	while (dbus_message_iter_get_arg_type(&sub) != DBUS_TYPE_INVALID) {
+ 		char *arg;
+ 
+ 		if (dbus_message_iter_get_arg_type(&sub) != DBUS_TYPE_STRING) {
+ 			g_free(result);
+ 
+ 			return NULL;
+ 		}
+ 
+ 		dbus_message_iter_get_basic(&sub, &arg);
+ 
+ 		result[i++] = arg;
+ 
+ 		dbus_message_iter_next(&sub);
+ 	}
+ 
+ 	return result;
+ }
+ 
+ static void query_reply(DBusPendingCall *call, void *user_data)
+ {
+ 	DBusMessage *reply = dbus_pending_call_steal_reply(call);
+ 	struct session *session = user_data;
+ 	DBusMessageIter iter, element;
+ 	DBusError derr;
+ 
+ 	dbus_error_init(&derr);
+ 	if (dbus_set_error_from_message(&derr, reply)) {
+ 		error("Replied with an error: %s, %s", derr.name, derr.message);
+ 		dbus_error_free(&derr);
+ 
+ 		goto done;
+ 	}
+ 
+ 	dbus_message_iter_init(reply, &iter);
+ 
+ 	if (dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_ARRAY) {
+ 		error("SparqlQuery reply is not an array");
+ 
+ 		goto done;
+ 	}
+ 
+ 	dbus_message_iter_recurse(&iter, &element);
+ 
+ 	while (dbus_message_iter_get_arg_type(&element) != DBUS_TYPE_INVALID) {
+ 		char **node;
+ 
+ 		if (dbus_message_iter_get_arg_type(&element)
+ 							!= DBUS_TYPE_ARRAY) {
+ 			error("Element is not an array\n");
+ 
+ 			goto done;
+ 		}
+ 
+ 		node = string_array_from_iter(element, QUERY_RESPONSE_SIZE);
+ 
+ 		if (node != NULL)
+ 			session->request->generate_response((const char **) node,
+ 								session);
+ 
+ 		g_free(node);
+ 
+ 		dbus_message_iter_next(&element);
+ 	}
+ 
+ done:
+ 	session->request->generate_response(NULL, session);
+ 	dbus_message_unref(reply);
+ 	dbus_pending_call_unref(call);
+ }
+ 
+ static DBusPendingCall *query_tracker(char *query, void *user_data, int *err)
+ {
+ 	DBusPendingCall *call;
+ 	DBusMessage *msg;
+ 
+ 	msg = dbus_message_new_method_call(TRACKER_SERVICE,
+ 						TRACKER_RESOURCES_PATH,
+ 						TRACKER_RESOURCES_INTERFACE,
+ 						"SparqlQuery");
+ 
+ 	if (msg == NULL) {
+ 		if (err)
+ 			*err = -EPERM;
+ 
+ 		return NULL;
+ 	}
+ 
+ 	dbus_message_append_args(msg, DBUS_TYPE_STRING, &query,
+ 							DBUS_TYPE_INVALID);
+ 
+ 	if (dbus_connection_send_with_reply(session_connection, msg, &call,
+ 								-1) == FALSE) {
+ 		error("Could not send dbus message");
+ 		dbus_message_unref(msg);
+ 
+ 		if (err)
+ 			*err = -EPERM;
+ 
+ 		return NULL;
+ 	}
+ 
+ 	dbus_pending_call_set_notify(call, query_reply, user_data, NULL);
+ 
+ 	dbus_message_unref(msg);
+ 
+ 	return call;
+ }
+ 
+ static char *folder2query(const struct message_folder *folder,
+ 							const char *query)
+ {
+ 	return g_strdup_printf(query, folder->query, "");
+ }
  
  static struct message_folder *get_folder(const char *folder)
  {
***************
*** 144,332 ****
  				"nmo:isSent \"true\" . ");
  	parent->subfolders = g_slist_append(parent->subfolders, child);
  
  	child = create_folder("deleted", "?msg nmo:isDeleted \"true\" . ");
  	parent->subfolders = g_slist_append(parent->subfolders, child);
  }
  
! int messages_init(void)
  {
! 	create_folder_tree();
  
! 	return 0;
  }
  
! void messages_exit(void)
  {
! 	destroy_folder_tree(folder_tree);
  }
  
! int messages_connect(void **s)
  {
! 	struct session *session = g_new0(struct session, 1);
! 
! 	session->cwd = g_strdup("/");
! 	session->folder = folder_tree;
  
! 	*s = session;
  
! 	return 0;
  }
  
! void messages_disconnect(void *s)
  {
! 	struct session *session = s;
  
! 	g_free(session->cwd);
! 	g_free(session);
  }
  
! int messages_set_notification_registration(void *session,
! 		void (*send_event)(void *session,
! 			const struct messages_event *event, void *user_data),
! 		void *user_data)
  {
! 	return -ENOSYS;
  }
  
! int messages_set_folder(void *s, const char *name, gboolean cdup)
  {
! 	struct session *session = s;
! 	char *newrel = NULL;
! 	char *newabs;
! 	char *tmp;
! 
! 	if (name && (strchr(name, '/') || strcmp(name, "..") == 0))
! 		return -EBADR;
  
! 	if (cdup) {
! 		if (session->cwd[0] == 0)
! 			return -ENOENT;
  
! 		newrel = g_path_get_dirname(session->cwd);
  
! 		/* We use empty string for indication of the root directory */
! 		if (newrel[0] == '.' && newrel[1] == 0)
! 			newrel[0] = 0;
! 	}
  
! 	tmp = newrel;
! 	if (!cdup && (!name || name[0] == 0))
! 		newrel = g_strdup("");
  	else
! 		newrel = g_build_filename(newrel ? newrel : session->cwd, name,
! 									NULL);
! 	g_free(tmp);
  
! 	if (newrel[0] != '/')
! 		newabs = g_build_filename("/", newrel, NULL);
  	else
! 		newabs = g_strdup(newrel);
  
! 	session->folder = get_folder(newabs);
! 	if (session->folder == NULL) {
! 		g_free(newrel);
! 		g_free(newabs);
  
! 		return -ENOENT;
  	}
  
! 	g_free(newrel);
! 	g_free(session->cwd);
! 	session->cwd = newabs;
  
! 	return 0;
  }
  
! static gboolean async_get_folder_listing(void *s)
  {
! 	struct session *session = s;
! 	gboolean count = FALSE;
! 	int folder_count = 0;
! 	char *path = NULL;
! 	struct message_folder *folder;
! 	GSList *dir;
  
! 	if (session->name && strchr(session->name, '/') != NULL)
! 		goto done;
  
! 	path = g_build_filename(session->cwd, session->name, NULL);
  
! 	if (path == NULL || strlen(path) == 0)
! 		goto done;
  
! 	folder = get_folder(path);
  
! 	if (folder == NULL)
  		goto done;
  
! 	if (session->max == 0) {
! 		session->max = 0xffff;
! 		session->offset = 0;
! 		count = TRUE;
! 	}
  
! 	for (dir = folder->subfolders; dir &&
! 				(folder_count - session->offset) < session->max;
! 				folder_count++, dir = g_slist_next(dir)) {
! 		struct message_folder *dir_data = dir->data;
  
! 		if (count == FALSE && session->offset <= folder_count)
! 			session->folder_list_cb(session, -EAGAIN, 0,
! 					dir_data->name, session->user_data);
! 	}
  
!  done:
! 	session->folder_list_cb(session, 0, folder_count, NULL,
! 							session->user_data);
  
! 	g_free(path);
! 	g_free(session->name);
  
! 	return FALSE;
  }
  
! int messages_get_folder_listing(void *s, const char *name,
! 					uint16_t max, uint16_t offset,
! 					messages_folder_listing_cb callback,
! 					void *user_data)
  {
  	struct session *session = s;
! 	session->name = g_strdup(name);
! 	session->max = max;
! 	session->offset = offset;
! 	session->folder_list_cb = callback;
! 	session->user_data = user_data;
  
! 	g_idle_add_full(G_PRIORITY_DEFAULT_IDLE, async_get_folder_listing,
! 						session, NULL);
  
! 	return 0;
! }
  
! int messages_get_messages_listing(void *session,
! 				const char *name,
! 				uint16_t max, uint16_t offset,
! 				const struct messages_filter *filter,
! 				messages_get_messages_listing_cb callback,
! 				void *user_data)
! {
! 	return -ENOSYS;
! }
  
! int messages_get_message(void *session, const char *handle,
! 				unsigned long flags,
! 				messages_get_message_cb callback,
! 				void *user_data)
! {
! 	return -ENOSYS;
! }
  
! int messages_update_inbox(void *session, messages_update_inbox_cb callback,
! 							void *user_data)
! {
! 	return -ENOSYS;
! }
  
! void messages_abort(void *session)
! {
  }
--- 508,2062 ----
  				"nmo:isSent \"true\" . ");
  	parent->subfolders = g_slist_append(parent->subfolders, child);
  
+ 	child = create_folder("outbox", " FILTER (!BOUND(?msg)) ");
+ 	parent->subfolders = g_slist_append(parent->subfolders, child);
+ 
  	child = create_folder("deleted", "?msg nmo:isDeleted \"true\" . ");
  	parent->subfolders = g_slist_append(parent->subfolders, child);
  }
  
! static char *merge_names(const char *name, const char *lastname)
  {
! 	char *tmp = NULL;
  
! 	if (strlen(lastname) != 0) {
! 		if (strlen(name) == 0)
! 			tmp = g_strdup(lastname);
! 		else
! 			tmp = g_strdup_printf("%s %s", name, lastname);
! 	} else if (strlen(name) != 0)
! 		tmp = g_strdup(name);
! 	else
! 		tmp = g_strdup("");
! 
! 	return tmp;
  }
  
! static char *message2folder(const struct messages_message *data)
  {
! 	if (data->sent == TRUE)
! 		return g_strdup("telecom/msg/sent");
! 
! 	if (data->sent == FALSE)
! 		return g_strdup("telecom/msg/inbox");
! 
! 	return NULL;
  }
  
! static char *path2query(const char *folder, const char *query,
! 							const char *user_rule)
  {
! 	if (g_str_has_suffix(folder, "telecom/msg/inbox") == TRUE)
! 		return g_strdup_printf(query, "?msg nmo:isSent \"false\" ; "
! 					"nmo:isDeleted \"false\" ; "
! 					"nmo:isDraft \"false\". ", user_rule);
! 
! 	if (g_str_has_suffix(folder, "telecom/msg/sent") == TRUE)
! 		return g_strdup_printf(query, "?msg nmo:isSent \"true\" ; "
! 					"nmo:isDeleted \"false\" . ", user_rule);
! 
! 	if (g_str_has_suffix(folder, "telecom/msg/deleted") == TRUE)
! 		return g_strdup_printf(query, "?msg nmo:isDeleted \"true\" . ",
! 					user_rule);
  
! 	if (g_str_has_suffix(folder, "telecom/msg") == TRUE)
! 		return g_strdup_printf(query, "", user_rule);
  
! 	return NULL;
  }
  
! static gboolean filter_message(struct messages_message *message,
! 						struct messages_filter *filter)
  {
! 	if (filter->type != 0) {
! 		if (g_strcmp0(message->type, "SMS_GSM") == 0 &&
! 				(filter->type & 0x01))
! 			return FALSE;
! 
! 		if (g_strcmp0(message->type, "SMS_CDMA") == 0 &&
! 				(filter->type & 0x02))
! 			return FALSE;
! 
! 		if (g_strcmp0(message->type, "SMS_EMAIL") == 0 &&
! 				(filter->type & 0x04))
! 			return FALSE;
! 
! 		if (g_strcmp0(message->type, "SMS_MMS") == 0 &&
! 				(filter->type & 0x08))
! 			return FALSE;
! 	}
  
! 	if (filter->read_status != 0) {
! 		if (filter->read_status == 0x01 && message->read != FALSE)
! 			return FALSE;
! 
! 		if (filter->read_status == 0x02 && message->read != TRUE)
! 			return FALSE;
! 	}
! 
! 	if (filter->priority != 0) {
! 		if (filter->priority == 0x01 && message->priority == FALSE)
! 			return FALSE;
! 
! 		if (filter->priority == 0x02 && message->priority == TRUE)
! 			return FALSE;
! 	}
! 
! 	if (filter->period_begin != NULL &&
! 			g_strcmp0(filter->period_begin, message->datetime) > 0)
! 		return FALSE;
! 
! 	if (filter->period_end != NULL &&
! 			g_strcmp0(filter->period_end, message->datetime) < 0)
! 		return FALSE;
! 
! 	if (filter->originator != NULL) {
! 		char *orig = g_strdup_printf("*%s*", filter->originator);
! 
! 		if (g_pattern_match_simple(orig,
! 					message->sender_addressing != NULL ?
! 					message->sender_addressing : "") == FALSE &&
! 				g_pattern_match_simple(orig,
! 					message->sender_name != NULL ?
! 					message->sender_name : "") == FALSE) {
! 			g_free(orig);
! 			return FALSE;
! 		}
! 
! 		g_free(orig);
! 	}
! 
! 	if (filter->recipient != NULL) {
! 		char *recip = g_strdup_printf("*%s*", filter->recipient);
! 
! 		if (g_pattern_match_simple(recip,
! 					message->recipient_addressing != NULL ?
! 					message->recipient_addressing : "") ==
! 					FALSE &&
! 				g_pattern_match_simple(recip,
! 					message->recipient_name != NULL ?
! 					message->recipient_name : "") == FALSE) {
! 			g_free(recip);
! 			return FALSE;
! 		}
! 
! 		g_free(recip);
! 	}
! 
! 	return TRUE;
  }
  
! static struct phonebook_contact *pull_message_contact(const char **reply,
! 								gboolean sent)
  {
! 	struct phonebook_contact *contact;
! 	struct phonebook_field *number;
! 
! 	contact = g_new0(struct phonebook_contact, 1);
! 
! 	contact->fullname = g_strdup(reply[MESSAGE_CONTACT_FN]);
! 	contact->given = g_strdup(reply[MESSAGE_CONTACT_GIVEN]);
! 	contact->family = g_strdup(reply[MESSAGE_CONTACT_FAMILY]);
! 	contact->additional = g_strdup(reply[MESSAGE_CONTACT_ADDITIONAL]);
! 	contact->prefix = g_strdup(reply[MESSAGE_CONTACT_PREFIX]);
! 	contact->suffix = g_strdup(reply[MESSAGE_CONTACT_SUFFIX]);
! 
! 	number = g_new0(struct phonebook_field, 1);
! 	number->text = g_strdup(reply[MESSAGE_CONTACT_PHONE]);
! 	number->type = TEL_TYPE_NONE;
! 	contact->numbers = g_slist_append(contact->numbers, number);
! 
! 	return contact;
  }
  
! static char *format_tstamp(const char *stamp, const char *format)
  {
! 	struct tm tm;
! 	time_t time;
! 	char *local_time = g_new0(char, 16); /* format: "YYYYMMDDTHHMMSS\0" */
! 
! 	if (strptime(stamp, format, &tm) == NULL)
! 		return NULL;
! 
! 	time = timegm(&tm);
! 	localtime_r(&time, &tm);
! 	strftime(local_time, 16, "%Y%m%dT%H%M%S", &tm);
  
! 	return local_time;
! }
  
! static struct messages_message *pull_message_data(const char **reply)
! {
! 	struct messages_message *data = g_new0(struct messages_message, 1);
  
! 	data->handle = g_strdup(reply[MESSAGE_HANDLE] +
! 						MESSAGE_HANDLE_PREFIX_LEN);
  
! 	if (strlen(reply[MESSAGE_SUBJECT]) != 0)
! 		data->subject = g_strdup(reply[MESSAGE_SUBJECT]);
  	else
! 		data->subject = g_strdup(reply[MESSAGE_CONTENT]);
  
! 	data->mask |= PMASK_SUBJECT;
! 
! 	if (strlen(reply[MESSAGE_SDATE]) != 0)
! 		data->datetime = format_tstamp(reply[MESSAGE_SDATE],
! 						TRACKER_MESSAGE_TSTAMP_FORMAT);
! 	else if (strlen(reply[MESSAGE_RDATE]) != 0)
! 		data->datetime = format_tstamp(reply[MESSAGE_RDATE],
! 						TRACKER_MESSAGE_TSTAMP_FORMAT);
  	else
! 		data->datetime = g_strdup("");
  
! 	data->mask |= PMASK_DATETIME;
  
! 	data->sent = g_strcmp0(reply[MESSAGE_SENT], "true") == 0 ? TRUE : FALSE;
! 	data->mask |= PMASK_SENT;
! 
! 	if (!data->sent) {
! 		data->sender_name = merge_names(reply[MESSAGE_CONTACT_GIVEN],
! 						reply[MESSAGE_CONTACT_FAMILY]);
! 
! 		if (data->sender_name[0] != '\0')
! 			data->mask |= PMASK_SENDER_NAME;
! 
! 		data->sender_addressing =
! 					g_strdup(reply[MESSAGE_CONTACT_PHONE]);
! 		data->mask |= PMASK_SENDER_ADDRESSING;
! 
! 		data->recipient_addressing = g_strdup("");
! 	} else {
! 		data->recipient_name = merge_names(reply[MESSAGE_CONTACT_GIVEN],
! 						reply[MESSAGE_CONTACT_FAMILY]);
! 
! 		if (data->recipient_name[0] != '\0')
! 			data->mask |= PMASK_RECIPIENT_NAME;
! 
! 		data->recipient_addressing =
! 					g_strdup(reply[MESSAGE_CONTACT_PHONE]);
  	}
+ 	data->mask |= PMASK_RECIPIENT_ADDRESSING;
  
! 	data->type = g_strdup("SMS_GSM");
! 	data->mask |= PMASK_TYPE;
  
! 	data->size = g_strdup_printf("%d", strlen(reply[MESSAGE_CONTENT]));
! 	data->mask |= PMASK_SIZE;
! 
! 	data->text = TRUE;
! 	data->mask |= PMASK_TEXT;
! 
! 	data->reception_status = g_strdup("complete");
! 	data->mask |= PMASK_RECEPTION_STATUS;
! 
! 	data->attachment_size = g_strdup("0");
! 	data->mask |= PMASK_ATTACHMENT_SIZE;
! 
! 	data->priority = FALSE;
! 	data->mask |= PMASK_PRIORITY;
! 
! 	data->read = g_strcmp0(reply[MESSAGE_READ], "true") == 0 ? TRUE : FALSE;
! 	data->mask |= PMASK_READ;
! 
! 	data->protect = FALSE;
! 	data->mask |= PMASK_PROTECTED;
! 
! 	return data;
  }
  
! static void get_messages_listing_resp(const char **reply, void *user_data)
  {
! 	struct session *session = user_data;
! 	struct request *request = session->request;
! 	struct messages_message *msg_data;
! 	struct message_status *stat;
  
! 	DBG("reply %p", reply);
  
! 	if (reply == NULL)
! 		goto end;
  
! 	if (session->aborted)
! 		goto aborted;
  
! 	msg_data = pull_message_data(reply);
  
! 	stat = g_hash_table_lookup(session->msg_stat, msg_data->handle);
! 
! 	if (stat == NULL) {
! 		stat = g_new0(struct message_status, 1);
! 		stat->read = msg_data->read;
! 
! 		g_hash_table_insert(session->msg_stat,
! 					g_strdup(msg_data->handle), stat);
! 	} else if (stat != NULL && stat->read != STATUS_NOT_SET)
! 		msg_data->read = stat->read;
! 
! 	if (request->deleted && (stat == NULL || !stat->deleted))
  		goto done;
  
! 	if (!request->deleted && (stat != NULL && stat->deleted))
! 		goto done;
  
! 	/* It isn't clear whether or not NewMessage header should take into
! 	 * account full folder contents or only filtered messages */
! 	if (!msg_data->read)
! 		request->new_message = TRUE;
  
! 	if (!filter_message(msg_data, request->filter))
! 		goto done;
  
! 	request->size++;
  
! 	if (request->count == TRUE)
! 		goto done;
  
! 	if (request->size > request->offset &&
! 			(request->size - request->offset) <= request->max)
! 		request->cb.messages_list(session, -EAGAIN, 1,
! 						request->new_message, msg_data,
! 						request->user_data);
! 
! done:
! 	free_msg_data(msg_data);
! 	return;
! 
! end:
! 	request->cb.messages_list(session, 0, request->size - request->offset,
! 						request->new_message, NULL,
! 						request->user_data);
! 
! aborted:
! 	g_free(request->filter->period_begin);
! 	g_free(request->filter->period_end);
! 	g_free(request->filter->originator);
! 	g_free(request->filter->recipient);
! 	g_free(request->filter);
! 
! 	g_free(request);
! 
! 	session->request = NULL;
! 	if (session->destroy)
! 		messages_disconnect(session);
  }
  
! static void get_message_resp(const char **reply, void *s)
  {
  	struct session *session = s;
! 	struct request *request = session->request;
! 	struct messages_message *msg_data;
! 	struct bmsg *bmsg;
! 	char *final_bmsg, *status, *folder, *handle;
! 	struct phonebook_contact *contact;
! 	struct message_status *stat;
! 	int err;
  
! 	DBG("reply %p", reply);
  
! 	if (reply == NULL)
! 		goto done;
  
! 	if (session->aborted)
! 		goto aborted;
  
! 	msg_data = pull_message_data(reply);
! 	handle = fill_handle(msg_data->handle);
! 	g_free(msg_data->handle);
! 	msg_data->handle = handle;
  
! 	contact = pull_message_contact(reply, msg_data->sent);
  
! 	stat = g_hash_table_lookup(session->msg_stat, msg_data->handle);
! 
! 	if (stat != NULL && stat->read != STATUS_NOT_SET)
! 		msg_data->read = stat->read;
! 
! 	status = msg_data->read ? "READ" : "UNREAD";
! 
! 	folder = message2folder(msg_data);
! 
! 	bmsg = g_new0(struct bmsg, 1);
! 	bmsg_init(bmsg, BMSG_VERSION_1_0, status, BMSG_SMS, folder);
! 
! 	if (!msg_data->sent)
! 		bmsg_add_originator(bmsg, contact);
! 
! 	bmsg_add_envelope(bmsg);
! 
! 	if (msg_data->sent)
! 		bmsg_add_recipient(bmsg, contact);
! 
! 	bmsg_add_content(bmsg, -1, NULL, SMS_DEFAULT_CHARSET, NULL,
! 						reply[MESSAGE_CONTENT]);
! 
! 	final_bmsg = bmsg_text(bmsg);
! 
! 	request->cb.message(session, 0, FALSE, final_bmsg, request->user_data);
! 
! 	bmsg_destroy(bmsg);
! 	g_free(folder);
! 	g_free(final_bmsg);
! 	free_msg_data(msg_data);
! 	phonebook_contact_free(contact);
! 
! 	request->count++;
! 
! 	return;
! 
! done:
! 	if (request->count == 0)
! 		err = -ENOENT;
! 	else
! 		err = 0;
! 
! 	request->cb.message(session, err, FALSE, NULL, request->user_data);
! 
! aborted:
! 	g_free(request->name);
! 	g_free(request);
! 	session->request = NULL;
! 
! 	if (session->destroy)
! 		messages_disconnect(session);
! }
! 
! static void session_dispatch_event(struct session *session,
! 						struct messages_event *event)
! {
! 	if (session->push_in_progress) {
! 		struct messages_event *data;
! 
! 		data = g_new0(struct messages_event, 1);
! 		data->type = event->type;
! 		data->msg_type = g_strdup(event->msg_type);
! 		data->old_folder = g_strdup(event->old_folder);
! 		data->handle = g_strdup(event->handle);
! 		data->folder = g_strdup(event->folder);
! 
! 		session->mns_event_cache = g_slist_append(
! 						session->mns_event_cache,
! 						data);
! 
! 		DBG("Event cached");
! 	} else {
! 		session->event_cb(session, event, session->event_user_data);
! 
! 		DBG("Event dispatched");
! 	}
! }
! 
! static void notify_new_sms(const char *handle, enum messages_event_type type,
! 						enum event_direction direction)
! {
! 	struct messages_event *data;
! 	GSList *next;
! 
! 	DBG("");
! 
! 	data = g_new0(struct messages_event, 1);
! 	data->type = type;
! 	data->msg_type = g_strdup("SMS_GSM");
! 	data->old_folder = g_strdup("");
! 	data->handle = fill_handle(handle);
! 
! 	switch (direction) {
! 		case DIRECTION_INBOUND:
! 			data->folder = g_strdup("telecom/msg/inbox");
! 			break;
! 		case DIRECTION_OUTBOUND:
! 			data->folder = g_strdup("telecom/msg/sent");
! 			break;
! 		default:
! 			data->folder = g_strdup("");
! 			break;
! 	}
! 
! 	for (next = mns_srv; next != NULL; next = g_slist_next(next)) {
! 		struct session *session = next->data;
! 
! 		session_dispatch_event(session, data);
! 	}
! }
! 
! static void notify_cached_events(struct session *session, const char *h)
! {
! 	GSList *event;
! 	char *handle = fill_handle(h);
! 
! 	DBG("");
! 
! 	for (event = session->mns_event_cache; event != NULL;
! 						event = g_slist_next(event)) {
! 		struct messages_event *data = event->data;
! 
! 		if (handle != NULL && g_strcmp0(handle, data->handle) == 0) {
! 			free_event_data(data);
! 
! 			continue;
! 		}
! 
! 		if (g_slist_find(mns_srv, session) != NULL)
! 			session->event_cb(session, data,
! 						session->event_user_data);
! 	}
! 
! 	g_slist_free(session->mns_event_cache);
! 	session->mns_event_cache = NULL;
! 	g_free(handle);
! }
! 
! static gboolean handle_new_sms(DBusConnection * connection, DBusMessage * msg,
! 							void *user_data)
! {
! 	DBusMessageIter arg, inner_arg, struct_arg;
! 	unsigned ihandle = 0;
! 	int32_t direction;
! 	char *handle;
! 
! 	DBG("");
! 
! 	if (!dbus_message_iter_init(msg, &arg))
! 		return TRUE;
! 
! 	if (dbus_message_iter_get_arg_type(&arg) != DBUS_TYPE_ARRAY)
! 		return TRUE;
! 
! 	dbus_message_iter_recurse(&arg, &inner_arg);
! 
! 	if (dbus_message_iter_get_arg_type(&inner_arg) != DBUS_TYPE_STRUCT)
! 		return TRUE;
! 
! 	dbus_message_iter_recurse(&inner_arg, &struct_arg);
! 
! 	if (dbus_message_iter_get_arg_type(&struct_arg) != DBUS_TYPE_INT32)
! 		return TRUE;
! 
! 	dbus_message_iter_get_basic(&struct_arg, &ihandle);
! 
! 	handle = g_strdup_printf("%d", ihandle);
! 
! 	dbus_message_iter_next(&struct_arg); /* Type */
! 	dbus_message_iter_next(&struct_arg); /* StartTime */
! 	dbus_message_iter_next(&struct_arg); /* EndTime */
! 	dbus_message_iter_next(&struct_arg); /* Direction */
! 
! 	if (dbus_message_iter_get_arg_type(&struct_arg) != DBUS_TYPE_INT32)
! 		return TRUE;
! 
! 	dbus_message_iter_get_basic(&struct_arg, &direction);
! 
! 	DBG("new message: %s", handle);
! 
! 	notify_new_sms(handle, MET_NEW_MESSAGE, direction);
! 
! 	g_free(handle);
! 
! 	return TRUE;
! }
! 
! static gboolean handle_del_sms(DBusConnection * connection, DBusMessage * msg,
! 							void *user_data)
! {
! 	DBusMessageIter arg;
! 	unsigned ihandle = 0;
! 	char *handle;
! 
! 	DBG("");
! 
! 	if (!dbus_message_iter_init(msg, &arg))
! 		return TRUE;
! 
! 	if (dbus_message_iter_get_arg_type(&arg) != DBUS_TYPE_INT32)
! 		return TRUE;
! 
! 	dbus_message_iter_get_basic(&arg, &ihandle);
! 
! 	handle = g_strdup_printf("%d", ihandle);
! 
! 	DBG("message deleted: %s", handle);
! 
! 	notify_new_sms(handle, MET_MESSAGE_DELETED, DIRECTION_UNKNOWN);
! 
! 	g_free(handle);
! 
! 	return TRUE;
! }
! 
! static int retrieve_message_id_tracker_id(void)
! {
! 	DBusMessage *msg;
! 	DBusMessage *reply;
! 	DBusMessageIter iargs, irows, icols;
! 	char *id;
! 	char *query = "SELECT tracker:id(nmo:messageId) {}";
! 
! 	msg = dbus_message_new_method_call(TRACKER_SERVICE,
! 						TRACKER_RESOURCES_PATH,
! 						TRACKER_RESOURCES_INTERFACE,
! 						"SparqlQuery");
! 
! 	if (msg == NULL)
! 		goto failed;
! 
! 	if (!dbus_message_append_args(msg, DBUS_TYPE_STRING,
! 					&query,
! 					DBUS_TYPE_INVALID))
! 		goto failed;
! 
! 	reply = dbus_connection_send_with_reply_and_block(session_connection,
! 								msg, -1, NULL);
! 
! 	if (reply == NULL)
! 		goto failed;
! 
! 	if (!dbus_message_iter_init(reply, &iargs))
! 		goto failed;
! 
! 	if (dbus_message_iter_get_arg_type(&iargs) != DBUS_TYPE_ARRAY)
! 		goto failed;
! 
! 	dbus_message_iter_recurse(&iargs, &irows);
! 
! 	if (dbus_message_iter_get_arg_type(&irows) == DBUS_TYPE_ARRAY) {
! 		dbus_message_iter_recurse(&irows, &icols);
! 		dbus_message_iter_get_basic(&icols, &id);
! 		message_id_tracker_id = strtoul(id, NULL, 10);
! 		DBG("tracker:id(nmo:messageId): %lu", message_id_tracker_id);
! 	} else {
! 		goto failed;
! 	}
! 
! 	dbus_message_unref(reply);
! 	dbus_message_unref(msg);
! 
! 	return 0;
! 
! failed:
! 	DBG("Unable to get tracker.id(nmo:messageId)!");
! 
! 	if (reply != NULL)
! 		dbus_message_unref(reply);
! 
! 	if (msg != NULL)
! 		dbus_message_unref(msg);
! 
! 	return -ENOENT;
! }
! 
! int messages_init(void)
! {
! 	session_connection = dbus_bus_get(DBUS_BUS_SESSION, NULL);
! 
! 	if (session_connection == NULL) {
! 		error("Unable to connect to the session bus.");
! 
! 		return -1;
! 	}
! 
! 	if (retrieve_message_id_tracker_id() < 0)
! 		return -1;
! 
! 	messages_qt_init();
! 
! 	create_folder_tree();
! 
! 	return 0;
! }
! 
! void messages_exit(void)
! {
! 	destroy_folder_tree(folder_tree);
! 
! 	dbus_connection_unref(session_connection);
! 
! 	messages_qt_exit();
! }
! 
! int messages_connect(void **s)
! {
! 	struct session *session = g_new0(struct session, 1);
! 
! 	session->cwd = g_strdup("/");
! 	session->folder = folder_tree;
! 
! 	session->msg_stat = g_hash_table_new_full(g_str_hash, g_str_equal,
! 							g_free, g_free);
! 
! 	*s = session;
! 
! 	return 0;
! }
! 
! void messages_disconnect(void *s)
! {
! 	struct session *session = s;
! 
! 	messages_set_notification_registration(session, NULL, NULL);
! 
! 	if (session->request != NULL) {
! 		session->destroy = TRUE;
! 
! 		return;
! 	}
! 
! 	g_hash_table_destroy(session->msg_stat);
! 	g_free(session->cwd);
! 	g_free(session);
! }
! 
! int messages_set_notification_registration(void *session, messages_event_cb cb,
! 								void *user_data)
! {
! 	struct session *session = s;
! 
! 	if (cb != NULL) {
! 		if (g_slist_find(mns_srv, session) != NULL)
! 			return 0;
! 
! 		if (g_slist_length(mns_srv) == 0) {
! 			newmsg_watch_id = g_dbus_add_signal_watch(
! 							session_connection,
! 							NULL, NULL,
! 							"com.nokia.commhistory",
! 							"eventsAdded",
! 							handle_new_sms,
! 							NULL, NULL);
! 			delmsg_watch_id = g_dbus_add_signal_watch(
! 							session_connection,
! 							NULL, NULL,
! 							"com.nokia.commhistory",
! 							"eventDeleted",
! 							handle_del_sms,
! 							NULL, NULL);
! 		}
! 
! 		if (newmsg_watch_id == 0 || delmsg_watch_id == 0)
! 			return -EIO;
! 
! 		session->event_user_data = user_data;
! 		session->event_cb = cb;
! 
! 		mns_srv = g_slist_prepend(mns_srv, session);
! 	} else {
! 		mns_srv = g_slist_remove(mns_srv, session);
! 
! 		if (g_slist_length(mns_srv) == 0) {
! 			g_dbus_remove_watch(session_connection,
! 							newmsg_watch_id);
! 			g_dbus_remove_watch(session_connection,
! 							delmsg_watch_id);
! 		}
! 	}
! 
! 	return 0;
! }
! 
! int messages_set_folder(void *s, const char *name, gboolean cdup)
! {
! 	struct session *session = s;
! 	char *newrel = NULL;
! 	char *newabs;
! 	char *tmp;
! 
! 	if (name && (strchr(name, '/') || strcmp(name, "..") == 0))
! 		return -EBADR;
! 
! 	if (cdup) {
! 		if (session->cwd[0] == 0)
! 			return -ENOENT;
! 
! 		newrel = g_path_get_dirname(session->cwd);
! 
! 		/* We use empty string for indication of the root directory */
! 		if (newrel[0] == '.' && newrel[1] == 0)
! 			newrel[0] = 0;
! 	}
! 
! 	tmp = newrel;
! 	if (!cdup && (!name || name[0] == 0))
! 		newrel = g_strdup("");
! 	else
! 		newrel = g_build_filename(newrel ? newrel : session->cwd, name,
! 									NULL);
! 	g_free(tmp);
! 
! 	if (newrel[0] != '/')
! 		newabs = g_build_filename("/", newrel, NULL);
! 	else
! 		newabs = g_strdup(newrel);
! 
! 	session->folder = get_folder(newabs);
! 	if (session->folder == NULL) {
! 		g_free(newrel);
! 		g_free(newabs);
! 
! 		return -ENOENT;
! 	}
! 
! 	g_free(newrel);
! 	g_free(session->cwd);
! 	session->cwd = newabs;
! 
! 	return 0;
! }
! 
! static gboolean async_get_folder_listing(void *s)
! {
! 	struct session *session = s;
! 	struct request *request = session->request;
! 	gboolean count = FALSE;
! 	int folder_count = 0;
! 	char *path = NULL;
! 	struct message_folder *folder;
! 	GSList *dir;
! 
! 	if (session->aborted)
! 		goto aborted;
! 
! 	if (request->name && strchr(request->name, '/') != NULL)
! 		goto done;
! 
! 	path = g_build_filename(session->cwd, request->name, NULL);
! 
! 	if (path == NULL || strlen(path) == 0)
! 		goto done;
! 
! 	folder = get_folder(path);
! 
! 	if (folder == NULL)
! 		goto done;
! 
! 	if (request->max == 0) {
! 		request->max = 0xffff;
! 		request->offset = 0;
! 		count = TRUE;
! 	}
! 
! 	for (dir = folder->subfolders; dir &&
! 				(folder_count - request->offset) < request->max;
! 				folder_count++, dir = g_slist_next(dir)) {
! 		struct message_folder *dir_data = dir->data;
! 
! 		if (count == FALSE && request->offset <= folder_count)
! 			request->folder_list_cb(session, -EAGAIN, 0,
! 					dir_data->name, request->user_data);
! 	}
! 
!  done:
! 	request->folder_list_cb(session, 0, folder_count, NULL,
! 							request->user_data);
! 
! 	g_free(path);
! 
! aborted:
! 	g_free(request->name);
! 	g_free(request);
! 	session->request = NULL;
! 
! 	if (session->destroy)
! 		messages_disconnect(session);
! 
! 	return FALSE;
! }
! 
! int messages_get_folder_listing(void *s, const char *name,
! 					uint16_t max, uint16_t offset,
! 					messages_folder_listing_cb callback,
! 					void *user_data)
! {
! 	struct session *session = s;
! 	struct request *request = g_new0(struct request, 1);
! 
! 	request->name = g_strdup(name);
! 	request->max = max;
! 	request->offset = offset;
! 	request->folder_list_cb = callback;
! 	request->user_data = user_data;
! 
! 	session->aborted = FALSE;
! 	session->request = request;
! 
! 	g_idle_add_full(G_PRIORITY_DEFAULT_IDLE, async_get_folder_listing,
! 						session, NULL);
! 
! 	return 0;
! }
! 
! int messages_get_messages_listing(void *session,
! 				const char *name,
! 				uint16_t max, uint16_t offset,
! 				const struct messages_filter *filter,
! 				messages_get_messages_listing_cb callback,
! 				void *user_data)
! {
! 	struct session *session = s;
! 	struct request *request;
! 	char *path, *query;
! 	struct message_folder *folder = NULL;
! 	DBusPendingCall *call;
! 	int err = 0;
! 
! 	if (name == NULL || strlen(name) == 0) {
! 		path = g_strdup(session->cwd);
! 
! 		folder = session->folder;
! 		if (folder == NULL)
! 			folder = get_folder(path);
! 	} else {
! 		if (strchr(name, '/') != NULL)
! 			return -EBADR;
! 
! 		path = g_build_filename(session->cwd, name, NULL);
! 		folder = get_folder(path);
! 	}
! 
! 	g_free(path);
! 
! 	if (folder == NULL)
! 		return -EBADR;
! 
! 	query = folder2query(folder, LIST_MESSAGES_QUERY);
! 	if (query == NULL)
! 		return -ENOENT;
! 
! 	request = g_new0(struct request, 1);
! 
! 	request->filter = copy_messages_filter(filter);
! 	request->generate_response = get_messages_listing_resp;
! 	request->cb.messages_list = callback;
! 	request->offset = offset;
! 	request->max = max;
! 	request->user_data = user_data;
! 	request->deleted = g_strcmp0(folder->name, "deleted") ? FALSE : TRUE;
! 
! 	session->aborted = FALSE;
! 
! 	if (session->request) {
! 		g_free(session->request->name);
! 		g_free(session->request);
! 	}
! 
! 	session->request = request;
! 
! 	if (max == 0) {
! 		request->max = 0xffff;
! 		request->offset = 0;
! 		request->count = TRUE;
! 	}
! 
! 	call = query_tracker(query, session, &err);
! 
! 	g_free(query);
! 
! 	return err;
! }
! 
! int messages_get_message(void *session, const char *handle,
! 				unsigned long flags,
! 				messages_get_message_cb callback,
! 				void *user_data)
! {
! 	struct session *session = s;
! 	struct request *request;
! 	DBusPendingCall *call;
! 	int err = 0;
! 	char *handle, *query_handle, *query;
! 
! 	if (!validate_handle(h))
! 		return -ENOENT;
! 
! 	handle = strip_handle(h);
! 	query_handle = g_strdup_printf(MESSAGES_FILTER_BY_HANDLE, handle);
! 	query = path2query("telecom/msg", LIST_MESSAGES_QUERY, query_handle);
! 
! 	if (query == NULL) {
! 		err = -ENOENT;
! 
! 		goto failed;
! 	}
! 
! 	if (flags & MESSAGES_FRACTION && flags & MESSAGES_NEXT) {
! 		err = -EBADR;
! 
! 		goto failed;
! 	}
! 
! 	request = g_new0(struct request, 1);
! 
! 	request->name = g_strdup(handle);
! 	request->flags = flags;
! 	request->cb.message = cb;
! 	request->generate_response = get_message_resp;
! 	request->user_data = user_data;
! 
! 	session->aborted = FALSE;
! 
! 	if (session->request) {
! 		g_free(session->request->name);
! 		g_free(session->request);
! 	}
! 
! 	session->request = request;
! 
! 	call = query_tracker(query, session, &err);
! 
! failed:
! 	g_free(query_handle);
! 	g_free(handle);
! 	g_free(query);
! 
! 	return err;
! }
! 
! static void messages_qt_callback(int err, void *user_data)
! {
! 	struct session *session = user_data;
! 	struct request *request = session->request;
! 
! 	if (!session->aborted && request->cb.status)
! 		request->cb.status(session, err, request->user_data);
! 
! 	g_free(request);
! 	session->request = NULL;
! }
! 
! int messages_set_message_status(void *s, const char *handle, uint8_t indicator,
! 			uint8_t value, messages_set_message_status_cb callback,
! 			void *user_data)
! {
! 	struct session *session = s;
! 	struct message_status *stat = NULL;
! 	int ret;
! 	struct request *request;
! 
! 	stat = g_hash_table_lookup(session->msg_stat, handle);
! 	if (stat == NULL) {
! 		stat = g_new0(struct message_status, 1);
! 		stat->read = STATUS_NOT_SET;
! 
! 		g_hash_table_insert(session->msg_stat, g_strdup(handle), stat);
! 	}
! 
! 	request = g_new0(struct request, 1);
! 	request->cb.status = callback;
! 	request->user_data = user_data;
! 	session->request = request;
! 
! 	switch (indicator) {
! 		case 0x0:
! 			ret = messages_qt_set_read(&request->set_status_call,
! 						handle, value & 0x01,
! 						messages_qt_callback, session);
! 			if (ret < 0)
! 				return ret;
! 
! 			stat->read = value;
! 			break;
! 		case 0x1:
! 			ret = messages_qt_set_deleted(&request->set_status_call,
! 						handle, value & 0x01,
! 						messages_qt_callback, session);
! 			if (ret < 0)
! 				return ret;
! 
! 			stat->deleted = value;
! 			break;
! 		default:
! 			g_free(request);
! 			session->request = NULL;
! 			return -EBADR;
! 	}
! 
! 	return 0;
! }
! 
! static void push_message_abort(gpointer s)
! {
! 	struct session *session = s;
! 	struct push_message_request *request = session->request_data;
! 
! 	DBG("");
! 
! 	if (request == NULL)
! 		return;
! 
! 	if (request->send_sms != NULL) {
! 		dbus_pending_call_cancel(request->send_sms);
! 		dbus_pending_call_unref(request->send_sms);
! 	}
! 
! 	if (request->get_handle != NULL) {
! 		DBG("Cancelled get_handle");
! 		dbus_pending_call_cancel(request->get_handle);
! 		dbus_pending_call_unref(request->get_handle);
! 	}
! 
! 	if (request->insert_message_call != NULL)
! 		messages_qt_insert_message_abort(request->insert_message_call);
! 
! 	g_dbus_remove_watch(session_connection, request->watch);
! 
! 	if (request->body)
! 		g_string_free(request->body, TRUE);
! 
! 	if (request->name)
! 		g_free(request->name);
! 
! 	g_free(request->uuid);
! 	g_free(request);
! 
! 	session->push_in_progress = FALSE;
! 	notify_cached_events(session, NULL);
! }
! 
! static void push_message_finalize(struct session *session)
! {
! 	DBG("");
! 
! 	push_message_abort(session);
! 	session->request_data = NULL;
! 	session->abort_request = NULL;
! }
! 
! static void send_sms_finalize(struct session *session, const char *uri)
! {
! 	struct push_message_request *request = session->request_data;
! 	char handle[HANDLE_LEN];
! 	unsigned long uri_no;
! 
! 	if (sscanf(uri, "message:%lu", &uri_no) != 1)
! 		request->cb(session, -EIO, NULL, request->user_data);
! 	else {
! 		snprintf(handle, HANDLE_LEN, "%016lu", uri_no);
! 		request->cb(session, 0, handle, request->user_data);
! 	}
! 
! 	notify_cached_events(session, handle);
! 	push_message_finalize(session);
! }
! 
! static int get_uri_by_uuid(void *s, const char *id);
! 
! static void get_uri_by_uuid_pc(DBusPendingCall *pc, void *user_data)
! {
! 	struct session *session = user_data;
! 	struct push_message_request *request = session->request_data;
! 	DBusMessage *reply;
! 	DBusError error;
! 	DBusMessageIter iargs, irows, icols;
! 	char *uri;
! 
! 	reply = dbus_pending_call_steal_reply(pc);
! 	dbus_error_init(&error);
! 
! 	if (dbus_set_error_from_message(&error, reply)) {
! 		DBG("%s: %s", error.name, error.message);
! 		dbus_error_free(&error);
! 
! 		goto cont;
! 	}
! 
! 	if (!dbus_message_has_signature(reply, "aas")) {
! 		DBG("Unexpected signature: %s",
! 					dbus_message_get_signature(reply));
! 
! 		goto cont;
! 	}
! 
! 	dbus_message_iter_init(reply, &iargs);
! 	dbus_message_iter_recurse(&iargs, &irows);
! 
! 	if (dbus_message_iter_get_arg_type(&irows) != DBUS_TYPE_ARRAY) {
! 		DBG("Message not yet in Tracker");
! 		goto cont;
! 	}
! 
! 	dbus_message_iter_recurse(&irows, &icols);
! 	dbus_message_iter_get_basic(&icols, &uri);
! 	DBG("URI: %s", uri);
! 	dbus_message_unref(reply);
! 	send_sms_finalize(session, uri);
! 
! 	return;
! 
! cont:
! 	dbus_message_unref(reply);
! 	dbus_pending_call_unref(request->get_handle);
! 	request->get_handle = NULL;
! 
! 	if (request->retry) {
! 		request->retry = FALSE;
! 		get_uri_by_uuid(session, request->uuid);
! 	}
! }
! 
! static int get_uri_by_uuid(void *s, const char *id)
! {
! 	struct session *session = s;
! 	struct push_message_request *request = session->request_data;
! 	DBusMessage *msg;
! 	DBusPendingCall *pc;
! 	char *query;
! 
! 	if (request->get_handle != NULL) {
! 		request->retry = TRUE;
! 		return 0;
! 	}
! 
! 	msg = dbus_message_new_method_call(TRACKER_SERVICE,
! 						TRACKER_RESOURCES_PATH,
! 						TRACKER_RESOURCES_INTERFACE,
! 						"SparqlQuery");
! 	if (msg == NULL)
! 		goto failed;
! 
! 	query = g_strdup_printf(HANDLE_BY_UUID_QUERY, id);
! 	if (!dbus_message_append_args(msg, DBUS_TYPE_STRING, &query,
! 							DBUS_TYPE_INVALID)) {
! 		g_free(query);
! 		goto failed;
! 	}
! 	g_free(query);
! 
! 	if (!dbus_connection_send_with_reply(session_connection, msg, &pc, -1))
! 		goto failed;
! 
! 	if (!dbus_pending_call_set_notify(pc, get_uri_by_uuid_pc, session,
! 									NULL)) {
! 		dbus_pending_call_cancel(pc);
! 		goto failed;
! 	}
! 
! 	dbus_message_unref(msg);
! 	request->get_handle = pc;
! 
! 	return 0;
! 
! failed:
! 	if (pc != NULL)
! 		dbus_pending_call_unref(pc);
! 
! 	if (msg != NULL)
! 		dbus_message_unref(msg);
! 
! 	push_message_finalize(session);
! 
! 	return -ENOMEM;
! }
! 
! static gboolean send_sms_graph_updated(DBusConnection *connection,
! 					DBusMessage *msg, void *user_data)
! {
! 	struct session *session = user_data;
! 	struct push_message_request *request = session->request_data;
! 	DBusMessageIter iargs, irows, icols;
! 	char *class;
! 	dbus_uint32_t predicate;
! 
! 	dbus_message_iter_init(msg, &iargs);
! 	if (dbus_message_iter_get_arg_type(&iargs) != DBUS_TYPE_STRING)
! 		return TRUE;
! 
! 	dbus_message_iter_get_basic(&iargs, &class);
! 	if (g_strcmp0("http://www.semanticdesktop.org/ontologies"
! 					"/2007/03/22/nmo#Message", class) != 0)
! 		return TRUE;
! 
! 	dbus_message_iter_next(&iargs);
! 	if (dbus_message_iter_get_arg_type(&iargs) != DBUS_TYPE_ARRAY)
! 		return TRUE;
! 
! 	dbus_message_iter_recurse(&iargs, &irows);
! 
! 	while (dbus_message_iter_get_arg_type(&irows) == DBUS_TYPE_STRUCT) {
! 		dbus_message_iter_recurse(&irows, &icols);
! 		dbus_message_iter_next(&icols);
! 		dbus_message_iter_next(&icols);
! 		dbus_message_iter_get_basic(&icols, &predicate);
! 		if (predicate == message_id_tracker_id) {
! 			DBG("Predicate hit!");
! 			get_uri_by_uuid(session, request->uuid);
! 		}
! 		dbus_message_iter_next(&irows);
! 	}
! 
! 	return TRUE;
! }
! 
! static void send_sms_messaging_pc(DBusPendingCall *pc, void *user_data)
! {
! 	struct session *session = user_data;
! 	struct push_message_request *request = session->request_data;
! 	DBusMessage *reply;
! 	DBusError error;
! 	char *uuid;
! 	int err;
! 
! 	DBG("");
! 
! 	reply = dbus_pending_call_steal_reply(pc);
! 	dbus_error_init(&error);
! 
! 	if (dbus_set_error_from_message(&error, reply)) {
! 		DBG("%s: %s", error.name, error.message);
! 		dbus_error_free(&error);
! 		err = -EIO;
! 
! 		goto failed;
! 	}
! 
! 	if (!dbus_message_has_signature(reply, DBUS_TYPE_STRING_AS_STRING)) {
! 		DBG("Unexpected signature: %s",
! 					dbus_message_get_signature(reply));
! 		err = -EIO;
! 
! 		goto failed;
! 	}
! 
! 	dbus_message_get_args(reply, NULL, DBUS_TYPE_STRING, &uuid,
! 							DBUS_TYPE_INVALID);
! 	if (uuid[0] == '\0') {
! 		DBG("Empty response from SendSMS, possibly wrong phone number");
! 		err = -EBADR;
! 
! 		goto failed;
! 	}
! 
! 
! 	DBG("Message UUID: %s", uuid);
! 	request->uuid = g_strdup(uuid);
! 
! 	request->watch = g_dbus_add_signal_watch(session_connection,
! 					NULL, NULL,
! 					"org.freedesktop.Tracker1.Resources",
! 					"GraphUpdated",
! 					send_sms_graph_updated,
! 					session, NULL);
! 	get_uri_by_uuid(session, uuid);
! 
! 	dbus_message_unref(reply);
! 	dbus_pending_call_unref(request->send_sms);
! 	request->send_sms = NULL;
! 
! 	return;
! 
! failed:
! 	request->cb(session, err, NULL, request->user_data);
! 	push_message_finalize(session);
! 	dbus_message_unref(reply);
! }
! 
! static int send_sms(struct session *session, const char *recipient,
! 					const char *body, gboolean store)
! {
! 	struct push_message_request *request = session->request_data;
! 	DBusMessage *msg = NULL;
! 	DBusPendingCall *pc = NULL;
! 
! 	msg = dbus_message_new_method_call("com.nokia.Messaging", "/",
! 					"com.nokia.MessagingIf", "sendSMS");
! 	if (msg == NULL)
! 		goto failed;
! 
! 	if (!dbus_message_append_args(msg, DBUS_TYPE_STRING, &recipient,
! 						DBUS_TYPE_STRING, &body,
! 						DBUS_TYPE_BOOLEAN, &store,
! 						DBUS_TYPE_INVALID))
! 		goto failed;
! 
! 	if (!dbus_connection_send_with_reply(session_connection, msg,
! 							&pc, -1))
! 		goto failed;
! 
! 	if (!dbus_pending_call_set_notify(pc, send_sms_messaging_pc,
! 							session, NULL)) {
! 		/* XXX: Now, that's kind of a problem */
! 		dbus_pending_call_cancel(pc);
! 		goto failed;
! 	}
! 
! 	dbus_message_unref(msg);
! 	request->send_sms = pc;
! 
! 	return 0;
! 
! failed:
! 	if (pc != NULL)
! 		dbus_pending_call_unref(pc);
! 	if (msg != NULL)
! 		dbus_message_unref(msg);
! 
! 	return -ENOMEM;
! }
! 
! static void insert_message_cb(int id, void *s)
! {
! 	struct session *session = s;
! 	struct push_message_request *request = session->request_data;
! 	char handle[HANDLE_LEN];
! 
! 	DBG("");
! 
! 	if (id < 0) {
! 		request->cb(session, id, NULL, request->user_data);
! 		goto finalize;
! 	}
! 
! 	request->insert_message_call = NULL;
! 
! 	snprintf(handle, HANDLE_LEN, "%016d", id);
! 	request->cb(session, 0, handle, request->user_data);
! 
! 	notify_cached_events(session, handle);
! 
! finalize:
! 	push_message_finalize(session);
! }
! 
! static int store_sms(struct session *session, const char *recipient,
! 					const char *body)
! {
! 	struct push_message_request *request = session->request_data;
! 
! 	DBG("");
! 
! 	return messages_qt_insert_message(&request->insert_message_call,
! 						recipient, body, request->name,
! 						insert_message_cb, session);
! }
! 
! int messages_push_message(void *s, struct bmsg_bmsg *bmsg, const char *name,
! 						unsigned long flags,
! 						messages_push_message_cb cb,
! 						void *user_data)
! {
! 	struct session *session = s;
! 	struct push_message_request *request;
! 
! 	session->push_in_progress = TRUE;
! 
! 	if ((flags & MESSAGES_UTF8) != MESSAGES_UTF8) {
! 		DBG("Tried to push non-utf message");
! 		return -EINVAL;
! 	}
! 
! 	if ((flags & MESSAGES_TRANSPARENT) == MESSAGES_TRANSPARENT)
! 		DBG("Warning! Transparent flag is ignored");
! 
! 	if ((flags & MESSAGES_RETRY) != MESSAGES_RETRY)
! 		DBG("Warning! Retry flag is ignored.");
! 
! 	if (bmsg->type != BMSG_T_SMS_GSM ||
! 					bmsg->charset != BMSG_C_UTF8 ||
! 					bmsg->part_id != -1 ||
! 					bmsg->nenvelopes < 1) {
! 		DBG("Incorrect BMSG format!");
! 		return -EBADR;
! 	}
! 
! 	request = g_new0(struct push_message_request, 1);
! 	session->request_data = request;
! 	session->abort_request = push_message_abort;
! 
! 	request->bmsg = bmsg;
! 	request->cb = cb;
! 	request->body = g_string_new("");
! 	request->user_data = user_data;
! 
! 	request->name = g_build_filename(session->cwd, name, NULL);
! 	DBG("Push destination: %s", request->name);
! 
! 	return 0;
! }
! 
! static int prepare_body(GString *body)
! {
! 	if (body->len < MSG_BLOCK_OVERHEAD)
! 		return -EBADR;
! 
! 	if (!g_str_has_prefix(body->str, "BEGIN:MSG\r\n"))
! 		return -EBADR;
! 
! 	if (!g_str_has_prefix(body->str + body->len - 11, "\r\nEND:MSG\r\n"))
! 		return -EBADR;
! 
! 	g_string_erase(body, 0, 11);
! 	g_string_set_size(body, body->len - 10);
! 	body->str[body->len - 1] = '\0';
! 
! 	return 0;
! }
! 
! int messages_push_message_body(void *s, const char *body, size_t len)
! {
! 	struct session *session = s;
! 	struct push_message_request *request = session->request_data;
! 	struct bmsg_bmsg_vcard *vcard;
! 	int env, ret;
! 
! 	if (len > 0) {
! 		g_string_append_len(request->body, body, len);
! 		return len;
! 	}
! 
! 	env = request->bmsg->nenvelopes - 1;
! 	if (env < 0 || request->bmsg->recipients[env] == NULL)
! 	{
! 		ret = -EBADR;
! 		goto failed;
! 	}
! 
! 	if (request->bmsg->recipients[env]->next != NULL)
! 	{
! 		ret = -EINVAL;
! 		goto failed;
! 	}
! 
! 	vcard = request->bmsg->recipients[request->bmsg->nenvelopes - 1]->data;
! 	if (vcard->tel == NULL) {
! 		ret = -EBADR;
! 		goto failed;
! 	}
! 
! 	ret = prepare_body(request->body);
! 	if (ret < 0)
! 		goto failed;
! 
! 	if (g_strcmp0(request->name, "/telecom/msg/outbox") == 0)
! 		ret = send_sms(session, vcard->tel, request->body->str, TRUE);
! 	else
! 		ret = store_sms(session, vcard->tel, request->body->str);
! 
! 	if (ret < 0)
! 		goto failed;
! 
! 	g_string_free(request->body, TRUE);
! 	request->body = NULL;
! 
! 	return 0;
! 
! failed:
! 	push_message_finalize(session);
! 
! 	return ret;
! }
! 
! int messages_update_inbox(void *session, messages_update_inbox_cb callback,
! 							void *user_data)
! {
! 	return -ENOSYS;
! }
! 
! void messages_abort(void *session)
! {
! 	struct session *session = s;
! 
! 	DBG("");
! 
! 	if (session->abort_request != NULL)
! 		session->abort_request(session);
! 
! 	session->aborted = TRUE;
! 	session->abort_request = NULL;
! 	session->request_data = NULL;
  }
diff -crN plugins/messages.h plugins/messages.h
*** plugins/messages.h	Tue Oct  2 04:11:18 2012
--- plugins/messages.h	Tue Oct  2 04:37:04 2012
***************
*** 24,29 ****
--- 24,31 ----
  #include <glib.h>
  #include <stdint.h>
  
+ #include "bmsg_parser.h"
+ 
  /* Those are used by backend to notify transport plugin which properties did it
   * send.
   */
***************
*** 177,185 ****
   * To unregister currently registered notifications, call this with send_event
   * set to NULL.
   */
  int messages_set_notification_registration(void *session,
! 		void (*send_event)(void *session,
! 			const struct messages_event *event, void *user_data),
  		void *user_data);
  
  /* Changes current directory.
--- 179,190 ----
   * To unregister currently registered notifications, call this with send_event
   * set to NULL.
   */
+ typedef void (*messages_event_cb)(void *session,
+ 		const struct messages_event *event,
+ 		void *user_data);
+ 
  int messages_set_notification_registration(void *session,
! 		messages_event_cb callback,
  		void *user_data);
  
  /* Changes current directory.
***************
*** 237,244 ****
  #define MESSAGES_UTF8		(1 << 1)
  #define MESSAGES_FRACTION	(1 << 2)
  #define MESSAGES_NEXT		(1 << 3)
  
! /* Retrieves bMessage object (see MAP specification, ch. 3.1.3) of a given
   * message.
   *
   * session: Backend session.
--- 242,251 ----
  #define MESSAGES_UTF8		(1 << 1)
  #define MESSAGES_FRACTION	(1 << 2)
  #define MESSAGES_NEXT		(1 << 3)
+ #define MESSAGES_TRANSPARENT	(1 << 4)
+ #define MESSAGES_RETRY		(1 << 5)
  
! /* Retrieves/sets bMessage object (see MAP specification, ch. 3.1.3) of a given
   * message.
   *
   * session: Backend session.
***************
*** 260,270 ****
--- 267,303 ----
  typedef void (*messages_get_message_cb)(void *session, int err, gboolean fmore,
  	const char *chunk, void *user_data);
  
+ typedef void (*messages_set_message_status_cb)(void *session, int err,
+ 		void *user_data);
+ 
  int messages_get_message(void *session, const char *handle,
  					unsigned long flags,
  					messages_get_message_cb callback,
  					void *user_data);
  
+ int messages_set_message_status(void *session, const char *handle,
+ 		uint8_t indicator, uint8_t value,
+ 		messages_set_message_status_cb callback,
+ 		void *user_data);
+ 
+ /* Push messages to the backend.
+  *
+  * session: Backend session.
+  * bmsg_bmsg:
+  * name:
+  * flags:
+  * user_data: User data if any to be sent.
+  * Callback shall be called ???
+  */
+ typedef void(*messages_push_message_cb)(void *session, int err,
+ 					const char *handle, void *user_data);
+ 
+ int messages_push_message(void *session, struct bmsg_bmsg *bmsg,
+ 				const char *name, unsigned long flags,
+ 				messages_push_message_cb cb, void *user_data);
+ 
+ int messages_push_message_body(void *session, const char *body, size_t len);
+ 
  /* Informs Message Server to Update Inbox via network.
   *
   * session: Backend session.
diff -crN test/mns-client test/mns-client
*** test/mns-client	Wed Dec 31 19:00:00 1969
--- test/mns-client	Tue Oct  2 04:37:04 2012
***************
*** 0 ****
--- 1,26 ----
+ #!/usr/bin/python -u
+ 
+ import dbus
+ import sys
+ import time
+ 
+ bus = dbus.SessionBus()
+ client = dbus.Interface(bus.get_object("org.openobex.client", "/"),
+ 						"org.openobex.Client")
+ print "Creating session...",
+ session_path = client.CreateSession({"Destination": sys.argv[1], "Target": "MNS"})
+ print "done (session path: %s)" % (session_path)
+ mns = dbus.Interface(bus.get_object("org.openobex.client", session_path),
+ 						"org.openobex.MNS")
+ 
+ print "Sending...",
+ mns.SendEvent(0,1,"31337","TELECOM/MSG/INBOX","",2)
+ print "done"
+ 
+ print "Removing session...",
+ client.RemoveSession(session_path)
+ print "done"
+ 
+ print "Sleeping...",
+ time.sleep(10)
+ print "done"
